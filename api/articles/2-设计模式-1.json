{"title":"设计模式-1","uid":"7674181de4c9b5a5cfd21fdfe784296a","slug":"2-设计模式-1","date":"2023-05-06T12:38:18.000Z","updated":"2023-05-08T14:03:50.197Z","comments":true,"path":"api/articles/2-设计模式-1.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式-1\"><a class=\"markdownIt-Anchor\" href=\"#设计模式-1\"></a> 设计模式-1</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>AI为入门者设计的学习思路：</p>\n<blockquote>\n<ol>\n<li>先理解什么是设计模式以及它的重要性和好处。可以阅读一些设计模式概述的文章或者书籍第一章。</li>\n<li>了解设计模式的分类和各个类别的主要模式。比如<strong>创建型模式</strong>有工厂模式、单例模式、建造者模式;<strong>结构型模式</strong>有代理模式、外观模式、适配器模式;<strong>行为型模式</strong>有策略模式、观察者模式、模板方法模式等。</li>\n<li>选择几个常用和简单的设计模式开始学习,比如<strong>工厂模式</strong>、<strong>单例模式</strong>、<strong>代理模式</strong>以及<strong>观察者模式</strong>。可以阅读相关书籍的内容,并做coding实践。</li>\n<li>继续学习其他常用模式,比如<strong>适配器模式</strong>、<strong>装饰器模式</strong>、<strong>外观模式</strong>、<strong>模板方法模式</strong>等。同样通过理论学习和coding实践进行深入理解。</li>\n<li>学习了常用设计模式后,可以了解一些不太常用但也很有用的设计模式,比如桥接模式、组合模式、命令模式、迭代器模式等。</li>\n<li>回顾设计模式学习,理解不同设计模式之间的区别和使用场景,学习如何选择合适的设计模式。</li>\n<li>项目实践,在实际项目中运用适当的设计模式,解决设计问题。实践出真知,项目实践是学习设计模式的最好方式。</li>\n<li>保持设计模式的学习和运用,跟踪设计模式的发展和演变,不断学习新的设计模式和案例</li>\n</ol></blockquote>\n</blockquote>\n<h2 id=\"一-设计模式相关概念\"><a class=\"markdownIt-Anchor\" href=\"#一-设计模式相关概念\"></a> 一、 设计模式相关概念</h2>\n<h3 id=\"一设计模式的简介\"><a class=\"markdownIt-Anchor\" href=\"#一设计模式的简介\"></a> （一）设计模式的简介</h3>\n<h4 id=\"1简述\"><a class=\"markdownIt-Anchor\" href=\"#1简述\"></a> 1.简述：</h4>\n<ul>\n<li>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>\n<li>设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。</li>\n</ul>\n<h4 id=\"2历史\"><a class=\"markdownIt-Anchor\" href=\"#2历史\"></a> 2.历史：</h4>\n<ul>\n<li>1995 年，GoF（Gang of Four，四人组）合作出版了<strong>Design Patterns: Elements of Reusable Object-Oriented Software</strong>一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称【GoF设计模式】。</li>\n</ul>\n<h3 id=\"二设计模式的七大原则\"><a class=\"markdownIt-Anchor\" href=\"#二设计模式的七大原则\"></a> （二）设计模式的七大原则</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设计模式有7大原则，目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p></blockquote>\n<p><img src=\"../img/2/principal.png\" alt=\"设计模式的七大原则\" /></p>\n<h4 id=\"1开闭原则open-closed-principleocp\"><a class=\"markdownIt-Anchor\" href=\"#1开闭原则open-closed-principleocp\"></a> 1.开闭原则（Open Closed Principle，OCP）</h4>\n<ul>\n<li>含义： 软件实体应当对扩展开放，对修改关闭</li>\n<li>表现：\n<ul>\n<li>扩展时，不修改原有代码或者尽量少修改原有代码</li>\n<li>修改时，尽量不修改原有代码或者尽量少修改原有代码</li>\n</ul>\n</li>\n<li>实现方法： 通过<strong>抽象约束、封装变化</strong>来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</li>\n</ul>\n<h4 id=\"2依赖倒置原则dependence-inversion-principledip\"><a class=\"markdownIt-Anchor\" href=\"#2依赖倒置原则dependence-inversion-principledip\"></a> 2.依赖倒置原则（Dependence Inversion Principle，DIP）</h4>\n<ul>\n<li>含义： 要面向接口编程，不要面向实现编程, 降低类间的耦合性</li>\n<li>表现：\n<ul>\n<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li>\n<li>抽象不应该依赖具体类，具体类应该依赖抽象</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>使用接口或抽象类进行变量类型声明、参数类型说明、方法返回类型声明、以及数据类型的转换等\n<ul>\n<li>在需要时，可将具体类通过依赖注入的方式注入到其他对象中</li>\n</ul>\n</li>\n<li>一个具体类应只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法</li>\n<li>任何类都不应该从具体类派生</li>\n<li>使用继承时尽量遵循里氏替换原则</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3里氏代换原则liskov-substitution-principlelsp\"><a class=\"markdownIt-Anchor\" href=\"#3里氏代换原则liskov-substitution-principlelsp\"></a> 3.里氏代换原则（Liskov Substitution Principle，LSP）</h4>\n<ul>\n<li>含义：所有引用基类的地方必须能 透明/不受影响 地使用其子类的对象（继承必须确保超类所拥有的性质在子类中仍然成立）</li>\n<li>表现：\n<ul>\n<li>子类可以替换任何基类，而程序逻辑不变</li>\n<li>子类可以扩展父类的功能，但不能改变父类原有的功能（即 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法）</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>\n<li>子类中可以增加自己特有的方法</li>\n<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>\n<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>\n<li>在类方法设计时，方法参数应尽量使用抽象类型（抽象类或接口）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4合成复用原则composite-reuse-principlecrp\"><a class=\"markdownIt-Anchor\" href=\"#4合成复用原则composite-reuse-principlecrp\"></a> 4.合成复用原则（Composite Reuse Principle，CRP）</h4>\n<ul>\n<li>含义：在一个新的对象里使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象委派以达到复用的目的</li>\n<li>表现：\n<ul>\n<li>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现；如果要使用继承关系，则必须严格遵循里氏替换原则</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5单一职责原则single-responsibility-principlesrp\"><a class=\"markdownIt-Anchor\" href=\"#5单一职责原则single-responsibility-principlesrp\"></a> 5.单一职责原则（Single Responsibility Principle，SRP）</h4>\n<ul>\n<li>含义：规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</li>\n</ul>\n<h4 id=\"6迪米特原则law-of-demeterlod最少知识原则least-knowledge-principlelkp\"><a class=\"markdownIt-Anchor\" href=\"#6迪米特原则law-of-demeterlod最少知识原则least-knowledge-principlelkp\"></a> 6.迪米特原则（Law of Demeter，LoD）/最少知识原则（Least Knowledge Principle，LKP)</h4>\n<ul>\n<li>含义：\n<ul>\n<li>一个软件实体应当尽可能少地与其他实体发生相互作用</li>\n<li>只与你的直接朋友交谈，不跟<strong>陌生人</strong>说话\n<ul>\n<li>迪米特法则中的<strong>朋友</strong>是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>表现：\n<ul>\n<li>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>\n<li>在类的结构设计上，尽量降低类成员的访问权限。</li>\n<li>在类的设计上，优先考虑将一个类设置成不变类。</li>\n<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>\n<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>\n<li>谨慎使用序列化（Serializable）功能。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7接口隔离原则interface-segregation-principleisp\"><a class=\"markdownIt-Anchor\" href=\"#7接口隔离原则interface-segregation-principleisp\"></a> 7.接口隔离原则（Interface Segregation Principle，ISP）</h4>\n<ul>\n<li>含义：使用多个专门的接口比使用单一的总接口要好</li>\n<li>表现：\n<ul>\n<li>客户端不应该被迫依赖于它不使用的方法</li>\n<li>一个类对另一个类的依赖应该建立在最小的接口上</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>\n<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>\n<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>\n<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>\n</ul>\n</li>\n</ul>\n<table>\n    <thead>\n        <tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr>\n    </thead>\n    <tbody>\n        <tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr>\n        <tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr>\n        <tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr>\n        <tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr>\n        <tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr>\n        <tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr>\n        <tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr>\n    </tbody>\n</table>\n<h3 id=\"三设计模式的类型\"><a class=\"markdownIt-Anchor\" href=\"#三设计模式的类型\"></a> （三）设计模式的类型</h3>\n<ul>\n<li>按目的划分\n<ul>\n<li>基本设计模式分为三大类：创建型、结构型、行为型。\n<ul>\n<li>创建型模式：处理的是<strong>对象的创建过程</strong>（通过各种方式创建对象，使对象创建和管理变得简单）</li>\n<li>结构型模式：处理的是<strong>对象/类的组合</strong></li>\n<li>行为型模式：处理<strong>类和对象间的交互方式和任务分布</strong>。（只有类可以创建对象，接口只能被实现）</li>\n</ul>\n</li>\n<li>其他设计模式：J2EE模式</li>\n</ul>\n</li>\n</ul>\n<table>\n<tbody>\n    <tr><th style=\"width:5%;\">序号</th><th style=\"width:45%;\">模式 &amp; 描述</th><th>包括</th></tr>\n    <tr>\n        <td>1</td>\n        <td><b>创建型模式</b><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>\n        <td>\n            <ul>\n            <li>工厂模式（Factory Pattern）</li>\n            <li>抽象工厂模式（Abstract Factory Pattern）</li>\n            <li>单例模式（Singleton Pattern）</li>\n            <li>建造者模式（Builder Pattern）</li>\n            <li>原型模式（Prototype Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td><b>结构型模式</b><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>\n        <td>\n            <ul>\n            <li>适配器模式（Adapter Pattern）</li>\n            <li>桥接模式（Bridge Pattern）</li>\n            <li>过滤器模式（Filter、Criteria Pattern）</li>\n            <li>组合模式（Composite Pattern）</li>\n            <li>装饰器模式（Decorator Pattern）</li>\n            <li>外观模式（Facade Pattern）</li>\n            <li>享元模式（Flyweight Pattern）</li>\n            <li>代理模式（Proxy Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td><b>行为型模式</b><br>这些设计模式特别关注对象之间的通信。</td>\n        <td>\n            <ul>\n            <li>责任链模式（Chain of Responsibility Pattern）</li>\n            <li>命令模式（Command Pattern）</li>\n            <li>解释器模式（Interpreter Pattern）</li>\n            <li>迭代器模式（Iterator Pattern）</li>\n            <li>中介者模式（Mediator Pattern）</li>\n            <li>备忘录模式（Memento Pattern）</li>\n            <li>观察者模式（Observer Pattern）</li>\n            <li>状态模式（State Pattern）</li>\n            <li>空对象模式（Null Object Pattern）</li>\n            <li>策略模式（Strategy Pattern）</li>\n            <li>模板模式（Template Pattern）</li>\n            <li>访问者模式（Visitor Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td><b>J2EE 模式</b><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>\n        <td>\n            <ul>\n            <li>MVC 模式（MVC Pattern）</li>\n            <li>业务代表模式（Business Delegate Pattern）</li>\n            <li>组合实体模式（Composite Entity Pattern）</li>\n            <li>数据访问对象模式（Data Access Object Pattern）</li>\n            <li>前端控制器模式（Front Controller Pattern）</li>\n            <li>拦截过滤器模式（Intercepting Filter Pattern）</li>\n            <li>服务定位器模式（Service Locator Pattern）</li>\n            <li>传输对象模式（Transfer Object Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n</tbody></table>\n<ul>\n<li>按作用范围划分\n<ul>\n<li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器均属于该模式</li>\n<li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-创建型模式\"><a class=\"markdownIt-Anchor\" href=\"#二-创建型模式\"></a> 二、 创建型模式</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>创建型模式的关注点是<strong>怎样创建对象</strong>，特点是<strong>将对象的创建与使用分离</strong>，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成</p>\n<ul>\n<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>\n<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>\n<li>单例（Singleton）模式：类只能产生一个实例，保证全局使用的是同一对象。</li>\n<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>\n<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>\n</ul></blockquote>\n<h3 id=\"一工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#一工厂模式\"></a> （一）工厂模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>工厂模式是常用的设计模式，一般分为简单工厂模式、工厂方法模式、抽象工厂模式三类。<br />\n工厂方法模式是对简单工厂模式的推广，抽象工厂模式是对工厂方法模式的推广。</p></blockquote>\n<h4 id=\"简单工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式\"></a> 简单工厂模式</h4>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>简单工厂模式是学习其他创建型模式的基础，不属于23种GOF设计模式之一。</p></blockquote>\n<h5 id=\"模式介绍\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍\"></a> 模式介绍</h5>\n<ol>\n<li>\n<p>模式动机：</p>\n<ul>\n<li>把对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的，只用告诉工厂我想要什么就行了。</li>\n<li><img src=\"../img/2/0-1.png\" alt=\"\" /></li>\n</ul>\n</li>\n<li>\n<p>模式定义：</p>\n<ul>\n<li>专门定义一个类并提供静态方法来负责创建其他具有共同父类的类的实例，根据静态方法传入的参数的不同返回不同类的实例。</li>\n<li>专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。</li>\n<li>简单工厂模式也称为静态工厂方法模式（Static Factory Method Pattern），属于类创建型模式。</li>\n</ul>\n</li>\n<li>\n<p>模式结构：</p>\n<ul>\n<li><img src=\"../img/2/0-2.png\" alt=\"\" /></li>\n</ul>\n</li>\n<li>\n<p>角色分析：</p>\n<ul>\n<li>Factory（工厂角色）：可提供创建产品时的静态方法</li>\n<li>Product（抽象产品角色）：产品的接口，是所有产品的父类</li>\n<li>ConcreteProduct（具体产品角色）：具体的产品实现类</li>\n</ul>\n</li>\n<li>\n<p>模式评价：</p>\n<ul>\n<li>优点\n<ul>\n<li>实现了对象创建和使用的分离</li>\n<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</li>\n<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>新增产品需要修改工厂类的代码，违反了开闭原则</li>\n<li>工厂类需要负责创建所有产品，如果产品类型过多，工厂类的代码会变得过于复杂</li>\n<li>由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>当需要创建的对象具有相同的行为和属性时，可以使用简单工厂模式</li>\n<li>当一个类不知道它所需要的对象的类时，可以使用简单工厂模式，将创建对象的职责交给工厂类处理</li>\n<li>当需要在客户端中动态地根据条件创建不同的对象时，可以使用简单工厂模式</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>当系统中需要创建的具体产品类不断增多时，使用简单工厂模式会导致工厂类变得过于复杂，此时可以考虑使用工厂方法模式或者抽象工厂模式来解决问题，这两种方法根据系统的具体情况来确定，其中抽象工厂模式是更好的选择</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现\"><a class=\"markdownIt-Anchor\" href=\"#模式实现\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 核心思路\n&#x2F;&#x2F; 抽象产品类\ninterface Product &#123;\n    void operation();\n&#125;\n\n&#x2F;&#x2F; 具体产品类A\nclass ConcreteProductA implements Product &#123;\n    public void operation() &#123;\n        System.out.println(&quot;This is ConcreteProductA.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 具体产品类B\nclass ConcreteProductB implements Product &#123;\n    public void operation() &#123;\n        System.out.println(&quot;This is ConcreteProductB.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 工厂类\nclass Factory &#123;\n    public static Product createProduct(String type) &#123;\n        if (type.equals(&quot;A&quot;)) &#123;\n            return new ConcreteProductA();\n        &#125; else if (type.equals(&quot;B&quot;)) &#123;\n            return new ConcreteProductB();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Product productA &#x3D; Factory.createProduct(&quot;A&quot;);\n        Product productB &#x3D; Factory.createProduct(&quot;B&quot;);\n        productA.operation();\n        productB.operation();\n    &#125;\n&#125;</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 具体例子（此处采用具体类作产品父类，可改用接口作产品父类）\n&#x2F;&#x2F; Factory.java\n&#x2F;**\n * @Theme:工厂类\n * @Description:水果工厂\n *&#x2F;\npublic class Factory &#123;\n    public static Fruit createFruit(String type)&#123;\n        if(&quot;Pear&quot;.equals(type))&#123;\n            System.out.println(&quot;正在创建---------梨&quot;);\n            Pear pear &#x3D; new Pear();\n            pear.name &#x3D; &quot;梨&quot;;\n            pear.color &#x3D; &quot;黄色&quot;;\n            return pear;\n        &#125;else if(&quot;Apple&quot;.equals(type))&#123;\n            System.out.println(&quot;正在创建---------苹果&quot;);\n            Apple apple &#x3D; new Apple();\n            apple.name &#x3D; &quot;苹果&quot;;\n            apple.color &#x3D; &quot;红色&quot;;\n            return apple;\n        &#125;else &#123;\n            System.out.println(&quot;正在创建---------&quot;+type);\n            System.out.println(&quot;该工厂无法创建该产品：&quot;+type);\n            return null;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Fruit.java\n&#x2F;**\n * @Theme:抽象产品类\n * @Description:水果类\n *&#x2F;\npublic class Fruit &#123;\n    public String name;\n    public String color;\n    public void eat()&#123;\n        System.out.println(&quot;----------吃完啦----------&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Pear.java\n&#x2F;**\n * @Theme:具体产品类\n * @Description:具体产品-梨\n *&#x2F;\npublic class Pear extends Fruit &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(this.name+&quot;正在被吃······&quot;);\n        super.eat();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;NAME:&quot;+this.name+&quot;----COLOR:&quot;+this.color;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Apple.java\n&#x2F;**\n * @Theme: 具体产品类\n * @Description: 具体产品-苹果\n *&#x2F;\npublic class Apple extends Fruit&#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(this.name+&quot;正在被吃······&quot;);\n        super.eat();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;NAME:&quot;+this.name+&quot;----COLOR:&quot;+this.color;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Client.java\n\n&#x2F;**\n * @Theme: 客户端\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;现在想让该水果工厂给我生产水果给我吃\n\n        &#x2F;&#x2F;1.吃苹果\n        Fruit fruit;\n        fruit &#x3D; Factory.createFruit(&quot;Apple&quot;);\n        System.out.println(fruit.toString());\n        fruit.eat();\n\n        &#x2F;&#x2F;1.吃梨\n        fruit &#x3D; Factory.createFruit(&quot;Pear&quot;);\n        System.out.println(fruit.toString());\n        fruit.eat();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 运行结果\n\n    正在创建---------苹果\n    NAME:苹果----COLOR:红色\n    苹果正在被吃······\n    ----------吃完啦----------\n    正在创建---------梨\n    NAME:梨----COLOR:黄色\n    梨正在被吃······\n    ----------吃完啦----------</code></pre>\n<h4 id=\"工厂方法模式\"><a class=\"markdownIt-Anchor\" href=\"#工厂方法模式\"></a> 工厂方法模式</h4>\n<h5 id=\"模式介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-2\"></a> 模式介绍</h5>\n<ol>\n<li>\n<p>模式动机：</p>\n<ul>\n<li>在不修改已有具体工厂类的情况下引进新的产品，即满足开闭原则的要求</li>\n</ul>\n</li>\n<li>\n<p>模式定义：</p>\n<ul>\n<li>定义一个用于创建对象的接口，可让子类去决定将哪一个类进行实例化</li>\n<li>将产品类的实例化过程延迟到工厂子类完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</li>\n<li>工厂方法模式简称工厂模式，又可称虚拟构造器或者多态工厂模式，属于类创建型模式</li>\n</ul>\n</li>\n<li>\n<p>模式结构：</p>\n<ul>\n<li><img src=\"../img/2/1-1.png\" alt=\"工厂方法模式结构图\" /></li>\n</ul>\n</li>\n<li>\n<p>角色分析：</p>\n<ul>\n<li>抽象产品Product：定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类</li>\n<li>具体产品ConcreteProduct：实现抽象产品所定义的接口，负责具体产品的业务逻辑</li>\n<li>抽象工厂Factory：定义工厂的接口，是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口</li>\n<li>具体工厂ConcreteFactory：实现抽象工厂定义的接口，负责实例化具体的产品对象</li>\n</ul>\n</li>\n<li>\n<p>模式评价：</p>\n<ul>\n<li>优点\n<ul>\n<li>封装对象的创建过程：工厂模式将对象的创建过程封装到工厂类中，避免了客户端直接依赖具体的产品类，从而提高了代码的可维护性和可扩展性。</li>\n<li>创建多个产品族或产品等级结构：当需要创建多个产品族或产品等级结构时，工厂模式可以提供一个统一的接口，方便客户端进行调用。</li>\n<li>符合开闭原则：当需要添加新的产品时，只需要增加相应的产品类和工厂方法即可，不需要修改原有的代码，符合开闭原则。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>产品等级结构复杂时，会有大量的与之对应的工厂类，增加了系统的复杂度</li>\n<li>增加了系统的抽象性和理解难度</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>需要创建多个产品族或产品等级结构：当需要创建多个产品族或产品等级结构时，工厂模式可以提供一个统一的接口，方便客户端进行调用。</li>\n<li>需要封装对象的创建过程：当对象的创建过程比较复杂，或者需要依赖其他类的时候，可以使用工厂模式来封装对象的创建过程。</li>\n<li>需要动态切换产品：当需要动态切换产品时，工厂模式可以提供一个统一的接口，方便客户端进行调用。</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现-2\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-2\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;某系统运行日志记录器(Logger)可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。\n&#x2F;&#x2F;为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;LoggerFactory.java\n\n&#x2F;**\n * @Theme:抽象工厂接口\n * @Description:包含一个抽象工厂方法\n *&#x2F;\npublic interface LoggerFactory &#123;\n    &#x2F;&#x2F;工厂方法\n    Logger createLogger();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;FileLoggerFactory.java\n\n&#x2F;**\n * @Theme: 文件日志器记录器工厂\n * @Description:\n *&#x2F;\npublic class FileLoggerFactory implements LoggerFactory&#123;\n    @Override\n    public Logger createLogger() &#123;\n        System.out.println(&quot;-----正在创建文件日志记录器----&quot;);\n        return new FileLogger();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;DatabaseLoggerFactory.java\n\n&#x2F;**\n * @Theme: 数据库日志器记录器工厂\n * @Description:\n *&#x2F;\npublic class DataBaseLoggerFactory implements LoggerFactory&#123;\n    @Override\n    public Logger createLogger() &#123;\n        System.out.println(&quot;-----正在创建数据库日志记录器----&quot;);\n        return new DataBaseLogger();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Logger.java\n\n&#x2F;**\n * @Theme: 抽象产品接口\n * @Description: 包含一个写日志方法抽象方法\n *&#x2F;\npublic interface Logger &#123;\n    void writeLog();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;FileLogger.java\n\n&#x2F;**\n * @Theme: 文件日志记录器\n * @Description:\n *&#x2F;\npublic class FileLogger implements Logger &#123;\n    @Override\n    public void writeLog() &#123;\n        System.out.println(&quot;正在使用文件日志记录器记录日志&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;DataBaseLogger.java\n\n&#x2F;**\n * @Theme: 数据库日志记录器\n * @Description:\n *&#x2F;\npublic class DataBaseLogger implements Logger&#123;\n    @Override\n    public void writeLog() &#123;\n        System.out.println(&quot;正在使用数据库日志记录器记录日志&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Client.java\n\n&#x2F;**\n * @Theme: 客户端类\n * @Description: 测试\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        LoggerFactory factory;\n        Logger logger;\n\n        &#x2F;&#x2F;创建工厂类,并强制转换\n        factory &#x3D; (LoggerFactory)XMLUtil.getBean();\n\n        &#x2F;&#x2F;调用工厂方法，创建产品对象\n        logger &#x3D; factory.createLogger();\n\n        &#x2F;&#x2F;调用日志记录方法\n        logger.writeLog();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;XMLUtil.java\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.File;\n\n&#x2F;**\n * @Theme: 配置文件+反射实现 对象生成\n * @Description:工具类\n *&#x2F;\npublic class XMLUtil &#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取类的类型，并创建对象\n    public static Object getBean()&#123;\n        try &#123;\n            &#x2F;&#x2F;创建文档对象\n            DocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n            Document doc;\n            doc &#x3D; builder.parse(new File(&quot;&#x2F;config.xml&quot;));\n\n            &#x2F;&#x2F;获取类名的文本节点\n            NodeList nl &#x3D; doc.getElementsByTagName(&quot;className&quot;);\n            Node classNode &#x3D; nl.item(0).getFirstChild();\n            String className &#x3D; classNode.getNodeValue().trim();\n\n            &#x2F;&#x2F;通过类名生成实例对象并返回\n            Class c &#x3D; Class.forName(className);\n            Object o &#x3D; c.newInstance();\n            return o;\n        &#125;\n        catch(Exception e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;config.xml\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n    &lt;className&gt;FileLoggerFactory&lt;&#x2F;className&gt;\n&lt;&#x2F;config&gt;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n\n    -----正在创建文件日志记录器----\n    正在使用文件日志记录器记录日志</code></pre>\n<h3 id=\"二抽象工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#二抽象工厂模式\"></a> （二）抽象工厂模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>产品等级结构也就是产品的继承结构——产品等级结构中的产品是从属关系，也就是说某一个产品是由某一个产品衍生出来的</li>\n<li>产品族是指同一个工厂生产的，位于不同产品等级结构中的一组产品——产品族中的产品是平行关系</li>\n<li>从产品等级结构和产品族看工厂</li>\n</ul>\n<blockquote>\n<ul>\n<li>工厂方法模式<br />\n​    :每个具体工厂只有一个或者一组重载的工厂方法们，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必增加系统的开销。</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>抽象工厂模式<br />\n:一个工厂可以生产一系列产品（一族产品），极大地减少了工厂类的数量</li>\n</ul></blockquote>\n<ul>\n<li>在工厂方法模式中，我们只需要实现一个工厂方法，它负责创建一个特定类型的对象。而在抽象工厂模式中，我们需要实现一个工厂接口，它负责创建一组相关的对象。</li>\n</ul>\n</blockquote>\n<h5 id=\"模式介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-3\"></a> 模式介绍</h5>\n<ol>\n<li>模式动机：\n<ul>\n<li>抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品</li>\n<li>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率</li>\n<li>抽象工厂模式的主要用途是创建一组相关的对象，它在多个对象之间存在一系列的约束，抽象工厂模式将这些约束条件统一到一个接口中，使得在调用方不需要关心具体的约束条件</li>\n<li><img src=\"../img/2/2-1.png\" alt=\"抽象工厂模式动机图\" /></li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类</li>\n<li>抽象工厂模式又称为Kit模式，属于对象创建型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/2/2-2.png\" alt=\"抽象工厂模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象工厂AbstactFactory:提供了创建产品的接口，它包含多个创建产品的方法createProduct()</li>\n<li>具体工厂ConcreteFactory:实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中</li>\n<li>抽象产品AbstractProduct:为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法</li>\n<li>具体产品ConcreteProduct:定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法</li>\n</ul>\n</li>\n<li>模式评价：\n<ul>\n<li>优点\n<ul>\n<li>可以封装一组相关对象的创建逻辑，从而提高代码的可维护性和可扩展性。</li>\n<li>可以帮助客户端代码与具体类的解耦，从而提高代码的灵活性和可移植性。</li>\n<li>可以通过工厂的切换来实现对不同平台或不同产品系列/族的支持，同时又不会对客户端代码造成影响</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>在新增产品等级结构时，需要修改工厂接口及所有具体工厂类的实现，从而增加了代码的维护成本。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>抽象工厂模式通常在需要支持多种产品系列、动态切换产品系列或稳定不变的产品族和产品等级结构的场景中被使用。</li>\n<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li>\n<li>系统中有多于一个的产品族，但每次只使用其中某一产品族</li>\n<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来</li>\n<li>产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现-3\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-3\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象工厂接口\ninterface GUIFactory &#123;\n    Button createButton();\n    TextBox createTextBox();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 具体工厂类 - Windows工厂\nclass WinFactory implements GUIFactory &#123;\n    public Button createButton() &#123;\n        return new WinButton();\n    &#125;\n\n    public TextBox createTextBox() &#123;\n        return new WinTextBox();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 具体工厂类 - Mac工厂\nclass MacFactory implements GUIFactory &#123;\n    public Button createButton() &#123;\n        return new MacButton();\n    &#125;\n\n    public TextBox createTextBox() &#123;\n        return new MacTextBox();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象按钮类\nabstract class Button &#123;\n    public abstract void paint();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象文本框类\nabstract class TextBox &#123;\n    public abstract void paint();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Windows按钮类\nclass WinButton extends Button &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Windows按钮&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Windows文本框类\nclass WinTextBox extends TextBox &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Windows文本框&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Mac按钮类\nclass MacButton extends Button &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Mac按钮&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Mac文本框类\nclass MacTextBox extends TextBox &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Mac文本框&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class client&#123;\n    public static void main(String []args)&#123;\n        GUIFactory factory1 &#x3D; new WinFactory();\n        Button button1 &#x3D; factory1.createButton();\n        TextBox textBox1 &#x3D; factory1.createTextBox();\n        button1.paint();\n        textBox1.paint();\n        \n        GUIFactory factory2 &#x3D; new MacFactory();\n        Button button2 &#x3D; factory2.createButton();\n        TextBox textBox2 &#x3D; factory2.createTextBox();\n        button2.paint();\n        textBox2.paint();\n        \n    &#125;\n&#125;\n&#x2F;&#x2F;结果\n        Windows按钮\n        Windows文本框\n        Mac按钮\n        Mac文本框</code></pre>\n<h3 id=\"三单例模式\"><a class=\"markdownIt-Anchor\" href=\"#三单例模式\"></a> （三）单例模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>单例模式是一种对象创建型模式，单例模式又称为单件模式或单态模式</p></blockquote>\n<h5 id=\"模式介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-4\"></a> 模式介绍</h5>\n<ol>\n<li>模式动机：\n<ul>\n<li>确保一个类只能创建一个实例，并提供一种全局访问这个实例的方式</li>\n<li>在单例类的外部无法使用运算符new创建，否则该类的对象就不是单例</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>确保一个类只有一个实例，并提供一个全局的访问点来访问这个唯一的实例</li>\n<li>单例模式属于对象创建型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/2/3-1.png\" alt=\"单例模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>单例Singleton：负责保存自己的唯一实例，并提供给外部访问该实例的方法\n<ul>\n<li>提供一个自身类型的静态私有成员变量instance，用于保存自身的唯一实例</li>\n<li>构造函数私有化，以确保外部无法通过构造函数创建自身的实例</li>\n<li>提供一个公有的静态工厂方法getInstance()，用于获取自身的唯一实例\n<ul>\n<li>如果instance为null，则创建自身的唯一实例并返回</li>\n<li>如果instance不为null，则直接返回instance</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模式评价：\n<ul>\n<li>优点\n<ul>\n<li>提供了对唯一实例的受控访问</li>\n<li>可以节约系统资源，提高系统的性能</li>\n<li>允许可变数目的实例（多例类）</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>扩展困难（缺少抽象层）</li>\n<li>单例类的职责过重</li>\n<li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>在需要确保全局只有一个实例的场景中使用\n<ul>\n<li>线程池：在多线程环境下，线程池需要保证只有一个实例。</li>\n<li>数据库连接池：同样地，数据库连接池也需要保证只有一个实例。</li>\n<li>日志对象：日志对象通常是全局可见的，因此需要保证只有一个实例。</li>\n<li>配置文件：在某些情况下，需要全局共享的配置文件也需要保证只有一个实例。</li>\n</ul>\n</li>\n<li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li>\n<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>线程安全性：如上所述，如果多个线程同时访问getInstance()方法，可能会导致多个实例的创建。因此，需要确保getInstance()方法是线程安全的，可以通过synchronized关键字来实现。</li>\n<li>序列化问题：如果单例类实现了Serializable接口，那么在反序列化时可能会创建多个实例。解决方法是在类中添加readResolve()方法，并返回单例实例。</li>\n<li>反射问题：通过反射机制，可以调用私有构造函数创建实例。解决方法是在构造函数中添加判断，如果已经存在实例则抛出异常</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现-4\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-4\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1懒汉式单例模式\n&#x2F;&#x2F;懒汉式单例模式指的是在第一次使用单例对象时才创建实例。\n&#x2F;&#x2F;具体实现方式是在getInstance()方法中判断实例是否已经被创建，如果没有则创建一个新实例并返回。\n**懒汉式单例模式的缺点是线程不安全，在多线程环境下可能会创建多个实例。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Singleton instance;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;2饿汉式单例模式\n&#x2F;&#x2F;饿汉式单例模式指的是在类加载时就创建实例，而不管是否需要使用该实例。\n&#x2F;&#x2F;具体实现方式是在类加载时就创建实例，并使用静态私有成员变量保存唯一实例。\n&#x2F;&#x2F;由于在类加载时就创建了实例，因此不存在线程安全性问题。\n**饿汉式单例模式的缺点是在类加载时就创建实例，如果该实例在整个系统中都没有被使用过，则会造成内存的浪费。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; new Singleton();\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;3双重检验锁懒汉式单例模式\n&#x2F;&#x2F;双重检验锁单例模式是一种线程安全的单例模式实现方式，它通过使用synchronized关键字来确保线程安全性。\n&#x2F;&#x2F;具体实现方式是在getInstance()方法中添加双重检验锁，这可以避免不必要的锁竞争和实例化。\n&#x2F;&#x2F;使用双重检查锁定需要在静态成员变量前加上volatile关键字，是为了取消虚拟机所做的一些代码优化，并且只能在JDK1.5上面执行。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123; \n    private volatile static Singleton instance &#x3D; null; \n    private Singleton() &#123; &#125; \n    public static Singleton getInstance() &#123; \n        &#x2F;&#x2F;第一重判断\n        if (instance &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F;锁定代码块\n            synchronized (Singleton.class) &#123;\n                &#x2F;&#x2F;第二重判断\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton(); &#x2F;&#x2F;创建单例实例\n                &#125;\n            &#125;\n        &#125;\n        return instance; \n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;4静态内部类单例模式\n&#x2F;&#x2F;静态内部类单例模式是一种线程安全的单例模式实现方式，它通过使用静态内部类和类的初始化来保证线程安全性。\n&#x2F;&#x2F;静态内部类单例模式是利用了静态内部类只会在被使用时才会加载的特点，避免了饿汉式单例模式的资源浪费和懒汉式单例模式的线程不安全问题。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static class SingletonHolder &#123;\n        private static final Singleton INSTANCE &#x3D; new Singleton();\n    &#125;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return SingletonHolder.INSTANCE;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;5枚举单例模式\n&#x2F;&#x2F;枚举单例模式是一种更为简单和安全的单例模式实现方式，它利用了Java中枚举类型本身就是单例的特点。\n&#x2F;&#x2F;枚举单例模式是一种天然线程安全的单例模式实现方式，而且可以防止反射和序列化等攻击。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic enum Singleton &#123;\n    INSTANCE;\n    \n    &#x2F;&#x2F; 其他方法\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;6ThreadLocal单例模式\n&#x2F;&#x2F;ThreadLocal单例模式是一种可以在多线程环境下确保单例对象的线程安全单例模式实现方式。\n&#x2F;&#x2F;具体实现方式是在ThreadLocal中保存单例对象，每个线程都有自己的ThreadLocal副本，从而避免了线程安全性问题。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static final ThreadLocal&lt;Singleton&gt; INSTANCE &#x3D; new ThreadLocal&lt;Singleton&gt;() &#123;\n        @Override\n        protected Singleton initialValue() &#123;\n            return new Singleton();\n        &#125;\n    &#125;;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return INSTANCE.get();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;7注册式单例模式\n&#x2F;&#x2F;注册式单例模式指的是通过一个注册表来管理所有单例对象，从而实现单例模式。\n&#x2F;&#x2F;具体实现方式是在一个静态的Map中保存所有单例对象，然后在需要使用单例对象时通过Map来获取。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Map&lt;String, Singleton&gt; instances &#x3D; new HashMap&lt;&gt;();\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance(String name) &#123;\n        if (!instances.containsKey(name)) &#123;\n            instances.put(name, new Singleton());\n        &#125;\n        return instances.get(name);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子：\nimport java.sql.Connection;\nimport java.sql.DriverManager;\n \npublic class DBHelper &#123;\n\t\n\tprivate static final String driver &#x3D; &quot;com.mysql.jdbc.Driver&quot;;&#x2F;&#x2F;数据库驱动\n\tprivate static final String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gumysql?useUnicon&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;;\n\tprivate static final String username &#x3D; &quot;root&quot;;\n\tprivate static final String password &#x3D; &quot;root&quot;;\n\t\n\tstatic\n\t&#123;\n\t\ttry \n\t\t&#123;\n\t\t\tClass.forName(driver);\n\t\t&#125;\n\t\tcatch (Exception e)\n\t\t&#123;\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\t\n\tprivate static Connection conn &#x3D; null;\n\t&#x2F;&#x2F;单例模式返回数据库连接\n\tpublic static Connection getConnection() throws Exception\n\t&#123;\n\t\tif(conn &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tconn &#x3D; DriverManager.getConnection(url, username, password);\n\t\t\treturn conn;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn conn;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n<h3 id=\"四建造者模式\"><a class=\"markdownIt-Anchor\" href=\"#四建造者模式\"></a> （四）建造者模式</h3>\n<h5 id=\"模式介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-5\"></a> 模式介绍</h5>\n<ol>\n<li>\n<p>模式动机：</p>\n<ul>\n<li>主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li>\n</ul>\n</li>\n<li>\n<p>模式定义：</p>\n<ul>\n<li>将一个复杂对象的构建与它的表示相分离，使得同样的构建过程可以创建不同的表示</li>\n<li>建造者模式通过将复杂对象的构建过程分解为多个简单的步骤来实现</li>\n<li>建造者模式属于对象创建型模式</li>\n</ul>\n</li>\n<li>\n<p>模式结构：<br />\n<img src=\"../img/2/4-1.png\" alt=\"建造者模式结构图\" /></p>\n</li>\n<li>\n<p>角色分析：</p>\n<ul>\n<li>抽象建造者Builder：为创建一个产品对象的各个部件指定抽象接口和返回完整产品的抽象方法</li>\n<li>具体建造者ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口</li>\n<li>产品Product：表示被构造的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口</li>\n<li>指挥者Director：构造一个使用Builder接口的对象，指导构建过程，包含一个建造者的成员变量，用于指导建造过程，如何创建一个完整的产品对象</li>\n</ul>\n</li>\n<li>\n<p>模式评价：</p>\n<ul>\n<li>优点\n<ul>\n<li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>\n<li>可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则</li>\n<li>可以更容易地控制对象的创建过程，同时使得代码更易于维护和扩展</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制</li>\n<li>如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>当需要创建多个相似对象时，例如使用相同的构建过程创建不同的表示。</li>\n<li>当创建一个对象需要多个步骤时，例如需要设置多个属性或调用多个方法。</li>\n<li>当需要在不同的上下文中创建不同的对象表示时，例如根据用户的选择创建不同的表示。</li>\n<li>当需要控制对象的创建过程，并且希望代码易于维护和扩展时。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现-5\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-5\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;假设我们正在构建一个游戏，游戏中有多种类型的角色，每种角色都有不同的属性和装备。为了避免在创建每个角色时重复的代码，我们可以使用建造者模式。\n&#x2F;&#x2F;Actor角色类:复合产品\nclass Actor &#123;\n    private String type;\n    private String sex;\n    private String skill;\n\n    &#x2F;&#x2F;Getter and Setter: 略\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;角色建造器:抽象建造者\nabstract class ActorBuilder &#123;\n    protected Actor actor &#x3D; new Actor();\n\n    public abstract void buildType();\n    public abstract void buildSex();\n    public abstract void buildSkill();\n\n    public Actor createActor()&#123;\n        return actor;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;吸血鬼建造器:具体建造者\nclass VampireBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;吸血鬼&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;男&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;吸血&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;狼人建造器:具体建造者\nclass WerewolfBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;狼人&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;男&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;撕咬&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;女巫建造器:具体建造者\nclass WitchBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;女巫&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;女&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;魔法&quot;);\n    &#125;\n&#125;\n&#x2F;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Actor角色创建控制器:指挥者\nclass ActorController &#123;\n    public Actor construct(ActorBuilder ab)&#123;\n        Actor actor;\n        ab.buildType();\n        ab.buildSex();\n        ab.buildSkill();\n        actor &#x3D; ab.createActor();\n        return actor;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\nclass Client &#123;\n    public static void main(String[] args) &#123;\n        ActorController ac &#x3D; new ActorController();\n        \n        ActorBuilder ab &#x3D; new VampireBuilder();\n        Actor vampire &#x3D; ac.construct(ab);\n        System.out.println(vampire.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+vampire.getSex());\n        System.out.println(&quot;技能:&quot;+vampire.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n        \n        ActorBuilder ab2 &#x3D; new WerewolfBuilder();\n        Actor werewolf &#x3D; ac.construct(ab2);\n        System.out.println(werewolf.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+werewolf.getSex());\n        System.out.println(&quot;技能:&quot;+werewolf.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n        \n        ActorBuilder ab3 &#x3D; new WitchBuilder();\n        Actor witch &#x3D; ac.construct(ab3);\n        System.out.println(witch.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+witch.getSex());\n        System.out.println(&quot;技能:&quot;+witch.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    吸血鬼的游戏设定:\n    性别:男\n    技能:吸血\n    ---------------------------\n    狼人的游戏设定:\n    性别:男\n    技能:撕咬\n    ---------------------------\n    女巫的游戏设定:\n    性别:女\n    技能:魔法\n    ---------------------------</code></pre>\n<h3 id=\"五原型模式\"><a class=\"markdownIt-Anchor\" href=\"#五原型模式\"></a> （五）原型模式</h3>\n<h5 id=\"模式介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-6\"></a> 模式介绍</h5>\n<ol>\n<li>模式动机：\n<ul>\n<li>原型模式通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>使用原型对象实例指定待创建的对象的类型，并且通过复制这个原型来创建新的对象</li>\n<li>属于对象创建型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/2/5-1.png\" alt=\"原型模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>Prototype 抽象原型类：规定了具体原型对象必须实现的接口clone()</li>\n<li>ConcretePrototype 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象</li>\n<li>Client 客户类：让一个原型对象克隆自身从而创建一个新的对象</li>\n</ul>\n</li>\n<li>模式评价：\n<ul>\n<li>优点：\n<ul>\n<li>原型模式允许在运行时动态改变具体的实现类型</li>\n<li>原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了</li>\n<li>原型模式配合多线程使用时，要注意线程安全问题</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”</li>\n<li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改</li>\n<li>系统要保存对象的状态，而对象的状态变化很小</li>\n<li>需要避免使用分层次的工厂类来创建分层次的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>深克隆与浅克隆\n<ul>\n<li>浅克隆\n<ul>\n<li>当原型对象被复制时，只是复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制</li>\n<li><img src=\"../img/2/5-2.png\" alt=\"浅克隆\" /></li>\n</ul>\n</li>\n<li>深克隆\n<ul>\n<li>除了对象本身被复制外，对象所包含的所有成员变量也将被复制</li>\n<li><img src=\"../img/2/5-3.png\" alt=\"深克隆\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"模式实现-6\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-6\"></a> 模式实现</h5>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子-浅克隆\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 照片类\n * @Description:\n *&#x2F;\npublic class Photo &#123;\n    &#x2F;&#x2F;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 简历类\n * @Description:\n *&#x2F;\npublic class Resume implements Cloneable&#123;\n    private Photo photo;&#x2F;&#x2F;照片\n\n    public Photo getPhoto() &#123;\n        return photo;\n    &#125;\n\n    public void setPhoto(Photo photo) &#123;\n        this.photo &#x3D; photo;\n    &#125;\n\n    &#x2F;&#x2F;使用clone()方法来实现浅克隆\n    public Resume clone()&#123;\n        Object o &#x3D; null;\n        try &#123;\n            o &#x3D; super.clone();\n            return (Resume) o;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            System.out.println(&quot;不支持复制&quot;);\n            e.printStackTrace();\n        &#125;\n\n        return null;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Resume  previousResume,newResume;\n\n        previousResume &#x3D; new Resume();\n        &#x2F;&#x2F;添加照片\n        Photo photo &#x3D; new Photo();\n        previousResume.setPhoto(photo);\n\n        &#x2F;&#x2F;开始复制\n        newResume &#x3D; previousResume.clone();\n\n        &#x2F;&#x2F;比较简历\n        System.out.println(&quot;简历是否相同？&quot; + (previousResume &#x3D;&#x3D; newResume));\n        &#x2F;&#x2F;比较照片\n        System.out.println(&quot;照片是否相同（是：直接引用原照片|否：新照片）？&quot; + (previousResume.getPhoto() &#x3D;&#x3D; newResume.getPhoto()));\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    简历是否相同？false\n    照片是否相同（是：直接引用原照片|否：新照片）？true</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子-深克隆\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 照片类\n * @Description:\n *&#x2F;\npublic class Photo &#123;\n    &#x2F;&#x2F;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 简历类\n * @Description:\n *&#x2F;\nimport java.io.*;\n\npublic class Resume  implements Serializable &#123;\n    private Photo photo;&#x2F;&#x2F;照片\n\n    public Photo getPhoto() &#123;\n        return photo;\n    &#125;\n\n    public void setPhoto(Photo photo) &#123;\n        this.photo &#x3D; photo;\n    &#125;\n\n\n    &#x2F;&#x2F;实现深克隆\n    public Resume deepClone() throws IOException, ClassNotFoundException &#123;\n\n        &#x2F;&#x2F;1.将对象写到流\n        ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bao);\n        oos.writeObject(this);\n        &#x2F;&#x2F;将对象从流中取出\n        ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bao.toByteArray());\n        ObjectInputStream ois &#x3D; new ObjectInputStream(bis);\n        return (Resume) ois.readObject();\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\nimport java.io.IOException;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Resume previousResume,newResume;\n\n        previousResume &#x3D; new Resume();\n        &#x2F;&#x2F;添加照片\n        Photo photo &#x3D; new Photo();\n        previousResume.setPhoto(photo);\n\n        &#x2F;&#x2F;开始复制\n        try &#123;\n            newResume &#x3D; previousResume.deepClone();\n        &#125; catch (Exception e) &#123;\n            System.out.println(&quot;克隆失败&quot;);\n        &#125;\n\n        &#x2F;&#x2F;比较简历\n        System.out.println(&quot;简历是否相同？&quot; + (previousResume &#x3D;&#x3D; newResume));\n        &#x2F;&#x2F;比较照片\n        System.out.println(&quot;照片是否相同（是：直接引用原照片|否：新照片）？&quot; + (previousResume.getPhoto() &#x3D;&#x3D; newResume.getPhoto()));\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    简历是否相同？false\n    照片是否相同（是：直接引用原照片|否：新照片）？false</code></pre>\n<pre class=\"highlight\"><code class=\"\"># 参考文献/博客\n&gt; [1] [设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)  \n&gt; [2] [15分钟入门23种设计模式：图解，范例和对比](https://segmentfault.com/a/1190000043340405)  \n&gt; [3] [万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解](https://blog.csdn.net/penriver/article/details/118571991) \n&gt; [4] [纸短勤常在](https://blog.csdn.net/csu_hjh/category_11505231.html?spm=1001.2014.3001.5482)\n&gt; [5] [小薯条学技术](https://www.jianshu.com/u/4859d67311a2)</code></pre>\n","text":" 设计模式-1 AI为入门者设计的学习思路： 先理解什么是设计模式以及它的重要性和好处。可以阅读一些设计模式概述的文章或者书籍第一章。 了解设计模式的分类和各个类别的主要模式。比如创建型模式有工厂模式、单例模式、建造者模式;结构型模式有代理模式、外观模式、适配器模式;行为型模式有...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"48 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\"> 设计模式-1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> 一、 设计模式相关概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\"> （一）设计模式的简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E7%AE%80%E8%BF%B0\"><span class=\"toc-text\"> 1.简述：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E5%8E%86%E5%8F%B2\"><span class=\"toc-text\"> 2.历史：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\"> （二）设计模式的七大原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99open-closed-principleocp\"><span class=\"toc-text\"> 1.开闭原则（Open Closed Principle，OCP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99dependence-inversion-principledip\"><span class=\"toc-text\"> 2.依赖倒置原则（Dependence Inversion Principle，DIP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99liskov-substitution-principlelsp\"><span class=\"toc-text\"> 3.里氏代换原则（Liskov Substitution Principle，LSP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99composite-reuse-principlecrp\"><span class=\"toc-text\"> 4.合成复用原则（Composite Reuse Principle，CRP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99single-responsibility-principlesrp\"><span class=\"toc-text\"> 5.单一职责原则（Single Responsibility Principle，SRP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99law-of-demeterlod%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99least-knowledge-principlelkp\"><span class=\"toc-text\"> 6.迪米特原则（Law of Demeter，LoD）&#x2F;最少知识原则（Least Knowledge Principle，LKP)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99interface-segregation-principleisp\"><span class=\"toc-text\"> 7.接口隔离原则（Interface Segregation Principle，ISP）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\"> （三）设计模式的类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 二、 创建型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （一）工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 简单工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 工厂方法模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （二）抽象工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-3\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （三）单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-4\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-4\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （四）建造者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-5\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-5\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （五）原型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-6\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-6\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LR分析","uid":"b09a4c99d2d41cfb593f51df663274d6","slug":"3-LR分析","date":"2023-05-07T08:35:07.000Z","updated":"2023-05-08T11:58:36.274Z","comments":true,"path":"api/articles/3-LR分析.json","keywords":null,"cover":null,"text":" LR分析 概述 LR方法 LR分析法 LR分析器 下推栈 分析表 总控程序 LR(0)分析 LR(0)分析表构造 基本概念 构造过程 罗列所有的LR(0)项目 在文法的每个产生式右部添加一个圆点，就成为G的一个LR(0)项目（简称项目） 拓广文法：保证文法开始符号不出现在任何产...","link":"","photos":[],"count_time":{"symbolsCount":513,"symbolsTime":"1 mins."},"categories":[{"name":"编译原理 - LR分析","slug":"编译原理-LR分析","count":1,"path":"api/categories/编译原理-LR分析.json"}],"tags":[{"name":"编译原理","slug":"编译原理","count":1,"path":"api/tags/编译原理.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"软件架构实验","uid":"0957f802a029d0594b09e3b585318be7","slug":"1-软件架构实验","date":"2023-05-03T06:47:49.000Z","updated":"2023-05-06T06:28:14.438Z","comments":true,"path":"api/articles/1-软件架构实验.json","keywords":null,"cover":[],"text":" 软件架构实验 题目1 使用原始socket()实现一个C/S架构的应用，支持服务器时间回显示 要求：从客户端发送命令，接收服务器的时间并显示到终端 相关原理 C/S结构 socket python实现 环境：python3.9.13 编辑器：vscode 终端：powershe...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"软件架构","slug":"软件架构","count":2,"path":"api/tags/软件架构.json"},{"name":"实验","slug":"实验","count":1,"path":"api/tags/实验.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
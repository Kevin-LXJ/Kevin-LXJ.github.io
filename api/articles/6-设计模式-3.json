{"title":"设计模式-3","uid":"1282d363af11675dd608d5f2af6828ad","slug":"6-设计模式-3","date":"2023-05-08T15:06:41.000Z","updated":"2023-05-10T12:00:50.977Z","comments":true,"path":"api/articles/6-设计模式-3.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式-3\"><a class=\"markdownIt-Anchor\" href=\"#设计模式-3\"></a> 设计模式-3</h1>\n<h2 id=\"一-行为型模式\"><a class=\"markdownIt-Anchor\" href=\"#一-行为型模式\"></a> 一、 行为型模式</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>行为型模式关注的是<strong>各个类之间的相互作用</strong>，将职责划分清楚，使代码更加地清晰。描述程序在运行时复杂的流程控制，即描述<strong>多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。<br />\n行为型模式分为<strong>类行为模式</strong>和<strong>对象行为模式</strong>，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以<strong>对象行为模式比类行为模式具有更大的灵活性</strong>。</p>\n<ul>\n<li><strong>模板方法（Template Method）模式</strong>：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>\n<li><strong>策略（Strategy）模式</strong>：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>\n<li><strong>命令（Command）模式</strong>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>\n<li><strong>职责链（Chain of Responsibility）模式</strong>：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>\n<li><strong>状态（State）模式</strong>：允许一个对象在其内部状态发生改变时改变其行为能力。</li>\n<li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>\n<li><strong>中介者（Mediator）模式</strong>：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>\n<li><strong>迭代器（Iterator）模式</strong>：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>\n<li><strong>访问者（Visitor）模式</strong>：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>\n<li><strong>备忘录（Memento）模式</strong>：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>\n<li><strong>解释器（Interpreter）模式</strong>：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>\n</ul></blockquote>\n<h3 id=\"一策略模式\"><a class=\"markdownIt-Anchor\" href=\"#一策略模式\"></a> （一）策略模式</h3>\n<h4 id=\"模式介绍\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。</li>\n<li>在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。</li>\n<li>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化</li>\n<li>策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/1-1.png\" alt=\"策略模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>\n<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>\n<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>策略模式提供了对“开闭原则”的完美支持。</li>\n<li>策略模式提供了管理相关的算法族的办法。</li>\n<li>使用策略模式可以避免使用多重条件转移语句。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li>\n<li>策略模式将造成产生很多策略类和对象，可以通过享元模式在一定程度上减少对象的数量。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>\n<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>\n<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>\n<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>\n<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现\"><a class=\"markdownIt-Anchor\" href=\"#模式实现\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：\n&#x2F;&#x2F;(1) 学生凭学生证可享受票价8折优惠；\n&#x2F;&#x2F;(2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠；\n&#x2F;&#x2F;(3) 影院VIP用户除享受票价半价优惠外还可进行积分\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象策略类\npublic interface Discount&#123;\n\tpublic double calculate(double price);\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体策略类\n&#x2F;&#x2F;学生优惠\npublic class StudentDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;学生票：&quot;);\n\t\treturn price*0.8;\n\t&#125;\n&#125; \n\n\n&#x2F;&#x2F;儿童优惠\npublic class ChildDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;儿童票：&quot;);\n\t\treturn price-10;\n\t&#125;\n&#125; \n\n&#x2F;&#x2F;VIP优惠\npublic class VIPDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;VIP票：&quot;);\n\t\tSystem.out.println(&quot;增加积分！&quot;);\n\t\treturn price*0.5;\n\t&#125;\n&#125; \n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;环境类\npublic class MovieTicket &#123;\n\tprivate double price;\n\tprivate Discount discount;\n\tpublic void setPrice(double price)&#123;\n\t\tthis.price &#x3D; price;\n\t&#125;\n\tpublic void setDiscount(Discount d)&#123;\n\t\tthis.discount &#x3D; d;\n\t&#125;\n\tpublic double getPrice()&#123;\n\t\treturn discount.calculate(price);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;工具类XMLUtil\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\npublic class XMLUtil\n&#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取对应对象，并返回对象\n\tpublic static String getBean()\n\t&#123;\n\t\ttry\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;创建文档对象\n\t\t\tDocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc &#x3D; builder.parse(new File(&quot;config.xml&quot;)); \n\t\t\n\t\t\t&#x2F;&#x2F;获取包含类名的文本节点\n\t\t\tNodeList nl &#x3D; doc.getElementsByTagName(&quot;name&quot;);\n            Node classNode &#x3D; nl.item(0).getFirstChild();\n            String name &#x3D; classNode.getNodeValue().trim();\n            \n            return name;\n           &#125;   \n           \tcatch(Exception e)\n           \t&#123;\n           \t\te.printStackTrace();\n           \t\treturn null;\n           \t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n\t&lt;name&gt;VIPDiscount&lt;&#x2F;name&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tMovieTicket mt;\n\t\tDiscount discount;\n\t\tdiscount &#x3D; (Discount)XMLUtil.getBean();&#x2F;&#x2F;相当于获取特定的对象，如VIPDdiscount类\n\t\tmt &#x3D; new MovieTicket(discount);\n\t\tmt.setPrice(100);\n\t\tSystem.out.println(&quot;优惠后的价格：&quot;+mt.getPrice());\n\t&#125;\n&#125;</code></pre>\n<hr />\n<h3 id=\"二模板方法模式\"><a class=\"markdownIt-Anchor\" href=\"#二模板方法模式\"></a> （二）模板方法模式</h3>\n<h4 id=\"模式介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-2\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</li>\n<li>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</li>\n<li>这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>\n<li>它是一种类行为型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/2-1.png\" alt=\"模板方法模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象类/抽象模板（Abstract Class）：抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。\n<ul>\n<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>\n<li>基本方法：是整个算法中的一个步骤，包含以下几种类型。\n<ul>\n<li>抽象方法：在抽象类中声明，由具体子类实现。</li>\n<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>\n<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>具体子类/具体实现（Concrete Class）：具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>\n<li>它在父类中提取了公共的部分代码，便于代码复用。</li>\n<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>\n<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>\n<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>\n<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>\n<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-2\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-2\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;含钩子方法的抽象类\nabstract class HookAbstractClass &#123;\n    &#x2F;&#x2F;模板方法\n    public void TemplateMethod() &#123;\n        abstractMethod1();\n        HookMethod1();\n        if (HookMethod2()) &#123;\n            SpecificMethod();\n        &#125;\n        abstractMethod2();\n    &#125;\n    &#x2F;&#x2F;具体方法\n    public void SpecificMethod() &#123;\n        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);\n    &#125;\n    &#x2F;&#x2F;钩子方法1-需要子类重写的空方法\n    public void HookMethod1() &#123;\n    &#125;\n    &#x2F;&#x2F;钩子方法2-调用钩子方法控制某步骤是否执行\n    public boolean HookMethod2() &#123;\n        return true;\n    &#125;\n    &#x2F;&#x2F;抽象方法1\n    public abstract void abstractMethod1();\n    &#x2F;&#x2F;抽象方法2\n    public abstract void abstractMethod2();\n&#125;\n&#x2F;&#x2F;含钩子方法的具体子类\nclass HookConcreteClass extends HookAbstractClass &#123;\n    @Override\n    public void abstractMethod1() &#123;\n        System.out.println(&quot;抽象方法1的实现被调用...&quot;);\n    &#125;\n    @Override\n    public void abstractMethod2() &#123;\n        System.out.println(&quot;抽象方法2的实现被调用...&quot;);\n    &#125;\n    @Override\n    public void HookMethod1() &#123;\n        System.out.println(&quot;钩子方法1被重写...&quot;);\n    &#125;\n    @Override\n    public boolean HookMethod2() &#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class HookTemplateMethod &#123;\n    public static void main(String[] args) &#123;\n        HookAbstractClass tm &#x3D; new HookConcreteClass();\n        tm.TemplateMethod();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;运行结果：\n\n抽象方法1的实现被调用...\n钩子方法1被重写...\n抽象方法2的实现被调用...</code></pre>\n<hr />\n<h3 id=\"三备忘录模式\"><a class=\"markdownIt-Anchor\" href=\"#三备忘录模式\"></a> （三）备忘录模式</h3>\n<h4 id=\"模式介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-3\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。</li>\n<li>其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</li>\n<li>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</li>\n<li>该模式又叫快照模式。</li>\n<li>备忘录模式是一种对象行为型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/3-1.png\" alt=\"备忘录模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>\n<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>\n<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>\n<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>\n<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>\n<li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>备忘录的封装性\n<ul>\n<li>就是原发器可以访问备忘录类外其他不应该访问，所以在c++可以使用friend关键字，java可以将两个类放入一个包中，使他们之间可以满足默认的包可见性，也可以将备忘录类作为原发器的内部类。</li>\n</ul>\n</li>\n<li>多备份的实现\n<ul>\n<li>很多时候，负责人保存的状态不止一个的，所以对于备忘录类，可以设置一个集合容器存储多个历史状态。比如HashMap、ArrayList和栈</li>\n</ul>\n</li>\n<li>备忘录模式可以有另一种实现方式\n<ul>\n<li>将容器存储不单独成一个类，而是做一个容器放置在类属性，当我们需要存储历史状态时，我们可以通过克隆添加容器内,这样可能开发更为容易，但是有个问题就是克隆其实是整个对象整体克隆，就会占内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-3\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-3\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;备忘录\n&#x2F;&#x2F;这里是没有public的，采用默认的可见符，即包内可见\nclass Memento &#123;\n    private String account;\n    private String password;\n    private String telNo;\n\n    &#x2F;&#x2F;下面是三个属性构成的有参构造函数，getter、setter，这里不多展示\n&#125;\n&#x2F;&#x2F;发起人\npublic class UserInfoDTO &#123;\n    private String account;\n    private String password;\n    private String telNo;\n    \n    &#x2F;&#x2F;获取此时的快照，利用备忘录类作为载体返回\n    public Memento saveMemento()&#123;\n        return new Memento(account, password, telNo);\n    &#125;\n    \n    &#x2F;&#x2F;将历史记录快照进行恢复出来\n    public void restoreMemento(Memento memento)&#123;\n        this.account &#x3D; memento.getAccount();\n        this.password &#x3D; memento.getPassword();\n        this.telNo &#x3D; memento.getTelNo();\n    &#125;\n    \n    public void show()&#123;\n        System.out.println(&quot;Account:&quot; + this.account);\n        System.out.println(&quot;Password:&quot; + this.password);\n        System.out.println(&quot;TelNo:&quot; + this.telNo);\n    &#125;\n\n    &#x2F;&#x2F;下面是三个属性的setter、getter这里不多展示\n&#125;\n\n&#x2F;&#x2F;管理者\npublic class Caretaker &#123;\n    private Memento memento;&#x2F;&#x2F;容器存储历史状态\n    public Memento getMemento()&#123;\n        return memento;\n    &#125;\n    public void  setMemento(Memento memento)&#123;\n        this.memento &#x3D; memento;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserInfoDTO user &#x3D; new UserInfoDTO();\n        Caretaker c &#x3D; new Caretaker();\n        \n        user.setAccount(&quot;张三&quot;);\n        user.setPassword(&quot;123456&quot;);\n        user.setTelNo(&quot;13000000000&quot;);\n        System.out.println(&quot;状态一：&quot;);\n        user.show();\n        \n        c.setMemento(user.saveMemento());&#x2F;&#x2F;存储状态\n        System.out.println(&quot;-----------------------&quot;);\n        \n        user.setPassword(&quot;654321&quot;);\n        user.setTelNo(&quot;14000000000&quot;);\n        System.out.println(&quot;状态二：&quot;);\n        user.show();\n\n        System.out.println(&quot;-----------------------&quot;);\n        \n        user.restoreMemento(c.getMemento());&#x2F;&#x2F;恢复状态\n        System.out.println(&quot;回到状态一：&quot;);\n        user.show();\n    &#125;\n&#125;\n</code></pre>\n<hr />\n<h3 id=\"四观察者模式\"><a class=\"markdownIt-Anchor\" href=\"#四观察者模式\"></a> （四）观察者模式</h3>\n<h4 id=\"模式介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-4\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在某些场景中，需要建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</li>\n</ul>\n</li>\n<li>模式定义：<br />\n-定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。\n<ul>\n<li>观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/4-1.png\" alt=\"观察者模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>\n<li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>\n<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>\n<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>\n<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合，这样设计在增加观察者或被观察者的时候，都非常容易扩展，不修改原有代码只需要增加具体实现就可以进行扩展，符合“开闭原则”。</li>\n<li>建立一套触发机制，观察者模式可以更方便地实现具体业务中的复杂逻辑关系，形成逻辑链条。</li>\n<li>观察者模式支持广播通信。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>\n<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>\n<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>\n<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>\n<li>实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li>\n<li>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-4\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-4\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象目标\nabstract class Subject &#123;\n    protected List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n    &#x2F;&#x2F;增加观察者方法\n    public void add(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n    &#x2F;&#x2F;删除观察者方法\n    public void remove(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n    public abstract void notifyObserver(); &#x2F;&#x2F;通知观察者方法\n&#125;\n&#x2F;&#x2F;具体目标\nclass ConcreteSubject extends Subject &#123;\n    public void notifyObserver() &#123;\n        System.out.println(&quot;具体目标发生改变...&quot;);\n        System.out.println(&quot;--------------&quot;);\n        for (Object obs : observers) &#123;\n            ((Observer) obs).response();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象观察者\ninterface Observer &#123;\n    void response(); &#x2F;&#x2F;反应\n&#125;\n&#x2F;&#x2F;具体观察者1\nclass ConcreteObserver1 implements Observer &#123;\n    public void response() &#123;\n        System.out.println(&quot;具体观察者1作出反应！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;具体观察者1\nclass ConcreteObserver2 implements Observer &#123;\n    public void response() &#123;\n        System.out.println(&quot;具体观察者2作出反应！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class ObserverPattern &#123;\n    public static void main(String[] args) &#123;\n        Subject subject &#x3D; new ConcreteSubject();\n        Observer obs1 &#x3D; new ConcreteObserver1();\n        Observer obs2 &#x3D; new ConcreteObserver2();\n        subject.add(obs1);\n        subject.add(obs2);\n        subject.notifyObserver();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体目标发生改变...\n--------------\n具体观察者1作出反应！\n具体观察者2作出反应！</code></pre>\n<hr />\n<h3 id=\"五迭代器模式\"><a class=\"markdownIt-Anchor\" href=\"#五迭代器模式\"></a> （五）迭代器模式</h3>\n<h4 id=\"模式介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-5\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。</li>\n<li>“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。</li>\n<li>迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>\n<li>迭代器模式是一种对象行为型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/5-1.png\" alt=\"迭代器模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>\n<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>\n<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>\n<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>\n<li>遍历任务交由迭代器完成，这简化了聚合类。</li>\n<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>\n<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>\n<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>当需要为聚合对象提供多种遍历方式时。</li>\n<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>\n<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-5\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-5\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象聚合\ninterface Aggregate &#123;\n    public void add(Object obj);\n    public void remove(Object obj);\n    public Iterator getIterator();\n&#125;\n&#x2F;&#x2F;具体聚合\nclass ConcreteAggregate implements Aggregate &#123;\n    private List&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();\n    public void add(Object obj) &#123;\n        list.add(obj);\n    &#125;\n    public void remove(Object obj) &#123;\n        list.remove(obj);\n    &#125;\n    public Iterator getIterator() &#123;\n        return (new ConcreteIterator(list));\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象迭代器\ninterface Iterator &#123;\n    Object first();\n    Object next();\n    boolean hasNext();\n&#125;\n&#x2F;&#x2F;具体迭代器\nclass ConcreteIterator implements Iterator &#123;\n    private List&lt;Object&gt; list &#x3D; null;\n    private int index &#x3D; -1;\n    public ConcreteIterator(List&lt;Object&gt; list) &#123;\n        this.list &#x3D; list;\n    &#125;\n    public boolean hasNext() &#123;\n        if (index &lt; list.size() - 1) &#123;\n            return true;\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n    public Object first() &#123;\n        index &#x3D; 0;\n        Object obj &#x3D; list.get(index);\n        ;\n        return obj;\n    &#125;\n    public Object next() &#123;\n        Object obj &#x3D; null;\n        if (this.hasNext()) &#123;\n            obj &#x3D; list.get(++index);\n        &#125;\n        return obj;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class IteratorPattern &#123;\n    public static void main(String[] args) &#123;\n        Aggregate ag &#x3D; new ConcreteAggregate();\n        ag.add(&quot;中山大学&quot;);\n        ag.add(&quot;华南理工&quot;);\n        ag.add(&quot;清华大学&quot;);\n        System.out.print(&quot;聚合的内容有：&quot;);\n        Iterator it &#x3D; ag.getIterator();\n        while (it.hasNext()) &#123;\n            Object ob &#x3D; it.next();\n            System.out.print(ob.toString() + &quot;\\t&quot;);\n        &#125;\n        Object ob &#x3D; it.first();\n        System.out.println(&quot;\\nFirst：&quot; + ob.toString());\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n聚合的内容有：中山大学\t华南理工\t清华大学\nFirst：中山大学</code></pre>\n<hr />\n<h3 id=\"六命令模式\"><a class=\"markdownIt-Anchor\" href=\"#六命令模式\"></a> （六）命令模式</h3>\n<h4 id=\"模式介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-6\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在软件开发系统中，“方法的请求者”与“方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与实现者解耦？”变得很重要，命令模式就能很好地解决这个问题。</li>\n<li>在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。</li>\n<li>再比如，我们去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</li>\n<li>命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/6-1.png\" alt=\"命令模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>\n<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>\n<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>\n<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>通过引入中间件（抽象接口）降低系统的耦合度。</li>\n<li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。</li>\n<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>\n<li>方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。</li>\n<li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。</li>\n<li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难</li>\n</ul>\n</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-6\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-6\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。\n&#x2F;&#x2F;设计是将命令进行单独的封装，遥控器去使用命令，命令去操控电视，做到这些关系的分离与关联即可。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 实现者&#x2F;接收者（Receiver）\npublic class TV\n&#123;\n\tpublic void open()&#123;\n\t\tSystem.out.println(&quot;打开电视机！&quot;);\n\t&#125;\n\tpublic void close()&#123;\n\t\tSystem.out.println(&quot;关闭电视机！&quot;);\n\t&#125;\n\tpublic void changeChannel()&#123;\n\t\tSystem.out.println(&quot;切换电视频道！&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象命令类（Command）\npublic interface AbstractCommand&#123;\n\tpublic void execute();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体命令类（Concrete Command）\n&#x2F;&#x2F;打开电视机命令\npublic class TVOpenCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVOpenCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.open();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;关闭电视机命令\npublic class TVCloseCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVCloseCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.close();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;切换电视机频道命令\npublic class TVChangeCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVChangeCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.changeChannel();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;调用者&#x2F;请求者（Invoker）-遥控器类\npublic class Controller\n&#123;\n\tprivate AbstractCommand openCommand,closeCommand,changeCommand;\n\tpublic Controller(AbstractCommand openCommand,\n\t\tAbstractCommand closeCommand,\n\t\tAbstractCommand changeCommand)&#123;\n\t\t\n\t\tthis.openCommand &#x3D; openCommand;\n\t\tthis.closeCommand &#x3D; closeCommand;\n\t\tthis.changeCommand &#x3D; changeCommand;\n\t&#125;\n\t\n\tpublic void open()&#123;\n\t\topenCommand.execute();\n\t&#125;\n\tpublic void close()&#123;\n\t\tcloseCommand.execute();\n\t&#125;\n\tpublic void changeChannel()&#123;\n\t\tchangeCommand.execute();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n\t\tAbstractCommand openCommand,closeCommand,changeCommand;\n\t\t\n\t\topenCommand &#x3D; new TVOpenCommand();\n\t\tcloseCommand &#x3D; new TVCloseCommand();\n\t\tchangeCommand &#x3D; new TVChangeCommand();\n\t\t&#x2F;&#x2F;定制遥控器\n\t\tController control &#x3D; new Controller(openCommand,closeCommand,changeCommand);\n\n\t\tcontrol.open();\n\t\tcontrol.change();\n\t\tcontrol.close();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果：\n打开电视机！\n切换电视频道！\n关闭电视机！</code></pre>\n<hr />\n<h3 id=\"七状态模式\"><a class=\"markdownIt-Anchor\" href=\"#七状态模式\"></a> （七）状态模式</h3>\n<h4 id=\"模式介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-7\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：\n<ul>\n<li>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/7-1.png\" alt=\"状态模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：<br />\n环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。<br />\n抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。<br />\n具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li>\n<li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>\n<li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>状态模式的使用必然会增加系统的类与对象的个数。</li>\n<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>\n<li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li>\n<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-7\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-7\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;环境类\nclass Context &#123;\n    private State state;\n    &#x2F;&#x2F;定义环境类的初始状态\n    public Context() &#123;\n        this.state &#x3D; new ConcreteStateA();\n    &#125;\n    &#x2F;&#x2F;设置新状态\n    public void setState(State state) &#123;\n        this.state &#x3D; state;\n    &#125;\n    &#x2F;&#x2F;读取状态\n    public State getState() &#123;\n        return (state);\n    &#125;\n    &#x2F;&#x2F;对请求做处理\n    public void Handle() &#123;\n        state.Handle(this);\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象状态类\nabstract class State &#123;\n    public abstract void Handle(Context context);\n&#125;\n&#x2F;&#x2F;具体状态A类\nclass ConcreteStateA extends State &#123;\n    public void Handle(Context context) &#123;\n        System.out.println(&quot;当前状态是 A.&quot;);\n        context.setState(new ConcreteStateB());\n    &#125;\n&#125;\n&#x2F;&#x2F;具体状态B类\nclass ConcreteStateB extends State &#123;\n    public void Handle(Context context) &#123;\n        System.out.println(&quot;当前状态是 B.&quot;);\n        context.setState(new ConcreteStateA());\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class StatePatternClient &#123;\n    public static void main(String[] args) &#123;\n        Context context &#x3D; new Context();    &#x2F;&#x2F;创建环境      \n        context.Handle();    &#x2F;&#x2F;处理请求\n        context.Handle();\n        context.Handle();\n        context.Handle();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果：\n当前状态是 A.\n当前状态是 B.\n当前状态是 A.\n当前状态是 B.</code></pre>\n<hr />\n<h3 id=\"八职责链模式\"><a class=\"markdownIt-Anchor\" href=\"#八职责链模式\"></a> （八）职责链模式</h3>\n<h4 id=\"模式介绍-8\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-8\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。</li>\n<li>在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些，都可以考虑使用责任链模式来实现。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，属于对象行为模式。</li>\n<li>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/8-1.png\" alt=\"职责链模式结构图\" /></li>\n<li><img src=\"../img/6/8-2.png\" alt=\"职责链\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>\n<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>\n<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>\n<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>\n<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>\n<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else语句。</li>\n<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>\n<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>\n<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。</li>\n<li>可动态指定一组对象处理请求，或添加新的处理者。</li>\n<li>需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-8\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-8\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象处理者角色\nabstract class Handler &#123;\n    private Handler next;\n    public void setNext(Handler next) &#123;\n        this.next &#x3D; next;\n    &#125;\n    public Handler getNext() &#123;\n        return next;\n    &#125;\n    &#x2F;&#x2F;处理请求的方法\n    public abstract void handleRequest(String request);\n&#125;\n&#x2F;&#x2F;具体处理者角色1\nclass ConcreteHandler1 extends Handler &#123;\n    public void handleRequest(String request) &#123;\n        if (request.equals(&quot;one&quot;)) &#123;\n            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);\n        &#125; else &#123;\n            if (getNext() !&#x3D; null) &#123;\n                getNext().handleRequest(request);\n            &#125; else &#123;\n                System.out.println(&quot;没有人处理该请求！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;具体处理者角色2\nclass ConcreteHandler2 extends Handler &#123;\n    public void handleRequest(String request) &#123;\n        if (request.equals(&quot;two&quot;)) &#123;\n            System.out.println(&quot;具体处理者2负责处理该请求！&quot;);\n        &#125; else &#123;\n            if (getNext() !&#x3D; null) &#123;\n                getNext().handleRequest(request);\n            &#125; else &#123;\n                System.out.println(&quot;没有人处理该请求！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class ChainOfResponsibilityPattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;组装责任链\n        Handler handler1 &#x3D; new ConcreteHandler1();\n        Handler handler2 &#x3D; new ConcreteHandler2();\n        handler1.setNext(handler2);\n        &#x2F;&#x2F;提交请求\n        handler1.handleRequest(&quot;two&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体处理者2负责处理该请求！</code></pre>\n<hr />\n<h3 id=\"九中介者模式\"><a class=\"markdownIt-Anchor\" href=\"#九中介者模式\"></a> （九）中介者模式</h3>\n<h4 id=\"模式介绍-9\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-9\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机</li>\n<li>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。</li>\n<li>如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</li>\n<li>在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>\n<li>中介者模式又称为调停者模式，它是一种对象行为型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/9-1.png\" alt=\"中介者模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>\n<li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>\n<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>\n<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>类之间各司其职，符合迪米特法则。</li>\n<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>\n<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li>\n<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li>\n<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类</li>\n<li>我们所常知道的MVC模式中，controller就是我们所谓的中介者。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-9\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-9\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象中介者\nabstract class Mediator &#123;\n    public abstract void register(Colleague colleague);\n    public abstract void relay(Colleague cl); &#x2F;&#x2F;转发\n&#125;\n&#x2F;&#x2F;具体中介者\nclass ConcreteMediator extends Mediator &#123;\n    private List&lt;Colleague&gt; colleagues &#x3D; new ArrayList&lt;Colleague&gt;();\n    public void register(Colleague colleague) &#123;\n        if (!colleagues.contains(colleague)) &#123;\n            colleagues.add(colleague);\n            colleague.setMedium(this);\n        &#125;\n    &#125;\n    public void relay(Colleague cl) &#123;\n        for (Colleague ob : colleagues) &#123;\n            if (!ob.equals(cl)) &#123;\n                ((Colleague) ob).receive();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象同事类\nabstract class Colleague &#123;\n    protected Mediator mediator;\n    public void setMedium(Mediator mediator) &#123;\n        this.mediator &#x3D; mediator;\n    &#125;\n    public abstract void receive();\n    public abstract void send();\n&#125;\n&#x2F;&#x2F;具体同事类\nclass ConcreteColleague1 extends Colleague &#123;\n    public void receive() &#123;\n        System.out.println(&quot;具体同事类1收到请求。&quot;);\n    &#125;\n    public void send() &#123;\n        System.out.println(&quot;具体同事类1发出请求。&quot;);\n        mediator.relay(this); &#x2F;&#x2F;请中介者转发\n    &#125;\n&#125;\n&#x2F;&#x2F;具体同事类\nclass ConcreteColleague2 extends Colleague &#123;\n    public void receive() &#123;\n        System.out.println(&quot;具体同事类2收到请求。&quot;);\n    &#125;\n    public void send() &#123;\n        System.out.println(&quot;具体同事类2发出请求。&quot;);\n        mediator.relay(this); &#x2F;&#x2F;请中介者转发\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class MediatorPattern &#123;\n    public static void main(String[] args) &#123;\n        Mediator md &#x3D; new ConcreteMediator();\n        Colleague c1, c2;\n        c1 &#x3D; new ConcreteColleague1();\n        c2 &#x3D; new ConcreteColleague2();\n        md.register(c1);\n        md.register(c2);\n        c1.send();\n        System.out.println(&quot;-------------&quot;);\n        c2.send();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体同事类1发出请求。\n具体同事类2收到请求。\n-------------\n具体同事类2发出请求。\n具体同事类1收到请求。</code></pre>\n<hr />\n<h3 id=\"十访问者模式\"><a class=\"markdownIt-Anchor\" href=\"#十访问者模式\"></a> （十）访问者模式</h3>\n<h4 id=\"模式介绍-10\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-10\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：<br />\n-在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。<br />\n-这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。<br />\n-这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。</li>\n<li>模式定义：\n<ul>\n<li>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>\n<li>访问者（Visitor）模式是一种对象行为型模式</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/10-1.png\" alt=\"访问者模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>\n<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>\n<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li>\n<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>\n<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>\n<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>\n<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>\n<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>\n<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>\n<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>\n<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>\n<li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-10\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-10\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象访问者\ninterface Visitor &#123;\n    void visit(ConcreteElementA element);\n    void visit(ConcreteElementB element);\n&#125;\n&#x2F;&#x2F;具体访问者A类\nclass ConcreteVisitorA implements Visitor &#123;\n    public void visit(ConcreteElementA element) &#123;\n        System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationA());\n    &#125;\n    public void visit(ConcreteElementB element) &#123;\n        System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationB());\n    &#125;\n&#125;\n&#x2F;&#x2F;具体访问者B类\nclass ConcreteVisitorB implements Visitor &#123;\n    public void visit(ConcreteElementA element) &#123;\n        System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationA());\n    &#125;\n    public void visit(ConcreteElementB element) &#123;\n        System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationB());\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象元素类\ninterface Element &#123;\n    void accept(Visitor visitor);\n&#125;\n&#x2F;&#x2F;具体元素A类\nclass ConcreteElementA implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n    public String operationA() &#123;\n        return &quot;具体元素A的操作。&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;具体元素B类\nclass ConcreteElementB implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n    public String operationB() &#123;\n        return &quot;具体元素B的操作。&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;对象结构角色\nclass ObjectStructure &#123;\n    private List&lt;Element&gt; list &#x3D; new ArrayList&lt;Element&gt;();\n    public void accept(Visitor visitor) &#123;\n        Iterator&lt;Element&gt; i &#x3D; list.iterator();\n        while (i.hasNext()) &#123;\n            ((Element) i.next()).accept(visitor);\n        &#125;\n    &#125;\n    public void add(Element element) &#123;\n        list.add(element);\n    &#125;\n    public void remove(Element element) &#123;\n        list.remove(element);\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class VisitorPattern &#123;\n    public static void main(String[] args) &#123;\n        ObjectStructure os &#x3D; new ObjectStructure();\n        os.add(new ConcreteElementA());\n        os.add(new ConcreteElementB());\n        Visitor visitor &#x3D; new ConcreteVisitorA();\n        os.accept(visitor);\n        System.out.println(&quot;------------------------&quot;);\n        visitor &#x3D; new ConcreteVisitorB();\n        os.accept(visitor);\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体访问者A访问--&gt;具体元素A的操作。\n具体访问者A访问--&gt;具体元素B的操作。\n------------------------\n具体访问者B访问--&gt;具体元素A的操作。\n具体访问者B访问--&gt;具体元素B的操作。</code></pre>\n<hr />\n<h3 id=\"十一解释器模式\"><a class=\"markdownIt-Anchor\" href=\"#十一解释器模式\"></a> （十一）解释器模式</h3>\n<h4 id=\"模式介绍-11\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-11\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>定义语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”意思是使用规定格式和语法的代码，它是一个类行为型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/6/11-1.png\" alt=\"解释器模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>\n<li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>\n<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>\n<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>\n<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>\n<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>\n<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>\n<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>\n<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>\n<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-11\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-11\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package net.biancheng.c.interpreter;\n&#x2F;&#x2F;抽象表达式类\ninterface AbstractExpression &#123;\n    public void interpret(String info);    &#x2F;&#x2F;解释方法\n&#125;\n&#x2F;&#x2F;终结符表达式类\nclass TerminalExpression implements AbstractExpression &#123;\n    public void interpret(String info) &#123;\n        &#x2F;&#x2F;对终结符表达式的处理\n    &#125;\n&#125;\n&#x2F;&#x2F;非终结符表达式类\nclass NonterminalExpression implements AbstractExpression &#123;\n    private AbstractExpression exp1;\n    private AbstractExpression exp2;\n    public void interpret(String info) &#123;\n        &#x2F;&#x2F;非对终结符表达式的处理\n    &#125;\n&#125;\n&#x2F;&#x2F;环境类\nclass Context &#123;\n    private AbstractExpression exp;\n    public Context() &#123;\n        &#x2F;&#x2F;数据初始化\n    &#125;\n    public void operation(String info) &#123;\n        &#x2F;&#x2F;调用相关表达式类的解释方法\n    &#125;\n&#125;</code></pre>\n<hr />\n<h1 id=\"参考文献博客\"><a class=\"markdownIt-Anchor\" href=\"#参考文献博客\"></a> 参考文献/博客</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[1] <a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">设计模式</a><br />\n[2] <a href=\"https://segmentfault.com/a/1190000043340405\">15分钟入门23种设计模式：图解，范例和对比</a><br />\n[3] <a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解</a><br />\n[4] <a href=\"https://blog.csdn.net/weixin_43905387?type=blog\">一孔之见️</a><br />\n[5] <a href=\"https://www.jianshu.com/nb/26354260\">Jerry_1116</a><br />\n[6] <a href=\"https://www.zhihu.com/column/c_1449803713698856960\">Java技术教程</a></p></blockquote>\n","feature":true,"text":" 设计模式-3 一、 行为型模式 行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使代码更加地清晰。描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3\"><span class=\"toc-text\"> 设计模式-3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 一、 行为型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （一）策略模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （二）模板方法模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （三）备忘录模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-3\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （四）观察者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-4\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-4\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （五）迭代器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-5\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-5\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （六）命令模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-6\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-6\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （七）状态模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-7\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-7\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （八）职责链模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-8\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-8\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （九）中介者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-9\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-9\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （十）访问者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-10\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-10\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （十一）解释器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-11\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-11\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E5%8D%9A%E5%AE%A2\"><span class=\"toc-text\"> 参考文献&#x2F;博客</span></a></li></ol>","author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"编译原理复习","uid":"1213bb1667a1a27ac14ed9acb5d31b07","slug":"7-编译原理复习","date":"2023-06-23T11:48:38.000Z","updated":"2023-06-25T05:54:30.771Z","comments":true,"path":"api/articles/7-编译原理复习.json","keywords":null,"cover":[],"text":" 复习要点提纲 第二章(文法构造、句型的最左推导、句型的语法树、短语、直接短语、句柄) 第三章 (词法分析、8个算法)(必考：子集法) 第四章(LL(1)文法、FIRST集、FOLLOW集、SELECT集、LL(1)文法的判定、LL(1)文法的构造、LL(1)分析表的构造) 第六...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"设计模式-2","uid":"a39375e630b00cc66be242014aeafe21","slug":"5-设计模式-2","date":"2023-05-08T14:06:39.000Z","updated":"2023-05-09T13:44:44.248Z","comments":true,"path":"api/articles/5-设计模式-2.json","keywords":null,"cover":[],"text":" 设计模式-2 一、 结构型模式 结构型模式关注的是类或对象如何组织,描述如何将类或对象按某种布局组成更大的结构。 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问...","link":"","photos":[],"count_time":{"symbolsCount":"51k","symbolsTime":"46 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
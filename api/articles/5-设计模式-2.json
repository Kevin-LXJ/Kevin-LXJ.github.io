{"title":"设计模式-2","uid":"a39375e630b00cc66be242014aeafe21","slug":"5-设计模式-2","date":"2023-05-08T14:06:39.000Z","updated":"2023-05-09T02:46:46.887Z","comments":true,"path":"api/articles/5-设计模式-2.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式-2\"><a class=\"markdownIt-Anchor\" href=\"#设计模式-2\"></a> 设计模式-2</h1>\n<h2 id=\"一-结构型模式\"><a class=\"markdownIt-Anchor\" href=\"#一-结构型模式\"></a> 一、 结构型模式</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>结构型模式关注的是<strong>类或对象如何组织</strong>,描述<strong>如何将类或对象按某种布局组成更大的结构</strong>。  它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>\n<ul>\n<li><strong>代理（Proxy）模式</strong>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>\n<li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>\n<li><strong>桥接（Bridge）模式</strong>：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>\n<li><strong>装饰（Decorator）模式</strong>：动态地给对象增加一些职责，即增加其额外的功能。</li>\n<li><strong>外观（Facade）模式</strong>：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>\n<li><strong>享元（Flyweight）模式</strong>：运用共享技术来有效地支持大量细粒度对象的复用。</li>\n<li><strong>组合（Composite）模式</strong>：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>\n</ul></blockquote>\n<ul>\n<li><img src=\"../img/5/0-1.png\" alt=\"结构型模式\" /></li>\n</ul>\n<h3 id=\"一外观模式\"><a class=\"markdownIt-Anchor\" href=\"#一外观模式\"></a> （一）外观模式</h3>\n<h4 id=\"模式介绍\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道</li>\n<li>引入一个新的外观类（Facade）来负责多个业务类或者说是子系统，而客户类只需要与外观类进行交互</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>为子系统的一组接口提供一个统一的入口，外观模定义一个高层的接口，这个接口使得子系统更加统一使用</li>\n<li>外观模式属于对象结构型模式，又称为门面模式，是<strong>迪米特法则</strong>的一种具体实现</li>\n<li>通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统系统之间的耦合度。\n<ul>\n<li>所指的子系统是一个广义的概念，他可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/5/1-1.png\" alt=\"外观模式结构\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>Facade 外观角色：为多个子系统对外提供一个共同的接口</li>\n<li>SubSystem 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li>\n<li>实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>\n<li>子系统的内部变化不会影响到外观对象，一个子系统的修改对其他子系统也没有任何影响</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>\n<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>要为访问一系列复杂的子系统提供一个简单入口</li>\n<li>客户端程序与多个子系统之间存在很大的依赖性</li>\n<li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现\"><a class=\"markdownIt-Anchor\" href=\"#模式实现\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中\n&#x2F;&#x2F;具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。\n&#x2F;&#x2F;这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。\n&#x2F;&#x2F;现使用外观模式设计该文件加密模块。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件保存类\n * @Description:\n *&#x2F;\npublic class FileWriter &#123;\n    public void write(String encryptString,String path)&#123;\n        System.out.println(&quot;保存密文，写入文件。&quot;);\n        try &#123;\n            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(path);\n            &#x2F;&#x2F;写入\n            fileOutputStream.write(encryptString.getBytes());\n            fileOutputStream.close();\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在！&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件读取类\n * @Description:\n *&#x2F;\npublic class FileReader &#123;\n    public String read(String path)&#123;\n        System.out.println(&quot;读取文件，获得明文：&quot;);\n        StringBuffer stringBuffer &#x3D; new StringBuffer();\n        try &#123;\n            FileInputStream fileInputStream &#x3D; new FileInputStream(path);\n            int data;\n            while((data &#x3D; fileInputStream.read()) !&#x3D; -1)&#123;\n                stringBuffer &#x3D; stringBuffer.append((char) data);\n            &#125;\n            &#x2F;&#x2F;关闭\n            fileInputStream.close();\n            System.out.println(stringBuffer.toString());\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n\n        return stringBuffer.toString();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 子系统-文件加密类\n * @Description:\n *&#x2F;\npublic class CipherMachine &#123;\n    public String encrypt(String plainText)&#123;\n\n        System.out.println(&quot;数据加密，将明文转换为密文：&quot;);\n        String es &#x3D; &quot;&quot;;\n        for (int i &#x3D; 0; i &lt; plainText.length(); i++) &#123;\n            String s &#x3D; String.valueOf(plainText.charAt(i) % 7);\n            es +&#x3D; s;\n        &#125;\n\n        System.out.println(es);\n        return es;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 外观类：加密外观类\n * @Description:\n *&#x2F;\npublic class EncryptFacade &#123;\n    &#x2F;&#x2F;维持对子系统的引用\n    private FileReader fileReader;\n    private CipherMachine cipherMachine;\n    private FileWriter fileWriter;\n\n    public EncryptFacade() &#123;\n        this.fileReader &#x3D; new FileReader();\n        this.cipherMachine &#x3D; new CipherMachine();\n        this.fileWriter &#x3D; new FileWriter();\n    &#125;\n\n    &#x2F;&#x2F;调用子系统的业务方法\n    public void fileEncrypt(String pathSrc,String pathDes)&#123;\n        String read &#x3D; fileReader.read(pathSrc);\n        String encrypt &#x3D; cipherMachine.encrypt(read);\n        fileWriter.write(encrypt,pathDes);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        EncryptFacade encryptFacade &#x3D; new EncryptFacade();\n        encryptFacade.fileEncrypt(&quot;file.txt&quot;,&quot;des.txt&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nfile.text:happy birthday to you!\ndes.text:\n&#x2F;&#x2F;运行结果：\n    读取文件，获得明文：\n    happy birthday to you!\n    数据加密，将明文转换为密文：\n    331403442436545\n    保存密文，写入文件</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;增加抽象外观类，使用配置文件更换外观类\n&#x2F;&#x2F;核心代码\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;增加抽象外观类\npublic abstract class AbstractEncryptFacade &#123;\n    public abstract void fileEncrypt(String fileNameSrc, String fileNameDes);\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;实现新的外观类\npublic class NewEncryptFacade extends AbstractEncryptFacade &#123;\n    private FileReader reader;\n    private NewCipherMachine cipher;\n    private FileWriter writer;\n\t\n    public NewEncryptFacade() &#123;\n        reader &#x3D; new FileReader();\n        cipher &#x3D; new NewCipherMachine();\n        writer &#x3D; new FileWriter();\n    &#125;\n\t\n    public void fileEncrypt(String fileNameSrc, String fileNameDes) &#123;\n        String plainStr &#x3D; reader.read(fileNameSrc);\n        String encryptStr &#x3D; cipher.encrypt(plainStr);\n        writer.write(encryptStr,fileNameDes);\n    &#125;\n&#125; \n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\npublic class Client &#123;\n    public static void main(String args[]) &#123;\n        AbstractEncryptFacade ef;\n        ef &#x3D; (AbstractEncryptFacade)XMLUtil.getBean();\n        ef.fileEncrypt(&quot;src.txt&quot;,&quot;des.txt&quot;);    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n    &lt;className&gt;NewEncryptFacade&lt;&#x2F;className&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</code></pre>\n<hr />\n<h3 id=\"二适配器模式\"><a class=\"markdownIt-Anchor\" href=\"#二适配器模式\"></a> （二）适配器模式</h3>\n<h4 id=\"模式介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-2\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作</li>\n<li>既是对象结构型模式，又是类结构型模式</li>\n<li>别名：包装器模式</li>\n<li>定义中所指的接口是指广义的接口，他可以表示一个方法或者方法的集合</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li>类适配器</li>\n<li><img src=\"../img/5/2-1.png\" alt=\"类适配器\" /></li>\n<li>对象适配器</li>\n<li><img src=\"../img/5/2-2.png\" alt=\"对象适配器\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>Target 目标抽象类：期待得到的目标，相当于插座</li>\n<li>Adapter 适配器类：连接目标和源的中间对象，相当于插头转换器</li>\n<li>Adaptee 适配者类：需要被适配的对象或类型，相当于插头</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>\n<li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>\n<li>灵活性和扩展性非常好</li>\n<li>类适配器模式：置换一些适配者的方法很方便</li>\n<li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>类适配器模式：\n<ul>\n<li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li>\n<li>适配者类不能为最终类</li>\n<li>目标抽象类只能为接口，不能为类</li>\n</ul>\n</li>\n<li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>系统需要使用一些现有的类（适配者），而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li>\n<li>创建一个可以重复使用的类（目标类/适配者），用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-2\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-2\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;类适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter extends Adaptee implements Target &#123;\n\n    &#x2F;**\n     * 采用继承的方式实现转换功能\n     *&#x2F;\n    @Override\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用继承的方法，对其进行增强或处理\n        this.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;对象适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter implements Target &#123;\n    &#x2F;**\n     * 这是两种实现方式唯一的不同之处\n     *&#x2F;\n    private Adaptee adaptee;\n\n    public Adapter() &#123;\n        this.adaptee &#x3D; new Adaptee();\n    &#125;\n\n    &#x2F;**\n     * 采用组合的方式实现转换功能\n     *&#x2F;\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用组合成员的方法，对其进行增强或处理\n        this.adaptee.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;</code></pre>\n<hr />\n<h3 id=\"三组合模式\"><a class=\"markdownIt-Anchor\" href=\"#三组合模式\"></a> （三）组合模式</h3>\n<h4 id=\"模式介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-3\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：</li>\n<li>模式结构：</li>\n<li>角色分析：</li>\n<li>模型评价：\n<ul>\n<li>优点</li>\n<li>缺点</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-3\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-3\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;</code></pre>\n<hr />\n<h3 id=\"四代理模式\"><a class=\"markdownIt-Anchor\" href=\"#四代理模式\"></a> （四）代理模式</h3>\n<h4 id=\"模式介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-4\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：</li>\n<li>模式结构：</li>\n<li>角色分析：</li>\n<li>模型评价：\n<ul>\n<li>优点</li>\n<li>缺点</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-4\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-4\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;</code></pre>\n<hr />\n<h3 id=\"五桥接模式\"><a class=\"markdownIt-Anchor\" href=\"#五桥接模式\"></a> （五）桥接模式</h3>\n<h4 id=\"模式介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-5\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：</li>\n<li>模式结构：</li>\n<li>角色分析：</li>\n<li>模型评价：\n<ul>\n<li>优点</li>\n<li>缺点</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-5\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-5\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;</code></pre>\n<hr />\n<h3 id=\"六装饰模式\"><a class=\"markdownIt-Anchor\" href=\"#六装饰模式\"></a> （六）装饰模式</h3>\n<h4 id=\"模式介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-6\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：</li>\n<li>模式结构：</li>\n<li>角色分析：</li>\n<li>模型评价：\n<ul>\n<li>优点</li>\n<li>缺点</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-6\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-6\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;</code></pre>\n<hr />\n<h3 id=\"七享元模式\"><a class=\"markdownIt-Anchor\" href=\"#七享元模式\"></a> （七）享元模式</h3>\n<h4 id=\"模式介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-7\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：</li>\n<li>模式定义：</li>\n<li>模式结构：</li>\n<li>角色分析：</li>\n<li>模型评价：\n<ul>\n<li>优点</li>\n<li>缺点</li>\n<li>应用场景</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-7\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-7\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;</code></pre>\n<hr />\n<h1 id=\"参考文献博客\"><a class=\"markdownIt-Anchor\" href=\"#参考文献博客\"></a> 参考文献/博客</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[1] <a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">设计模式</a><br />\n[2] <a href=\"https://segmentfault.com/a/1190000043340405\">15分钟入门23种设计模式：图解，范例和对比</a><br />\n[3] <a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解</a><br />\n[4] <a href=\"https://blog.csdn.net/csu_hjh/category_11505231.html?spm=1001.2014.3001.5482\">纸短勤常在</a><br />\n[5] <a href=\"https://www.jianshu.com/u/4859d67311a2\">小薯条学技术</a><br />\n[6] <a href=\"https://juejin.cn/post/7118956732721987614\">一次性搞懂设计模式–适配器模式</a></p></blockquote>\n","feature":true,"text":" 设计模式-2 一、 结构型模式 结构型模式关注的是类或对象如何组织,描述如何将类或对象按某种布局组成更大的结构。 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2\"><span class=\"toc-text\"> 设计模式-2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 一、 结构型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （一）外观模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （二）适配器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （三）组合模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-3\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （四）代理模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-4\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-4\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （五）桥接模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-5\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-5\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （六）装饰模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-6\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-6\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （七）享元模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-7\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-7\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E5%8D%9A%E5%AE%A2\"><span class=\"toc-text\"> 参考文献&#x2F;博客</span></a></li></ol>","author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"设计模式-3","uid":"1282d363af11675dd608d5f2af6828ad","slug":"6-设计模式-3","date":"2023-05-08T15:06:41.000Z","updated":"2023-05-08T15:24:36.208Z","comments":true,"path":"api/articles/6-设计模式-3.json","keywords":null,"cover":null,"text":" 设计模式-3 一、 行为型模式 行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使代码更加地清晰。描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"软件架构复习大纲","uid":"088ebac38bba3124d962899c15781d5f","slug":"4-软件架构复习","date":"2023-05-07T13:05:25.000Z","updated":"2023-05-08T11:57:03.026Z","comments":true,"path":"api/articles/4-软件架构复习.json","keywords":null,"cover":null,"text":" 软件架构复习 软件体系结构概论 软件危机 构件与软件重用 构件模型及实现 构件获取 构件管理 构件描述 构件分类与组织 构件重用 软件体系结构的兴起与发展 软件体系结构的定义 软件体系结构的应用现状 软件体系结构建模 建模的种类 结构模型 框架模型 动态模型 过程模型 功能模型...","link":"","photos":[],"count_time":{"symbolsCount":784,"symbolsTime":"1 mins."},"categories":[{"name":"软件架构","slug":"软件架构","count":1,"path":"api/categories/软件架构.json"}],"tags":[{"name":"软件架构","slug":"软件架构","count":2,"path":"api/tags/软件架构.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
{"title":"设计模式-2","uid":"a39375e630b00cc66be242014aeafe21","slug":"5-设计模式-2","date":"2023-05-08T14:06:39.000Z","updated":"2023-05-09T13:44:44.248Z","comments":true,"path":"api/articles/5-设计模式-2.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式-2\"><a class=\"markdownIt-Anchor\" href=\"#设计模式-2\"></a> 设计模式-2</h1>\n<h2 id=\"一-结构型模式\"><a class=\"markdownIt-Anchor\" href=\"#一-结构型模式\"></a> 一、 结构型模式</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>结构型模式关注的是<strong>类或对象如何组织</strong>,描述<strong>如何将类或对象按某种布局组成更大的结构</strong>。  它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>\n<ul>\n<li><strong>代理（Proxy）模式</strong>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>\n<li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>\n<li><strong>桥接（Bridge）模式</strong>：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>\n<li><strong>装饰（Decorator）模式</strong>：动态地给对象增加一些职责，即增加其额外的功能。</li>\n<li><strong>外观（Facade）模式</strong>：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>\n<li><strong>享元（Flyweight）模式</strong>：运用共享技术来有效地支持大量细粒度对象的复用。</li>\n<li><strong>组合（Composite）模式</strong>：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>\n</ul></blockquote>\n<ul>\n<li><img src=\"../img/5/0-1.png\" alt=\"结构型模式\" /></li>\n</ul>\n<h3 id=\"一外观模式\"><a class=\"markdownIt-Anchor\" href=\"#一外观模式\"></a> （一）外观模式</h3>\n<h4 id=\"模式介绍\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道</li>\n<li>引入一个新的外观类（Facade）来负责多个业务类或者说是子系统，而客户类只需要与外观类进行交互</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>为子系统的一组接口提供一个统一的入口，外观模定义一个高层的接口，这个接口使得子系统更加统一使用</li>\n<li>外观模式属于对象结构型模式，又称为门面模式，是<strong>迪米特法则</strong>的一种具体实现</li>\n<li>通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统系统之间的耦合度。\n<ul>\n<li>所指的子系统是一个广义的概念，他可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/5/1-1.png\" alt=\"外观模式结构\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>Facade 外观角色：为多个子系统对外提供一个共同的接口</li>\n<li>SubSystem 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li>\n<li>实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>\n<li>子系统的内部变化不会影响到外观对象，一个子系统的修改对其他子系统也没有任何影响</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>\n<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>要为访问一系列复杂的子系统提供一个简单入口</li>\n<li>客户端程序与多个子系统之间存在很大的依赖性</li>\n<li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现\"><a class=\"markdownIt-Anchor\" href=\"#模式实现\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中\n&#x2F;&#x2F;具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。\n&#x2F;&#x2F;这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。\n&#x2F;&#x2F;现使用外观模式设计该文件加密模块。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件保存类\n * @Description:\n *&#x2F;\npublic class FileWriter &#123;\n    public void write(String encryptString,String path)&#123;\n        System.out.println(&quot;保存密文，写入文件。&quot;);\n        try &#123;\n            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(path);\n            &#x2F;&#x2F;写入\n            fileOutputStream.write(encryptString.getBytes());\n            fileOutputStream.close();\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在！&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件读取类\n * @Description:\n *&#x2F;\npublic class FileReader &#123;\n    public String read(String path)&#123;\n        System.out.println(&quot;读取文件，获得明文：&quot;);\n        StringBuffer stringBuffer &#x3D; new StringBuffer();\n        try &#123;\n            FileInputStream fileInputStream &#x3D; new FileInputStream(path);\n            int data;\n            while((data &#x3D; fileInputStream.read()) !&#x3D; -1)&#123;\n                stringBuffer &#x3D; stringBuffer.append((char) data);\n            &#125;\n            &#x2F;&#x2F;关闭\n            fileInputStream.close();\n            System.out.println(stringBuffer.toString());\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n\n        return stringBuffer.toString();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 子系统-文件加密类\n * @Description:\n *&#x2F;\npublic class CipherMachine &#123;\n    public String encrypt(String plainText)&#123;\n\n        System.out.println(&quot;数据加密，将明文转换为密文：&quot;);\n        String es &#x3D; &quot;&quot;;\n        for (int i &#x3D; 0; i &lt; plainText.length(); i++) &#123;\n            String s &#x3D; String.valueOf(plainText.charAt(i) % 7);\n            es +&#x3D; s;\n        &#125;\n\n        System.out.println(es);\n        return es;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 外观类：加密外观类\n * @Description:\n *&#x2F;\npublic class EncryptFacade &#123;\n    &#x2F;&#x2F;维持对子系统的引用\n    private FileReader fileReader;\n    private CipherMachine cipherMachine;\n    private FileWriter fileWriter;\n\n    public EncryptFacade() &#123;\n        this.fileReader &#x3D; new FileReader();\n        this.cipherMachine &#x3D; new CipherMachine();\n        this.fileWriter &#x3D; new FileWriter();\n    &#125;\n\n    &#x2F;&#x2F;调用子系统的业务方法\n    public void fileEncrypt(String pathSrc,String pathDes)&#123;\n        String read &#x3D; fileReader.read(pathSrc);\n        String encrypt &#x3D; cipherMachine.encrypt(read);\n        fileWriter.write(encrypt,pathDes);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        EncryptFacade encryptFacade &#x3D; new EncryptFacade();\n        encryptFacade.fileEncrypt(&quot;file.txt&quot;,&quot;des.txt&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nfile.text:happy birthday to you!\ndes.text:\n&#x2F;&#x2F;运行结果：\n    读取文件，获得明文：\n    happy birthday to you!\n    数据加密，将明文转换为密文：\n    331403442436545\n    保存密文，写入文件</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;增加抽象外观类，使用配置文件更换外观类\n&#x2F;&#x2F;核心代码\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;增加抽象外观类\npublic abstract class AbstractEncryptFacade &#123;\n    public abstract void fileEncrypt(String fileNameSrc, String fileNameDes);\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;实现新的外观类\npublic class NewEncryptFacade extends AbstractEncryptFacade &#123;\n    private FileReader reader;\n    private NewCipherMachine cipher;\n    private FileWriter writer;\n\t\n    public NewEncryptFacade() &#123;\n        reader &#x3D; new FileReader();\n        cipher &#x3D; new NewCipherMachine();\n        writer &#x3D; new FileWriter();\n    &#125;\n\t\n    public void fileEncrypt(String fileNameSrc, String fileNameDes) &#123;\n        String plainStr &#x3D; reader.read(fileNameSrc);\n        String encryptStr &#x3D; cipher.encrypt(plainStr);\n        writer.write(encryptStr,fileNameDes);\n    &#125;\n&#125; \n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\npublic class Client &#123;\n    public static void main(String args[]) &#123;\n        AbstractEncryptFacade ef;\n        ef &#x3D; (AbstractEncryptFacade)XMLUtil.getBean();\n        ef.fileEncrypt(&quot;src.txt&quot;,&quot;des.txt&quot;);    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n    &lt;className&gt;NewEncryptFacade&lt;&#x2F;className&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</code></pre>\n<hr />\n<h3 id=\"二适配器模式\"><a class=\"markdownIt-Anchor\" href=\"#二适配器模式\"></a> （二）适配器模式</h3>\n<h4 id=\"模式介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-2\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作</li>\n<li>既是对象结构型模式，又是类结构型模式</li>\n<li>别名：包装器模式</li>\n<li>定义中所指的接口是指广义的接口，他可以表示一个方法或者方法的集合</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li>类适配器</li>\n<li><img src=\"../img/5/2-1.png\" alt=\"类适配器\" /></li>\n<li>对象适配器</li>\n<li><img src=\"../img/5/2-2.png\" alt=\"对象适配器\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>Target 目标抽象类：期待得到的目标，相当于插座</li>\n<li>Adapter 适配器类：连接目标和源的中间对象，相当于插头转换器</li>\n<li>Adaptee 适配者类：需要被适配的对象或类型，相当于插头</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>\n<li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>\n<li>灵活性和扩展性非常好</li>\n<li>类适配器模式：置换一些适配者的方法很方便</li>\n<li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>类适配器模式：\n<ul>\n<li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li>\n<li>适配者类不能为最终类</li>\n<li>目标抽象类只能为接口，不能为类</li>\n</ul>\n</li>\n<li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>系统需要使用一些现有的类（适配者），而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li>\n<li>创建一个可以重复使用的类（目标类/适配者），用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-2\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-2\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;类适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter extends Adaptee implements Target &#123;\n\n    &#x2F;**\n     * 采用继承的方式实现转换功能\n     *&#x2F;\n    @Override\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用继承的方法，对其进行增强或处理\n        this.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;对象适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter implements Target &#123;\n    &#x2F;**\n     * 这是两种实现方式唯一的不同之处\n     *&#x2F;\n    private Adaptee adaptee;\n\n    public Adapter() &#123;\n        this.adaptee &#x3D; new Adaptee();\n    &#125;\n\n    &#x2F;**\n     * 采用组合的方式实现转换功能\n     *&#x2F;\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用组合成员的方法，对其进行增强或处理\n        this.adaptee.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;</code></pre>\n<hr />\n<h3 id=\"三组合模式\"><a class=\"markdownIt-Anchor\" href=\"#三组合模式\"></a> （三）组合模式</h3>\n<h4 id=\"模式介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-3\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>将多个对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得客户端对单个对象和组合对象的使用具有一致性</li>\n<li>组合模式又称为整体-部分模式，属于对象结构型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li>透明组合模式\n<ul>\n<li>在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的</li>\n<li>但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</li>\n<li><img src=\"../img/5/3-1.png\" alt=\"透明组合模式结构图\" /></li>\n</ul>\n</li>\n<li>安全组合模式\n<ul>\n<li>在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了透明方式的安全性问题</li>\n<li>但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</li>\n<li><img src=\"../img/5/3-2.png\" alt=\"安全组合模式结构图\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象构件（Component）角色：总的抽象类或接口，为树叶构件和树枝构件声明公共接口，并实现它们的默认行为\n<ul>\n<li>在透明式的组合模式中，抽象构件还声明访问和管理子类的接口</li>\n<li>在安全式的组合模式中，抽象构件仅仅做子类的声明，然后由树枝构件进行实现</li>\n</ul>\n</li>\n<li>树叶构件（Leaf）角色：树叶对象，是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件\n<ul>\n<li>树叶构件在组合中表示叶节点对象，它实现了在抽象构件中定义的行为</li>\n</ul>\n</li>\n<li>树枝构件/容器构件（Composite）角色 ：树枝对象，是组合中的分支节点对象，它有子节点，用于继承或实现抽象构件\n<ul>\n<li>容器构件定义有枝节点的行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无需关心自己处理的是单个对象，还是组合对象，这简化了客户端代码</li>\n<li>更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改源代码，满足“开闭原则”</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系</li>\n<li>不容易限制容器中的构件</li>\n<li>不容易用继承的方法来增加构件的新功能</li>\n<li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>在需要表示一个对象整体与部分的层次结构的场合。</li>\n<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-3\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-3\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;透明组合模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件\ninterface Component &#123;\n    public void add(Component c);\n    public void remove(Component c);\n    public Component getChild(int i);\n    public void operation();\n&#125;\n&#x2F;&#x2F;树叶构件\nclass Leaf implements Component &#123;\n    private String name;\n    public Leaf(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    &#x2F;&#x2F; 叶子节点没有子节点所以add和remove方法实现它没有意义，但这样做可以消除叶节点和枝节点对象在抽象层次的区别，它们具备完全一致的接口\n    public void add(Component c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void remove(Component c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    &#x2F;&#x2F; 叶子节点没有子节点所以返回null或者抛出异常也是可以的\n    public Component getChild(int i) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void operation() &#123;\n        System.out.println(&quot;树叶&quot; + name + &quot;：被访问！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;树枝构件\nclass Composite implements Component &#123;\n    private ArrayList&lt;Component&gt; children &#x3D; new ArrayList&lt;Component&gt;();\n    public void add(Component c) &#123;\n        children.add(c);\n    &#125;\n    public void remove(Component c) &#123;\n        children.remove(c);\n    &#125;\n    public Component getChild(int i) &#123;\n        return children.get(i);\n    &#125;\n    &#x2F;&#x2F; 遍历所有子节点并输出\n    public void operation() &#123;\n        for (Object obj : children) &#123;\n            ((Component) obj).operation();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class CompositePattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 构造根节点，注意声明类型为Component\n        Component c0 &#x3D; new Composite();\n        Component c1 &#x3D; new Composite();\n        Component leaf1 &#x3D; new Leaf(&quot;1&quot;);\n        Component leaf2 &#x3D; new Leaf(&quot;2&quot;);\n        Component leaf3 &#x3D; new Leaf(&quot;3&quot;);\n        c0.add(leaf1);\n        c0.add(c1);\n        c1.add(leaf2);\n        c1.add(leaf3);\n        c0.operation();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n    树叶1：被访问！\n    树叶2：被访问！\n    树叶3：被访问！</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;安全组合模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件\ninterface Component &#123;\n    public void operation();\n&#125;\n&#x2F;&#x2F;树叶构件\nclass Leaf implements Component &#123;\n    private String name;\n    public Leaf(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    public void operation() &#123;\n        System.out.println(&quot;树叶&quot; + name + &quot;：被访问！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;树枝构件\nclass Composite implements Component &#123;\n    private ArrayList&lt;Component&gt; children &#x3D; new ArrayList&lt;Component&gt;();\n    public void add(Component c) &#123;\n        children.add(c);\n    &#125;\n    public void remove(Component c) &#123;\n        children.remove(c);\n    &#125;\n    public Component getChild(int i) &#123;\n        return children.get(i);\n    &#125;\n    &#x2F;&#x2F; 遍历所有子节点并输出\n    public void operation() &#123;\n        for (Object obj : children) &#123;\n            ((Component) obj).operation();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class CompositePattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 构造根节点，注意声明类型为Composite，便于使用构件管理方法add和remove等\n        Composite c0 &#x3D; new Composite();\n        Composite c1 &#x3D; new Composite();\n        Component leaf1 &#x3D; new Leaf(&quot;1&quot;);\n        Component leaf2 &#x3D; new Leaf(&quot;2&quot;);\n        Component leaf3 &#x3D; new Leaf(&quot;3&quot;);\n        c0.add(leaf1);\n        c0.add(c1);\n        c1.add(leaf2);\n        c1.add(leaf3);\n        c0.operation();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n    树叶1：被访问！\n    树叶2：被访问！\n    树叶3：被访问！</code></pre>\n<hr />\n<h3 id=\"四代理模式\"><a class=\"markdownIt-Anchor\" href=\"#四代理模式\"></a> （四）代理模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>建议阅读：<a href=\"https://www.jianshu.com/p/9cdcf4e5c27d\">设计模式之——代理模式</a></p></blockquote>\n<h4 id=\"模式介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-4\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦，如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。</li>\n<li>代理模式就是为这些对象提供一种代理以控制对这些对象的访问，即通过代理对象访问目标对象。这样做的好处是：可以在不修改目标对象的前提下扩展目标对象的功能，同时可以为多个不同的客户端提供同一个目标对象，而这些客户端并不需要知道目标对象本身以及具体的操作细节，代理对象会封装所有的操作。</li>\n</ul>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买;明星都有自己的经纪人，有事需要找他们的时候就要先找他们的经纪人，经纪人也相当于是一个代理；再比如打官司都需要找一个律师，有什么问题直接由律师去沟通解决，那律师就是自己的一个代理。</p></blockquote>\n<ol start=\"2\">\n<li>模式定义：\n<ul>\n<li>代理模式又叫委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问</li>\n<li>代理模式是一种对象结构型模式。</li>\n</ul>\n</li>\n<li>模式结构：\n<ul>\n<li><img src=\"../img/5/4-1.png\" alt=\"代理模式结构图\" /></li>\n</ul>\n</li>\n<li>角色分析：\n<ul>\n<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>\n<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>\n<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>静态代理\n<ul>\n<li>优点\n<ul>\n<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>\n<li>代理对象可以扩展目标对象的功能；</li>\n<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>如果需要为不同的真实主题类提供代理，或代理一个真实主题类的不同方法时，不得不为每一个真实主题类或每一个方法都进行代理，这样会导致静态代理类爆炸，不易管理和维护。</li>\n<li>如果需要代理的方法很多且都使用增强方法，则导致代理类的不同方法中存在大量相同的代码，无法实现代码重用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>动态代理\n<ul>\n<li>优点\n<ul>\n<li>动态代理可以在运行时动态地创建代理对象，而不需要事先定义代理类，这样可以减少代码量和提高开发效率。</li>\n<li>动态代理可以根据不同的目标对象和需求，灵活地生成不同的代理对象，这样可以增加系统的可扩展性和可维护性。</li>\n<li>动态代理可以实现对目标对象的透明访问，客户端只需要使用抽象主题的接口，而不需要关心真实对象和代理对象的细节</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>动态代理需要使用反射和字节码技术来生成代理对象，这样会增加系统的复杂度和开销，也可能会影响系统的性能和稳定性。</li>\n<li>动态代理需要遵循一些约束和限制，例如JDK动态代理只能代理实现了接口的类，CGLIB动态代理不能代理final类或方法等，这样会降低系统的灵活性和通用性。</li>\n<li>动态代理比静态代理更难以理解和掌握，需要有一定的基础知识和经验才能使用好动态代理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>代理模式-应用场景\n<ul>\n<li>当我们需要访问一个远程对象时，可以使用<strong>远程代理</strong>，它可以隐藏远程对象的位置和通信细节，让客户端像访问本地对象一样访问远程对象。\n<ul>\n<li>JDK动态代理实现RPC</li>\n<li>RMI实现RPC</li>\n</ul>\n</li>\n<li>当我们需要创建一个开销很大的对象时，可以使用<strong>虚拟代理</strong>，它可以在真正需要的时候才创建真实对象，从而实现延迟加载和节省资源。</li>\n<li>当我们需要给一个对象增加一些额外的功能时，可以使用<strong>装饰代理</strong>，它可以在不修改原有对象的情况下，给对象添加一些新的行为或属性。</li>\n<li>当我们需要给一个对象增加一些访问控制或安全保护时，可以使用<strong>保护代理</strong>，它可以根据不同的用户或角色，对对象的访问进行限制或检查。</li>\n<li>当我们需要给一个对象增加一些日志记录或性能监控时，可以使用<strong>日志代理或性能代理</strong>，它可以在调用对象的方法之前或之后，记录相关的信息或数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-4\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-4\"></a> 模式实现</h4>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代理模式的不同方式</p>\n<blockquote>\n<ul>\n<li>静态代理：\n<ul>\n<li>由程序员创建或特定工具自动生成源代码，再对其进行编译。</li>\n<li>在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。</li>\n</ul>\n</li>\n<li>动态代理：\n<ul>\n<li>动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。</li>\n<li>代理类和委托类的关系是在程序运行时确定。<br />\n动态代理的2种实现方式</li>\n</ul>\n</li>\n<li>JDK动态代理</li>\n<li>CGLIB动态代理</li>\n</ul></blockquote>\n</blockquote>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;静态代理\n&#x2F;&#x2F; 抽象主题接口\npublic interface Subject &#123;\n    &#x2F;&#x2F; 定义一个抽象方法\n    void request();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 真实主题类\npublic class RealSubject implements Subject &#123;\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 真实的业务逻辑\n        System.out.println(&quot;RealSubject is doing something...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 代理主题类\npublic class Proxy implements Subject &#123;\n    &#x2F;&#x2F; 持有一个真实主题的引用\n    private RealSubject realSubject;\n\n    &#x2F;&#x2F; 构造方法，传入一个真实主题对象\n    public Proxy(RealSubject realSubject) &#123;\n        this.realSubject &#x3D; realSubject;\n    &#125;\n\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 在调用真实主题之前，可以执行一些额外操作\n        System.out.println(&quot;Proxy is doing something before...&quot;);\n        &#x2F;&#x2F; 调用真实主题的方法\n        realSubject.request();\n        &#x2F;&#x2F; 在调用真实主题之后，可以执行一些额外操作\n        System.out.println(&quot;Proxy is doing something after...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 客户端类\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个真实主题对象\n        RealSubject realSubject &#x3D; new RealSubject();\n        &#x2F;&#x2F; 创建一个代理对象，并传入真实主题对象\n        Proxy proxy &#x3D; new Proxy(realSubject);\n        &#x2F;&#x2F; 使用代理对象来调用抽象方法\n        proxy.request();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\nProxy is doing something before...\nRealSubject is doing something...\nProxy is doing something after...</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n&#x2F;&#x2F;JDK动态代理\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;从静态代理会发现——每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类。\n&#x2F;&#x2F;所以我们想办法通过一个代理类完成全部的代理功能，那么我们就需要用动态代理。\n&#x2F;&#x2F;在上面示例中，一个代理只能代理一种类型，而且是在编译器就已经确定被代理的对象。\n&#x2F;&#x2F;而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。\n&#x2F;&#x2F;在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类的支持。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象主题接口\npublic interface Subject &#123;\n    &#x2F;&#x2F; 定义一个抽象方法\n    void request();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 真实主题类\npublic class RealSubject implements Subject &#123;\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 真实的业务逻辑\n        System.out.println(&quot;RealSubject is doing something...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 日志处理器（代理主题）类，实现了InvocationHandler接口，用于定义代理逻辑\npublic class LogHandler implements InvocationHandler &#123;\n    &#x2F;&#x2F; 持有一个目标对象的引用\n    private Object target;\n\n    &#x2F;&#x2F; 构造方法，传入一个目标对象\n    public LogHandler(Object target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    &#x2F;&#x2F; 实现invoke方法，用于调用目标对象的方法，并在之前和之后执行日志操作\n        &#x2F;&#x2F;参数说明：\n        &#x2F;&#x2F;  Object proxy 被代理对象；\n        &#x2F;&#x2F;  Method method 要调用的方法；\n        &#x2F;&#x2F;  Object[] args 方法调用时所需要的参数\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        &#x2F;&#x2F; 在调用目标对象之前，记录开始时间\n        long startTime &#x3D; System.currentTimeMillis();\n        System.out.println(&quot;开始执行&quot; + method.getName() + &quot;方法...&quot;);\n\n        &#x2F;&#x2F; 调用目标对象的方法，并获取返回值\n        Object result &#x3D; method.invoke(target, args);\n\n        &#x2F;&#x2F; 在调用目标对象之后，记录结束时间和耗时\n        long endTime &#x3D; System.currentTimeMillis();\n        long duration &#x3D; endTime - startTime;\n        System.out.println(&quot;结束执行&quot; + method.getName() + &quot;方法，耗时&quot; + duration + &quot;毫秒&quot;);\n        &#x2F;&#x2F; 返回结果\n        return result;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 客户端类\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个真实主题对象\n        RealSubject realSubject &#x3D; new RealSubject();\n        &#x2F;&#x2F; 创建一个日志处理器对象，并传入真实主题对象\n        LogHandler logHandler &#x3D; new LogHandler(realSubject);\n        &#x2F;&#x2F; 使用Proxy类的静态方法newProxyInstance来动态地创建一个代理对象，传入真实主题对象的类加载器、接口和处理器\n            &#x2F;&#x2F;参数说明：\n            &#x2F;&#x2F;  ClassLoader loader 类的加载器；\n            &#x2F;&#x2F;  Class&lt;?&gt;[] interfaces 得到全部的接口；\n            &#x2F;&#x2F;  InvocationHandler h 得到InvocationHandler接口的子类的实例\n        Subject proxy &#x3D; (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), logHandler);\n        &#x2F;&#x2F; 使用代理对象来调用抽象方法\n        proxy.request();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n开始执行request方法...\nRealSubject is doing something...\n结束执行request方法，耗时1毫秒</code></pre>\n<hr />\n<h3 id=\"五桥接模式\"><a class=\"markdownIt-Anchor\" href=\"#五桥接模式\"></a> （五）桥接模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>建议阅读：<a href=\"https://blog.csdn.net/weixin_43905387/article/details/116940462?spm=1001.2014.3001.5502\">设计模式（八）—— 桥接模式（定义、案例分析、特点、缺点）</a></p></blockquote>\n<h4 id=\"模式介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-5\"></a> 模式介绍</h4>\n<ol>\n<li>\n<p>模式动机：</p>\n<ul>\n<li>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</li>\n<li>这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。</li>\n</ul>\n</li>\n<li>\n<p>模式定义：</p>\n<ul>\n<li>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>\n<li>它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>\n<li>它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。</li>\n</ul>\n</li>\n<li>\n<p>模式结构：</p>\n<ul>\n<li><img src=\"../img/5/5-1.png\" alt=\"桥接模式结构图\" /></li>\n</ul>\n</li>\n<li>\n<p>角色分析：</p>\n<ul>\n<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>\n<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>\n<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>\n<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>\n</ul>\n</li>\n<li>\n<p>模型评价：</p>\n<ul>\n<li>优点\n<ul>\n<li>当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。</li>\n<li>分离抽象接口及其实现部分（桥接模式中属性的定义是直接在接口类就定义了而没有到实现类才设置属性，这就是面向抽象编程）</li>\n<li>可以取代多层继承方案，极大地减少了子类的个数</li>\n<li>提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程。</li>\n<li>正确识别出系统中两个独立变化的维度并不是一件容易的事情。</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系</li>\n<li>抽象部分和实现部分可以以继承的方式独立扩展而互不影响</li>\n<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展</li>\n<li>不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-5\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-5\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5&#x3D;15支蜡笔，也就是说必须准备15个具体的蜡笔类。\n&#x2F;&#x2F;而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5&#x3D;8个类就可以实现15支蜡笔的功能。\n&#x2F;&#x2F;本实例使用桥接模式来模拟毛笔的使用过程\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;实现类接口——color\npublic interface Color&#123;\n\tpublic void bepaint(String penType, String name);\n&#125;\n\n&#x2F;&#x2F;具体实现类1——red等其他颜色\npublic class Red implements Color&#123;\n\tpublic void bepaint(String penType, String name)&#123;\n\t\tSystem.out.println(penType + &quot;红色的&quot; + name);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象类——pen\npublic abstract Pen\n&#123;\n    &#x2F;&#x2F;可视为接口作为属性通过setter注入，将实现化对象聚合到抽象类中，达成多层继承的效果\n\tprotected Color color;\n\tpublic void setColor(Color color)&#123;\n\t\tthis.color &#x3D; color;\n\t&#125;\n\tpublic abstract void draw(String name);\n&#125;\n\n&#x2F;&#x2F;扩充抽象类1——bigpen\npublic class BigPen extends Pen\n&#123;\n\tpublic void draw(String name)&#123;\n\t\tString penType &#x3D; &quot;大号毛笔绘制&quot;;\n\t\tthis.color.bepaint(penType, name);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client&#123;\n\tpublic static void main(String args[])&#123;\n         Color color;\n         Pen pen;\n\t\t\n\t\t&#x2F;&#x2F;利用xml反射读取指定对象\n\t\t color &#x3D; (Color)XMLUtil.getBean(&quot;color&quot;);&#x2F;&#x2F;理解成color &#x3D; new Red();\n\t\t pen&#x3D; (Pen)XMLUtil.getBean(&quot;pen&quot;);&#x2F;&#x2F;理解成pen &#x3D; new BigPen();\n         pen.setColor(color);&#x2F;&#x2F;把桥的另一边设置进来\n         pen.draw(&quot;鲜花&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n\t&lt;color&gt;Red&lt;&#x2F;color&gt;\n\t&lt;pen&gt;BigPen&lt;&#x2F;pen&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;工具类XMLUtil\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\npublic class XMLUtil\n&#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取品牌名称，并返回该品牌名称\n\tpublic static String getBean(String str)\n\t&#123;\n\t\ttry\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;创建文档对象\n\t\t\tDocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc &#x3D; builder.parse(new File(&quot;config.xml&quot;)); \n\t\t\n\t\t\t&#x2F;&#x2F;获取包含类名的文本节点\n\t\t\tif(str.equals(&quot;color&quot;))&#123;\n\t\t\t\tNodeList nl &#x3D; doc.getElementsByTagName(&quot;color&quot;);\n            \tNode classNode &#x3D; nl.item(0).getFirstChild();\n            \tString name &#x3D; classNode.getNodeValue().trim();\n            \treturn name;\n            &#125;else if(str.equals(&quot;pen&quot;)&#123;\n            \tNodeList nl &#x3D; doc.getElementsByTagName(&quot;pen&quot;);\n            \tNode classNode &#x3D; nl.item(0).getFirstChild();\n            \tString name &#x3D; classNode.getNodeValue().trim();\n            \treturn name;\n            &#125;\n            \n           &#125;   \n           \tcatch(Exception e)\n           \t&#123;\n           \t\te.printStackTrace();\n           \t\treturn null;\n           \t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n大号毛笔绘制红色的鲜花\n</code></pre>\n<hr />\n<h3 id=\"六装饰模式\"><a class=\"markdownIt-Anchor\" href=\"#六装饰模式\"></a> （六）装饰模式</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>建议阅读：<a href=\"https://blog.csdn.net/weixin_43905387/article/details/117032829?spm=1001.2014.3001.5502\">设计模式（十）—— 装饰模式（定义、案例分析、特点、缺点</a></p></blockquote>\n<h4 id=\"模式介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-6\"></a> 模式介绍</h4>\n<ol>\n<li>\n<p>模式动机：</p>\n<ul>\n<li>有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</li>\n<li>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现</li>\n</ul>\n</li>\n<li>\n<p>模式定义：</p>\n<ul>\n<li>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式</li>\n<li>装饰模式属于对象结构型模式</li>\n</ul>\n</li>\n<li>\n<p>模式结构：</p>\n<ul>\n<li><img src=\"../img/5/6-1.png\" alt=\"装饰模式结构图\" /></li>\n<li>半透明(Semi-transparent)装饰模式\n<ul>\n<li>用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义</li>\n<li>对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的</li>\n<li>可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便</li>\n<li>客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用扩展新增的方法</li>\n<li>最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象</li>\n</ul>\n</li>\n<li>透明(Transparent)装饰模式\n<ul>\n<li>要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型</li>\n<li>对于客户端而言，具体构件对象和具体装饰对象没有任何区别</li>\n<li>可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别</li>\n<li>可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象</li>\n<li>无法在客户端单独调用新增拓展方法。（只能内嵌使用）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>角色分析：</p>\n<ul>\n<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>\n<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>\n<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>\n<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>\n</ul>\n</li>\n<li>\n<p>模型评价：</p>\n<ul>\n<li>优点\n<ul>\n<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>\n<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>\n<li>装饰器模式完全遵守开闭原则</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>装饰器模式会增加许多子类，过度使用会增加程序得复杂性</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>\n<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>\n<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>\n</ul>\n</li>\n<li>改进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-6\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-6\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;半透明装饰模式\n&#x2F;&#x2F;变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。试用装饰模式设计该变形金刚\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件类-变形金刚\npublic abstract class Transform\n&#123;\n\tpublic abstract void move();\n&#125;\n&#x2F;&#x2F;具体构件类-汽车\npublic final class Car extends Transform&#123;\n\tpublic void Car()&#123;\n\t\tSystem.out.println(&quot;变形金刚是一辆车&quot;);\n\t&#125;\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;在陆地上移动&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;抽象装饰类Changer\npublic class Changer extends Transform&#123;\n\tprivate Transform t ;\n\tpublic Changer(Transform t)&#123;\n\t\tthis.t &#x3D; t;\n\t&#125;\n\tpublic void move()&#123;\n\t\tt.move();&#x2F;&#x2F;调用关联类自己的方法\n\t&#125;\t\n&#125;\n&#x2F;&#x2F;具体装饰类-机器人\npublic class Robot extends Changer&#123;\n\tpublic Robot(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成机器人&quot;);\n\t&#125;\n\tpublic void say()&#123;\n\t\tSystem.out.println(&quot;武器发射&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;具体装饰类-飞机\npublic class AirPlane extends Changer&#123;\n\tpublic AirPlane(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成飞机&quot;);\n\t&#125;\n\tpublic void fly()&#123;\n\t\tSystem.out.println(&quot;起飞&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class Client&#123;\n\tpublic static void main(String args[])&#123;\n\t\tTransform camaro;\n\t\tcamaro &#x3D; new Car();\n\t\tcamaro.move();\n\n\t\tRobot bumblebee &#x3D; new Robot(camaro);\n\t\tbumblebee.move();\n\t\tbumblebee.say();\n\t&#125;\n&#125;\n</code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;透明装饰模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件类\npublic abstract class Transform\n&#123;\n\tpublic abstract void move();\n&#125;\n&#x2F;&#x2F;具体构件类-汽车Car\npublic final class Car extends Transform&#123;\n\tpublic void Car()&#123;\n\t\tSystem.out.println(&quot;变形金刚是一辆车&quot;);\n\t&#125;\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;在陆地上移动&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;抽象装饰类Changer\npublic class Changer extends Transform&#123;\n\tprivate Transform t ;\n\tpublic Changer(Transform t)&#123;\n\t\tthis.t &#x3D; t;\n\t&#125;\n\tpublic void move()&#123;\n\t\tt.move();&#x2F;&#x2F;调用关联类自己的方法\n\t&#125;\t\n&#125;\n\n&#x2F;&#x2F;具体装饰类-机器人Robot\npublic class Robot extends Changer&#123;\n\tpublic Robot(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成机器人&quot;);\n\t&#125;\n    &#x2F;&#x2F;实现新增功能\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;武器发射&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;具体装饰类-飞机AirPlane\npublic class AirPlane extends Changer&#123;\n\tpublic AirPlane(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成飞机&quot;);\n\t&#125;\n    &#x2F;&#x2F;实现新增功能\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;起飞&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;客户端\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n        &#x2F;&#x2F;装饰前使用抽象构件声明\n\t\tTransform camaro;\n\t\tcamaro &#x3D; new Car();\n\t\tcamaro.move();\n        &#x2F;&#x2F;装饰后依然使用抽象构件声明\n\t\tTransform bumblebee;\n\t\tbumblebee &#x3D; new Robot(camaro);\n\t\tbumblebee.move();\n        &#x2F;&#x2F;装饰后依然使用抽象构件声明\n\t\tTransform plane;\n\t\tplane &#x3D; new AirPlane(camaro);\n\t\tplane.move();\n\t&#125;\n&#125;\n</code></pre>\n<hr />\n<h3 id=\"七享元模式\"><a class=\"markdownIt-Anchor\" href=\"#七享元模式\"></a> （七）享元模式</h3>\n<h4 id=\"模式介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#模式介绍-7\"></a> 模式介绍</h4>\n<ol>\n<li>模式动机：\n<ul>\n<li>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。</li>\n<li>例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景</li>\n</ul>\n</li>\n<li>模式定义：\n<ul>\n<li>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</li>\n<li>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</li>\n<li>细粒度的对象数量众多并且性质相近，就可以将这些对象信息分为两个部分：内部状态(intrinsic)和外部状态(extrinsic)。\n<ul>\n<li>内部状态是对象可以共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。内部状态可以作为一个对象的动态附加信息，不必直接存储于具体某个对象中，属于可共享的部分</li>\n<li>外部状态是对象的特有标记，随环境改变而改变，是对象不可以共享的状态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模式结构：<br />\n<img src=\"../img/5/7-1.png\" alt=\"享元模式结构图\" /></li>\n<li>角色分析：\n<ul>\n<li>抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>\n<li>具体享元角色（Concrete Flyweight）：实现抽象享元角色中所规定的接口。</li>\n<li>非享元角色（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>\n<li>享元工厂角色（Flyweight Factory）：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象</li>\n</ul>\n</li>\n<li>模型评价：\n<ul>\n<li>优点\n<ul>\n<li>可以减少内存中对象的数量，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能</li>\n<li>外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化</li>\n<li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长</li>\n</ul>\n</li>\n<li>应用场景\n<ul>\n<li>使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化</li>\n<li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长</li>\n</ul>\n</li>\n<li>改进\n<ul>\n<li>单纯享元模式：就是所有的具体享元类都是可共享的。</li>\n<li>复合享元模式：将纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是他们可以分解成单纯享元对象，而后者则可以共享。这样复合享元类中所包含的每个单纯享元类都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。</li>\n<li>享元模式和其他模式的联用\n<ul>\n<li>享元模式的享元工厂类（就是享元池）中通常有一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li>\n<li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li>\n<li>如果只有一个具体构件类没有抽象构建类，那么可以将抽象装饰类作为具体构建类子类。</li>\n<li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"模式实现-7\"><a class=\"markdownIt-Anchor\" href=\"#模式实现-7\"></a> 模式实现</h4>\n<ul>\n<li>java实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发，如图所示，现用享元模式模拟共享网络设备的设计原理。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象享元角色：网络设备\npublic abstract class NetworkDevice&#123;\n\tpublic String getType();\n\tpublic void use();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体享元角色1：交换机\n&#x2F;&#x2F;Switch交换机\npublic class Switch extends NetworkDevice&#123;\n\tprivate String type;\n\tpublic Switch(String type)&#123;\n\t\tthis.type &#x3D; type;\n\t&#125;\n\tpublic String getType()&#123;\n\t\treturn this.type;\n\t&#125;\n\tpublic void use()&#123;\n\t\tSystem.out.println(&quot;Linked by switch, type is&quot; + this.type);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体享元角色2：集线器\n&#x2F;&#x2F;Hub集线器\npublic class Hub extends NetworkDevice&#123;\n\tprivate String type;\n\tpublic Hub(String type)&#123;\n\t\tthis.type &#x3D; type;\n\t&#125;\n\tpublic String getType()&#123;\n\t\treturn this.type;\n\t&#125;\n\tpublic void use()&#123;\n\t\tSystem.out.println(&quot;Linked by switch, type is&quot; + this.type);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;享元工厂角色DeviceFactory\npublic class DeviceFactory &#123;\n\tprivate ArrayList devices &#x3D; new ArrayList();\n\tprivate int totalTerminal &#x3D; 0;\n\t\n\tpublic DeviceFactory()&#123;\n\t\tNetworkDevice nd1 &#x3D; new Switch(&quot;Cisco-WS-C2950-24&quot;);\n\t\tdevices.add(nd1);\n\t\tNetworkDevice nd2 &#x3D; new Hub(&quot;TP-LINK-HF8M&quot;);\n\t\tdevices.add(nd2);\n\t&#125;\n\n\tpublic NetworkDevice getNetworkDevice(String type)&#123;\n\t\tif(type.equalsIgnoreCase(&quot;cisco&quot;))&#123;\n\t\t\ttotalTerminal++;\n\t\t\treturn (NetworkDevice)devices.get(0);\n\t\t&#125; else if(type.equalsIgnoreCase(&quot;tp&quot;))&#123;\n\t\t\ttotalTerminal++;\n\t\t\treturn (NetworkDevice)devices.get(1);\n\t\t&#125;else&#123;\n\t\t\treturn null;\n\t\t&#125;\n\t&#125;\n\tpublic int getTotalDevice()&#123;\n\t\treturn devices.size();\n\t&#125;\t\n\tpublic int getTotalTerminal()&#123;\n\t\treturn totalTerminal;\n\t&#125;\t\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端测试代码\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n\t\tNetworkDevice nd1,nd2,nd3,nd4,nd5;\n\t\tDeviceFactory df &#x3D; new DeviceFactory();\n\n\t\tnd1 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd1.use();\n\n\t\tnd2 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd2.use();\n\n\t\tnd3 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd3.use();\n\n\t\tnd4 &#x3D; df.getNetworkDevice(&quot;tp&quot;);\n\t\tnd4.use();\n\n\t\tnd5 &#x3D; df.getNetworkDevice(&quot;tp&quot;);\n\t\tnd5.use();\n\n\t\tSystem.out.println(&quot;Total Device:&quot; + df.getTotalDevice());\n\t\tSystem.out.println(&quot;Total Terminal:&quot; + df.getTotalTerminal());\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is TP-LINK-HF8M\n    Linked by switch, type is TP-LINK-HF8M\n    Total Device:2\n    Total Terminal:5</code></pre>\n<hr />\n<h1 id=\"参考文献博客\"><a class=\"markdownIt-Anchor\" href=\"#参考文献博客\"></a> 参考文献/博客</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[1] <a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">设计模式</a><br />\n[2] <a href=\"https://segmentfault.com/a/1190000043340405\">15分钟入门23种设计模式：图解，范例和对比</a><br />\n[3] <a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解</a><br />\n[4] <a href=\"https://blog.csdn.net/csu_hjh/category_11505231.html?spm=1001.2014.3001.5482\">纸短勤常在</a><br />\n[5] <a href=\"https://www.jianshu.com/u/4859d67311a2\">小薯条学技术</a><br />\n[6] <a href=\"https://juejin.cn/post/7118956732721987614\">一次性搞懂设计模式–适配器模式</a><br />\n[7] <a href=\"https://zhuanlan.zhihu.com/p/444784138\">27 设计模式——组合模式（详解版）</a><br />\n[8] <a href=\"https://blog.csdn.net/weixin_43905387\">一孔之见️</a></p></blockquote>\n","feature":true,"text":" 设计模式-2 一、 结构型模式 结构型模式关注的是类或对象如何组织,描述如何将类或对象按某种布局组成更大的结构。 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问...","link":"","photos":[],"count_time":{"symbolsCount":"51k","symbolsTime":"46 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2\"><span class=\"toc-text\"> 设计模式-2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 一、 结构型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （一）外观模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （二）适配器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （三）组合模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-3\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （四）代理模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-4\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-4\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （五）桥接模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-5\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-5\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （六）装饰模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-6\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-6\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （七）享元模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-7\"><span class=\"toc-text\"> 模式介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-7\"><span class=\"toc-text\"> 模式实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E5%8D%9A%E5%AE%A2\"><span class=\"toc-text\"> 参考文献&#x2F;博客</span></a></li></ol>","author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"设计模式-3","uid":"1282d363af11675dd608d5f2af6828ad","slug":"6-设计模式-3","date":"2023-05-08T15:06:41.000Z","updated":"2023-05-10T12:00:50.977Z","comments":true,"path":"api/articles/6-设计模式-3.json","keywords":null,"cover":[],"text":" 设计模式-3 一、 行为型模式 行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使代码更加地清晰。描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":3,"path":"api/tags/设计模式.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"软件架构复习大纲","uid":"088ebac38bba3124d962899c15781d5f","slug":"4-软件架构复习","date":"2023-05-07T13:05:25.000Z","updated":"2023-05-08T11:57:03.026Z","comments":true,"path":"api/articles/4-软件架构复习.json","keywords":null,"cover":null,"text":" 软件架构复习 软件体系结构概论 软件危机 构件与软件重用 构件模型及实现 构件获取 构件管理 构件描述 构件分类与组织 构件重用 软件体系结构的兴起与发展 软件体系结构的定义 软件体系结构的应用现状 软件体系结构建模 建模的种类 结构模型 框架模型 动态模型 过程模型 功能模型...","link":"","photos":[],"count_time":{"symbolsCount":784,"symbolsTime":"1 mins."},"categories":[{"name":"软件架构","slug":"软件架构","count":1,"path":"api/categories/软件架构.json"}],"tags":[{"name":"软件架构","slug":"软件架构","count":2,"path":"api/tags/软件架构.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
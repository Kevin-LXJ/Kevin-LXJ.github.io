{"title":"设计模式-1","uid":"7674181de4c9b5a5cfd21fdfe784296a","slug":"设计模式-1","date":"2023-05-06T12:38:18.000Z","updated":"2023-05-06T15:31:20.571Z","comments":true,"path":"api/articles/设计模式-1.json","keywords":null,"cover":[],"content":"<h1 id=\"设计模式-1\"><a class=\"markdownIt-Anchor\" href=\"#设计模式-1\"></a> 设计模式-1</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>AI为入门者设计的学习思路：</p>\n<blockquote>\n<ol>\n<li>先理解什么是设计模式以及它的重要性和好处。可以阅读一些设计模式概述的文章或者书籍第一章。</li>\n<li>了解设计模式的分类和各个类别的主要模式。比如<strong>创建型模式</strong>有工厂模式、单例模式、建造者模式;<strong>结构型模式</strong>有代理模式、外观模式、适配器模式;<strong>行为型模式</strong>有策略模式、观察者模式、模板方法模式等。</li>\n<li>选择几个常用和简单的设计模式开始学习,比如<strong>工厂模式</strong>、<strong>单例模式</strong>、<strong>代理模式</strong>以及<strong>观察者模式</strong>。可以阅读相关书籍的内容,并做coding实践。</li>\n<li>继续学习其他常用模式,比如<strong>适配器模式</strong>、<strong>装饰器模式</strong>、<strong>外观模式</strong>、<strong>模板方法模式</strong>等。同样通过理论学习和coding实践进行深入理解。</li>\n<li>学习了常用设计模式后,可以了解一些不太常用但也很有用的设计模式,比如桥接模式、组合模式、命令模式、迭代器模式等。</li>\n<li>回顾设计模式学习,理解不同设计模式之间的区别和使用场景,学习如何选择合适的设计模式。</li>\n<li>项目实践,在实际项目中运用适当的设计模式,解决设计问题。实践出真知,项目实践是学习设计模式的最好方式。</li>\n<li>保持设计模式的学习和运用,跟踪设计模式的发展和演变,不断学习新的设计模式和案例</li>\n</ol></blockquote>\n</blockquote>\n<h2 id=\"一-设计模式相关概念\"><a class=\"markdownIt-Anchor\" href=\"#一-设计模式相关概念\"></a> 一、 设计模式相关概念</h2>\n<h3 id=\"一设计模式的简介\"><a class=\"markdownIt-Anchor\" href=\"#一设计模式的简介\"></a> （一）设计模式的简介</h3>\n<h4 id=\"1简述\"><a class=\"markdownIt-Anchor\" href=\"#1简述\"></a> 1.简述：</h4>\n<ul>\n<li>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>\n<li>设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。</li>\n</ul>\n<h4 id=\"2历史\"><a class=\"markdownIt-Anchor\" href=\"#2历史\"></a> 2.历史：</h4>\n<ul>\n<li>1995 年，GoF（Gang of Four，四人组）合作出版了**《Design Patterns: Elements of Reusable Object-Oriented Software》**一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称【GoF设计模式】。</li>\n</ul>\n<h3 id=\"二设计模式的七大原则\"><a class=\"markdownIt-Anchor\" href=\"#二设计模式的七大原则\"></a> （二）设计模式的七大原则</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设计模式有7大原则，目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p></blockquote>\n<p><img src=\"/source/img/2/principal.png\" alt=\"设计模式的七大原则\" /></p>\n<h4 id=\"1开闭原则open-closed-principleocp\"><a class=\"markdownIt-Anchor\" href=\"#1开闭原则open-closed-principleocp\"></a> 1.开闭原则（Open Closed Principle，OCP）</h4>\n<ul>\n<li>含义： 软件实体应当对扩展开放，对修改关闭</li>\n<li>表现：\n<ul>\n<li>扩展时，不修改原有代码或者尽量少修改原有代码</li>\n<li>修改时，尽量不修改原有代码或者尽量少修改原有代码</li>\n</ul>\n</li>\n<li>实现方法： 通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</li>\n</ul>\n<h4 id=\"2依赖倒置原则dependence-inversion-principledip\"><a class=\"markdownIt-Anchor\" href=\"#2依赖倒置原则dependence-inversion-principledip\"></a> 2.依赖倒置原则（Dependence Inversion Principle，DIP）</h4>\n<ul>\n<li>含义： 要面向接口编程，不要面向实现编程, 降低类间的耦合性</li>\n<li>表现：\n<ul>\n<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li>\n<li>抽象不应该依赖具体类，具体类应该依赖抽象</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>使用接口或抽象类进行变量类型声明、参数类型说明、方法返回类型声明、以及数据类型的转换等\n<ul>\n<li>在需要时，可将具体类通过依赖注入的方式注入到其他对象中</li>\n</ul>\n</li>\n<li>一个具体类应只实现接口或抽象类xiang类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法</li>\n<li>任何类都不应该从具体类派生</li>\n<li>使用继承时尽量遵循里氏替换原则</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3里氏代换原则liskov-substitution-principlelsp\"><a class=\"markdownIt-Anchor\" href=\"#3里氏代换原则liskov-substitution-principlelsp\"></a> 3.里氏代换原则（Liskov Substitution Principle，LSP）</h4>\n<ul>\n<li>含义：所有引用基类的地方必须能 透明/不受影响 地使用其子类的对象（继承必须确保超类所拥有的性质在子类中仍然成立）</li>\n<li>表现：\n<ul>\n<li>子类可以替换任何基类，而程序逻辑不变</li>\n<li>子类可以扩展父类的功能，但不能改变父类原有的功能（即 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法）</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>\n<li>子类中可以增加自己特有的方法</li>\n<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>\n<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>\n<li>在类方法设计时，方法参数应尽量使用抽象类型（抽象类或接口）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4合成复用原则composite-reuse-principlecrp\"><a class=\"markdownIt-Anchor\" href=\"#4合成复用原则composite-reuse-principlecrp\"></a> 4.合成复用原则（Composite Reuse Principle，CRP）</h4>\n<ul>\n<li>含义：在一个新的对象里使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象委派以达到复用的目的</li>\n<li>表现：\n<ul>\n<li>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现；如果要使用继承关系，则必须严格遵循里氏替换原则</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5单一职责原则single-responsibility-principlesrp\"><a class=\"markdownIt-Anchor\" href=\"#5单一职责原则single-responsibility-principlesrp\"></a> 5.单一职责原则（Single Responsibility Principle，SRP）</h4>\n<ul>\n<li>含义：规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</li>\n</ul>\n<h4 id=\"6迪米特原则law-of-demeterlod最少知识原则least-knowledge-principlelkp\"><a class=\"markdownIt-Anchor\" href=\"#6迪米特原则law-of-demeterlod最少知识原则least-knowledge-principlelkp\"></a> 6.迪米特原则（Law of Demeter，LoD）/最少知识原则（Least Knowledge Principle，LKP)</h4>\n<ul>\n<li>含义：\n<ul>\n<li>一个软件实体应当尽可能少地与其他实体发生相互作用</li>\n<li>只与你的直接朋友交谈，不跟“陌生人”说话\n<ul>\n<li>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>表现：\n<ul>\n<li>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>\n<li>在类的结构设计上，尽量降低类成员的访问权限。</li>\n<li>在类的设计上，优先考虑将一个类设置成不变类。</li>\n<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>\n<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>\n<li>谨慎使用序列化（Serializable）功能。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7接口隔离原则interface-segregation-principleisp\"><a class=\"markdownIt-Anchor\" href=\"#7接口隔离原则interface-segregation-principleisp\"></a> 7.接口隔离原则（Interface Segregation Principle，ISP）</h4>\n<ul>\n<li>含义：使用多个专门的接口比使用单一的总接口要好</li>\n<li>表现：\n<ul>\n<li>客户端不应该被迫依赖于它不使用的方法</li>\n<li>一个类对另一个类的依赖应该建立在最小的接口上</li>\n</ul>\n</li>\n<li>实现方法：\n<ul>\n<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>\n<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>\n<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>\n<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>\n</ul>\n</li>\n</ul>\n<table>\n    <thead>\n        <tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr>\n    </thead>\n    <tbody>\n        <tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr>\n        <tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr>\n        <tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr>\n        <tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr>\n        <tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr>\n        <tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr>\n        <tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr>\n    </tbody>\n</table>\n<h3 id=\"三设计模式的类型\"><a class=\"markdownIt-Anchor\" href=\"#三设计模式的类型\"></a> （三）设计模式的类型</h3>\n<ul>\n<li>基本设计模式分为三大类：创建型、结构型、行为型。\n<ul>\n<li>创建型模式：处理的是<strong>对象的创建过程</strong>（通过各种方式创建对象，使对象创建和管理变得简单）</li>\n<li>结构型模式：处理的是<strong>对象/类的组合</strong></li>\n<li>行为型模式：处理<strong>类和对象间的交互方式和任务分布</strong>。（只有类可以创建对象，接口只能被实现）</li>\n</ul>\n</li>\n<li>其他设计模式：J2EE模式</li>\n</ul>\n<table>\n<tbody>\n    <tr><th style=\"width:5%;\">序号</th><th style=\"width:45%;\">模式 &amp; 描述</th><th>包括</th></tr>\n    <tr>\n        <td>1</td>\n        <td><b>创建型模式</b><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>\n        <td>\n            <ul>\n            <li>工厂模式（Factory Pattern）</li>\n            <li>抽象工厂模式（Abstract Factory Pattern）</li>\n            <li>单例模式（Singleton Pattern）</li>\n            <li>建造者模式（Builder Pattern）</li>\n            <li>原型模式（Prototype Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td><b>结构型模式</b><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>\n        <td>\n            <ul>\n            <li>适配器模式（Adapter Pattern）</li>\n            <li>桥接模式（Bridge Pattern）</li>\n            <li>过滤器模式（Filter、Criteria Pattern）</li>\n            <li>组合模式（Composite Pattern）</li>\n            <li>装饰器模式（Decorator Pattern）</li>\n            <li>外观模式（Facade Pattern）</li>\n            <li>享元模式（Flyweight Pattern）</li>\n            <li>代理模式（Proxy Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td><b>行为型模式</b><br>这些设计模式特别关注对象之间的通信。</td>\n        <td>\n            <ul>\n            <li>责任链模式（Chain of Responsibility Pattern）</li>\n            <li>命令模式（Command Pattern）</li>\n            <li>解释器模式（Interpreter Pattern）</li>\n            <li>迭代器模式（Iterator Pattern）</li>\n            <li>中介者模式（Mediator Pattern）</li>\n            <li>备忘录模式（Memento Pattern）</li>\n            <li>观察者模式（Observer Pattern）</li>\n            <li>状态模式（State Pattern）</li>\n            <li>空对象模式（Null Object Pattern）</li>\n            <li>策略模式（Strategy Pattern）</li>\n            <li>模板模式（Template Pattern）</li>\n            <li>访问者模式（Visitor Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td><b>J2EE 模式</b><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>\n        <td>\n            <ul>\n            <li>MVC 模式（MVC Pattern）</li>\n            <li>业务代表模式（Business Delegate Pattern）</li>\n            <li>组合实体模式（Composite Entity Pattern）</li>\n            <li>数据访问对象模式（Data Access Object Pattern）</li>\n            <li>前端控制器模式（Front Controller Pattern）</li>\n            <li>拦截过滤器模式（Intercepting Filter Pattern）</li>\n            <li>服务定位器模式（Service Locator Pattern）</li>\n            <li>传输对象模式（Transfer Object Pattern）</li>\n            </ul>\n        </td>\n    </tr>\n</tbody></table>\n<h2 id=\"二-创建型模式\"><a class=\"markdownIt-Anchor\" href=\"#二-创建型模式\"></a> 二、 创建型模式</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>创建型模式的关注点是“怎样创建对象”，特点是“将对象的创建与使用分离”，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成</p>\n<ul>\n<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>\n<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>\n<li>单例（Singleton）模式：类只能产生一个实例，保证全局使用的是同一对象。</li>\n<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>\n<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>\n</ul></blockquote>\n<h3 id=\"一工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#一工厂模式\"></a> （一）工厂模式</h3>\n<h3 id=\"二抽象工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#二抽象工厂模式\"></a> （二）抽象工厂模式</h3>\n<h3 id=\"三单例模式\"><a class=\"markdownIt-Anchor\" href=\"#三单例模式\"></a> （三）单例模式</h3>\n<h3 id=\"四建造者模式\"><a class=\"markdownIt-Anchor\" href=\"#四建造者模式\"></a> （四）建造者模式</h3>\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\"></a> 参考文献</h1>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[1] <a href=\"https://www.runoob.com/design-pattern/design-pattern-tutorial.html\">设计模式</a><br />\n[2] <a href=\"https://segmentfault.com/a/1190000043340405\">15分钟入门23种设计模式：图解，范例和对比</a><br />\n[3] <a href=\"https://blog.csdn.net/penriver/article/details/118571991\">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解</a></p></blockquote>\n","feature":true,"text":" 设计模式-1 AI为入门者设计的学习思路： 先理解什么是设计模式以及它的重要性和好处。可以阅读一些设计模式概述的文章或者书籍第一章。 了解设计模式的分类和各个类别的主要模式。比如创建型模式有工厂模式、单例模式、建造者模式;结构型模式有代理模式、外观模式、适配器模式;行为型模式有...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\"> 设计模式-1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> 一、 设计模式相关概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\"> （一）设计模式的简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E7%AE%80%E8%BF%B0\"><span class=\"toc-text\"> 1.简述：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E5%8E%86%E5%8F%B2\"><span class=\"toc-text\"> 2.历史：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\"> （二）设计模式的七大原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99open-closed-principleocp\"><span class=\"toc-text\"> 1.开闭原则（Open Closed Principle，OCP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99dependence-inversion-principledip\"><span class=\"toc-text\"> 2.依赖倒置原则（Dependence Inversion Principle，DIP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99liskov-substitution-principlelsp\"><span class=\"toc-text\"> 3.里氏代换原则（Liskov Substitution Principle，LSP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99composite-reuse-principlecrp\"><span class=\"toc-text\"> 4.合成复用原则（Composite Reuse Principle，CRP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99single-responsibility-principlesrp\"><span class=\"toc-text\"> 5.单一职责原则（Single Responsibility Principle，SRP）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99law-of-demeterlod%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99least-knowledge-principlelkp\"><span class=\"toc-text\"> 6.迪米特原则（Law of Demeter，LoD）&#x2F;最少知识原则（Least Knowledge Principle，LKP)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99interface-segregation-principleisp\"><span class=\"toc-text\"> 7.接口隔离原则（Interface Segregation Principle，ISP）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\"> （三）设计模式的类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 二、 创建型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （一）工厂模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （二）抽象工厂模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （三）单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> （四）建造者模式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\"> 参考文献</span></a></li></ol>","author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"软件架构实验","uid":"0957f802a029d0594b09e3b585318be7","slug":"1-软件架构实验","date":"2023-05-03T06:47:49.000Z","updated":"2023-05-06T06:28:14.438Z","comments":true,"path":"api/articles/1-软件架构实验.json","keywords":null,"cover":[],"text":" 软件架构实验 题目1 使用原始socket()实现一个C/S架构的应用，支持服务器时间回显示 要求：从客户端发送命令，接收服务器的时间并显示到终端 相关原理 C/S结构 socket python实现 环境：python3.9.13 编辑器：vscode 终端：powershe...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"软件架构","slug":"软件架构","count":1,"path":"api/tags/软件架构.json"},{"name":"实验","slug":"实验","count":1,"path":"api/tags/实验.json"}],"author":{"name":"Kevin","slug":"blog-author","avatar":"/img/avatar/OIP-C.jpg","link":"/","description":"我真的是ikun","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}
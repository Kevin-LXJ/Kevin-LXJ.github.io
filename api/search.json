[{"id":"eb05dba7bd0d4c39c42b68d64c5450a9","title":"马克思主义复习","content":"\n\n\n\n\n\n\n\n\n复习纲要\n\n报告（2000字，无需目录，摘要，关键词，重点论证，考试时候交报告——小组单元）\n题型：单选20/1；多选15/2；简答3/10【书中出题字数少的需要：要点+说明】；论述1/20【无需结合教材要点】\n0：（马克思主义、创立时间、理论来源、发展脉络、特征、当代价值和时代意义）\n1：【世界的统一性在于它的物质性】\n\n（物质、运动、静止、时间、空间、意识的概念、本质、内容、客观、意识的能动作用）\n（ 联系的概念和特点（解析例子）、发展的实质、为什么新事物是不可战胜的、矛盾的对立与统一、矛盾的普遍性和特殊性、矛盾的基本矛盾（抽象）、矛盾的主要矛盾（具体）、矛盾的主要方面和次要方面、否定的内涵（扬弃）、否定揭示的意义、量变（数量，位置））\n\n2：【实践与认识的关系问题（正向和反向）（重大问题）】【真理的特点（相对性、绝对性、客观性）（重大问题）】\n\n\n\n\n\n\n\n\n\n（实践的基本特征（社会历史性）、实践的结构（主体 客体 工具《重点》）、实践的形式（生产实践《最基本》 科学实验 社会交往）、认识的两次飞跃（感性到理性）、感性认识的三个呈现、感性的特点（直接，具体）、感性上升到理性认识的途径、理性认识的三个呈现、理性的特点（间接，抽象）、价值的概念、价值的特点、真理和价值的关系、价值判断（先讲对错再讲好坏）\n\n3：【社会存在和社会意识的关系问题（解释社会历史观）（重大问题）】【物质生产方式的决定性作用（重大问题）】【科学技术在社会发展中的作用（重大问题）】【文化在社会发展中的作用（23版才有，重大问题）】\n\n\n\n\n\n\n\n\n\n（社会存在的三个层面（地理环境《三个作用》人口因素  物质生产方式）、社会意识（1个体与群体意识 2社会心理与社会意识形式《意识形态》）、社会的基本矛盾（两个范畴《1生产力 2经济基础》））\n\n4：【价值规律及其作用（重大问题）】\n\n\n\n\n\n\n\n\n\n（商品的概念（两个条件《劳动产品 交换》）、商品经济、商品产生的历史条件、使用价值和交换价值的概念和关系、什么决定商品的价值、抽象劳动和具体劳动、社会必要劳动时间）\n\n5：【资本主义的本质（重大问题）】【资本主义的发展规律（重大问题）】【资本主义被社会主义所替代的历史必然性（重大问题）】\n\n\n\n\n\n\n\n\n\n（垄断资本主义发展的两个阶段）\n\n6：【社会主义建设过程的长期性（重大问题）】【社会主义发展道路的多样性（重大问题）】\n\n\n\n\n\n\n\n\n\n（空想社会主义的发展阶段（两本书和两个人）欧文傅里叶圣西门）\n\n7：共产主义的特点\n\n\n 导论\n\n马克思主义的组成\n\n马克思主义哲学\n马克思主义政治经济学\n马克思主义科学社会主义\n\n\n创立时间\n\n19世纪40年代\n1848年2月，《共产党宣言》发表，标志着马克思主义诞生\n\n\n理论来源\n\n德国古典哲学\n英国古典政治经济学\n英法空想社会主义\n\n\n发展脉络\n\n列宁主义\n毛泽东思想\n邓小平理论\n三个代表重要思想\n科学发展观\n习近平新时代中国特色社会主义思想\n\n\n特征\n\n科学性\n人民性\n实践性\n发展性\n\n\n当代价值/时代意义\n\n观察当代世界变化的认识工具\n指引当代中国发展的行动指南\n引领人类社会进步的科学真理\n\n\n\n 世界的物质性及发展规律\n 世界的多样性与物质统一性\n\n\n\n\n\n\n\n\n\n\n\n（物质、运动、静止、时间、空间、意识的概念、本质、内容、客观、意识的能动作用）\n\n\n 物质及其存在方式\n\n物质\n\n是对世界上客观存在的各种事物共同本质的概括\n\n\n物质的根本属性是运动\n\n相对静止\n\n\n物质的存在方式\n\n时间\n空间\n\n\n\n 物质与意识的辩证关系\n\n物质决定意识\n意识对物质具有反作用\n主观能动性和客观规律性的辩证统一\n\n\n\n\n\n\n\n\n\n\n【世界的统一性在于它的物质性（重大问题）】\n 世界的物质统一性\n\n世界的统一性在于它的物质性，世界统一于物质\n\n第一，自然界是物质的。\n第二，人类社会本质上是生产实践基础上形成的物质体系。\n第三，人的意识统一于物质。\n世界的物质统一性是多样性的统一。\n\n\n世界的物质统一性原理的意义\n\n世界的物质统一性原理是辩证唯物主义最基本、最核心的观点，是马克思主义的基石。\n一切从实际出发，是世界的物质统一性原理在现实生活中和实际工作中的生动体现，是在坚持和发展中国特色社会主义伟大实践中想办法、办事情的根本立足点。\n\n\n\n 事物的普遍联系与变化发展\n\n略\n\n 联系和发展的普遍性\n\n联系\n\n指事务内部各要素之间和事物之间相互影响、相互制约、相互作用的关系。\n联系的特点\n\n联系具有客观性。\n\n事物的联系是事物本身的属性，不以人的意志为转移。\n\n\n联系具有普遍性。\n\n任何事物都具有内在的结构性。\n任何事物都不能孤立存在。\n整个世界是相互联系的统一整体。\n@例如：5g网络、大数据、智能感知等前沿信息技术的迅猛发展\n\n\n联系具有多样性。\n\n事物联系的主要方式有直接联系与间接联系、内部联系与外部联系、必然联系与偶然联系等。\n\n\n联系具有条件性。\n\n联系是矛盾着的事物的联系，联系是有条件的。\n\n\n\n\n\n\n发展\n\n指事物变化中前进的、上升的运动。\n发展的实质\n\n新事物的产生和旧事物的灭亡\n\n\n为什么新事物是不可战胜的\n\n第一，就新事物与环境的关系而言\n\n新事物有新的要素、结构和功能，适应已经变化的环境和条件；\n旧事物的各种要素和功能已经不适应环境和客观条件的变化；\n\n\n第二，就新事物与旧事物的关系而言\n\n新事物由旧事物孕育成熟，既否定了旧事物消极的东西，又保留了旧事物合理的、适应新条件的因素，并添加了旧事物所不能容纳的新内容；\n\n\n\n\n\n\n\n 对立统一规律是事物发展的根本规律\n\n\n\n\n\n\n\n\n\n矛盾的统一属性称同一性；矛盾的对立属性称斗争性。\n\n矛盾的同一性和斗争性\n\n同一性\n\n指矛盾着的对立面相互依存、相互贯通的性质和趋势\n\n含义1：矛盾着的对立面相互依存，互为存在的前提，并处于一个统一体中。\n含义2：矛盾着的对立面相互贯通，在一定条件下可以相互转换。\n\n\n\n\n斗争性\n\n指矛盾着的对立面相互排斥、相互分离的性质和趋势\n\n分为对抗性矛盾和非对抗性矛盾两种基本形式\n\n\n\n\n同一性和斗争性的关系\n\n矛盾的同一性和斗争性相互连结、相辅相成\n斗争性寓于同一性之中，同一性通过斗争性来体现\n同一性是有条件的、相对的；斗争性是无条件的、绝对的\n矛盾的同一性和斗争性相结合，构成事物的矛盾运动，推动事物的发展变化\n\n\n在事物发展中的作用\n\n同一性\n\n同一性是事物存在和发展的前提\n同一性使矛盾双方相互吸收有利于自身的因素，在相互作用中各自得到发展\n同一性规定着事物转化的可能和发展的趋势\n\n\n斗争性\n\n矛盾双方的斗争为对立面的转化、事物的质变创造条件\n矛盾双方的斗争是一种矛盾统一体项另一种矛盾统一体过渡的决定性力量\n矛盾双方的相互排斥和否定促进旧的矛盾统一体破裂，新的矛盾统一体产生\n\n\n\n\n和谐\n\n矛盾的一种特殊表现形式，体现着矛盾双方的相互依存、相互促进、共同发展\n\n\n\n\n矛盾的普遍性和特殊性\n\n普遍性\n\n指矛盾存在于一切事物的发展过程中，存在于一切事物发展过程的始终\n\n\n特殊性\n\n指各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各有特点\n\n\n事物是由多种矛盾构成的\n\n主要矛盾是矛盾体系中处于支配地位、对事物发展起决定性作用的矛盾\n次要矛盾是矛盾体系中处于从属地位、对事物发展起次要作用的矛盾\n\n\n事物的性质是由主要矛盾的主要方面决定的\n\n在每一对矛盾中，处于支配地位、起着主导作用的一方，称为主要方面；处于从属地位、起着次要作用的一方，称为次要方面\n\n\n\n\n\n\n\n\n\n\n\n\n基本矛盾：生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。\n主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。\n主要矛盾是基本矛盾的具体表现，特别是生产关系和生产力之间矛盾的具体表现\n\n\n 量变质变规律和否定之否定规律\n\n量变质变规律\n\n量变\n\n指事物数量的增减和组成要素排列次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物发展渐进过程的连续性\n\n\n质变\n\n指事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物发展渐进过程和连续性的中断\n\n\n量变和质变的辩证关系\n\n量变是质变的必要准备\n质变是量变的必然结果\n量变和质变是相互渗透的\n\n\n意义\n\n体现了事物发展的渐进性和飞跃性的统一\n\n\n\n\n否定之否定规律\n\n事物的发展通过其内在矛盾运动以自我否定的方式而实现\n否定之否定\n\n指事物发展过程中，旧事物被新事物所取代，但新事物又保留了旧事物的某些东西，是旧事物的否定和新事物的肯定的统一\n\n\n唯物辩证法的否定观揭示了否定的深刻内涵\n\n否定是事物的自我否定、自我发展，是事物内部矛盾运动的结果\n否定是事物发展的环节，是旧事物向新事物的转变，是从旧质到新质的飞跃。只有经过否定，旧事物才能转化为新事物\n否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物是通过否定环节联系起来的\n辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素\n\n\n否定之否定规律揭示了事物发展的前进性与曲折性的统一\n\n\n\n 实践与认识及发展规律\n 实践与认识\n 科学的实践观及其意义\n\n略\n\n\n\n\n\n\n\n\n\n\n【实践与认识的关系问题（正向和反向）（重大问题）】\n 实践的本质与基本结构\n\n实践\n\n实践是人类生存和发展的基本活动，是人类社会生活的本质，是人类认识产生和发展的基础，也是真理与价值统一的基础\n\n\n实践的本质\n\n实践是人类能动地改造世界的社会性的物质活动，具有客观实在性、自觉能动性和社会历史性3个基本特征\n\n实践是人类改造世界的客观物质活动\n实践是人的自觉能动的活动\n实践是社会性、历史性的活动\n\n\n\n\n实践的基本结构\n\n实践的主体、客体和中介是实践活动的三项基本要素，三者的有机统一构成实践的基本结构\n\n实践的主体\n\n指具有一定的主体能力、从事现实社会实践活动的人\n实践主体的能力：自然能力、精神能力（知识性因素和非知识性因素）\n实践主体的基本形态：个体主体、群体主体、人类主体\n\n\n实践的客体\n\n指实践活动指向的对象\n实践客体的类型：\n\n天然客体、人工客体\n自然客体、社会客体\n物质性客体、精神性客体\n\n\n\n\n实践中介\n\n指各种形式的工具、手段以及运用、操作这些工具、手段的程序和方法等\n实践中介的两种子系统\n\n作为人的肢体延长、感官延申、体能放大的物质性工具系统：机器系统、动力能源系统（火车、计算机、雷达）\n语言符号工具系统：语言系统、符号系统\n\n\n\n\n\n\n\n\n实践形式的多样性\n\n实践形式的三种基本类型\n\n物质生产实践\n社会政治实践\n科学文化实践\n\n\n三者紧密联系：物质生产实践是最基本的实践活动，构成全部社会生活的基础；社会政治实践和科学文化实践是在物质生产实践基础上发展起来的，受物质生产实践的制约并对其产生能动的反作用\n\n\n实践对认识的决定作用（重大问题）\n\n实践是认识的来源\n\n认识的内容是在实践活动的基础上产生和发展的\n\n\n实践是认识发展的动力\n\n实践的需要推动认识的产生和发展，推动人类的科学发现和技术发明，推动人类的思想进步和理论创新\n\n\n实践是认识的目的\n\n人们通过实践获得认识，其最终目的是为实践服务，指导实践，以满足人们生活和生产的需要\n\n\n实践是检验认识真理性的唯一标准\n\n\n\n 认识的本质与过程\n\n认识的本质\n\n认识是主体在实践基础上对客体的能动反映\n\n\n认识的两次飞跃\n\n从实践到认识的飞跃\n\n表现为在实践基础上认识活动由感性认识能动地飞跃到理性认识\n\n感性认识\n\n感性认识的3个呈现\n\n感觉、知觉、表象\n\n\n感性认识的特点\n\n直接性、具体性\n\n\n感性认识上升到理性认识的基本条件\n\n投身实践、深入调查，获取十分丰富和合乎实际的感性材料\n经过思考作用，运用理论思维和科学抽象 将丰富的感性材料处理加工，形成概念和理论的系统\n\n\n\n\n理性认识\n\n理性认识的3个呈现\n\n概念、判断、推理\n\n\n理性认识的特点\n\n间接性、抽象性\n\n\n\n\n\n\n\n\n从认识到实践的飞跃\n\n表现为在认识基础上实践活动由理性认识能动地飞跃到实践\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n【真理的特点（相对性、绝对性、客观性）（重大问题）】\n 真理与价值\n\n真理\n\n真理的客观性\n\n指真理的内容是对客观事物及其规律的正确反映，真理不包含着依赖于人和人的意识的客观内容。\n\n\n真理的绝对性\n\n指真理主客观统一的确定性和发展的无限性。\n\n\n真理的相对性\n\n指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的\n\n\n\n\n价值\n\n价值是反映主体与客体之间意义关系的哲学范畴，是客体对个人、群体乃至整个社会的生活和活动所具有的意义。\n价值的特点\n\n价值的主体性\n\n指价值直接与主体相联系，始终以主体为中心\n\n\n价值的客观性\n\n指在一定条件下客体对于主体的不依赖于主体的主观意识而存在\n\n\n价值的多维性\n\n指每个主体的价值关系具有多样性，同一客体相对于主体的不同需要会产生不同的价值\n\n\n价值的社会历史性\n\n主体和客体的不断变化决定了价值的社会历史性\n\n\n\n\n\n\n真理与价值在实践中的辩证统一\n\n人们的实践活动总是受着真理尺度和价值尺度的双重制约\n任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一\n真理与价值是紧密联系、不可分割的辩证统一关系\n\n价值尺度必须以真理为前提\n人类所需的内在重叠度，推动着不断发现真理\n\n\n真理与价值是否达到具体的、历史的统一，必须通过实践来验证\n\n\n\n 认识世界和改造世界\n\n略\n\n 人类社会及发展规律\n 人类社会的存在与发展\n\n\n\n\n\n\n\n\n\n【物质生产方式的决定性作用（重大问题）】\n 社会存在与社会意识\n\n社会存在\n\n社会存在是指社会物质生活条件，是社会生活的物质方面，主要包括自然地理环境、人口因素和物质生产方式\n\n自然地理环境\n\n自然地理环境提供了社会生活和生产资料的来源\n自然地理环境的优劣对劳动生产率的提高产生积极或消极的影响，并对社会发展起促进或延缓的作用\n合理利用自然资源、保护生态环境，是社会得以正常发展的必要条件\n\n\n人口因素\n物质生产方式\n\n物质生产活动及生产方式是人类社会赖以存在和发展的基础，是人类其他一切活动的首要前提\n物质生产活动及生产方式决定社会的结构、性质和面貌，制约人们的全部社会生活\n\n\n\n\n\n\n社会意识\n\n社会意识是社会存在的反映，是社会生活的精神方面\n社会意识的划分\n\n个体意识和群体意识\n\n个体意识\n群体意识\n\n\n社会心理和社会意识形式\n\n社会心理\n社会意识形式\n\n意识形态\n\n指反映一定经济关系、政治关系，以及一定阶级或社会集团利益和要求的思想体系，是社会意识形式中构成观念上层建筑的部分\n包括政治法律思想、宗教、道德、哲学、艺术等\n\n\n非意识形态\n\n包括自然科学、语言学、形式逻辑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n【社会存在和社会意识的关系问题（解释社会历史观）（重大问题）】\n\n社会存在和社会意识的辩证关系\n\n社会存在和社会意识是辩证统一的，社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在\n\n社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映\n社会意识是人们进行社会物质交往的产物\n社会意识是具体的、历史的？\n\n\n社会存在和社会意识的辩证关系原理的重要意义\n\n树立科学历史观\n\n从社会生活各领域中划分出经济领域，从一切社会关系划分出生产关系，将其作为决定其他一切关系的基本的、原始的关系\n把一切社会关系归结于生产关系，并进一步归结于生产力发展\n从而将社会形态的发展看作一种自然历史过程，科学揭示人类社会发展的规律\n\n\n\n\n\n\n\n 社会基本矛盾及其运动规律\n\n社会基本矛盾的划分\n\n生产力和生产关系的矛盾\n经济基础和上层建筑的矛盾\n\n\n生产力和生产关系的矛盾运动及其规律\n\n生产力\n\n是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。\n生产力的特点\n\n生产力具有客观现实性和社会历史性\n生产力的发展要求和生产力水平、性质和状况三方面精密联系（是现实的生产力不断获得解放和发展的基本要求）\n\n生产力的水平表现为生产发展的现实程度\n生产力的性质取决于生产的物质技术性质，主要是劳动资料的性质\n生产力状况是生产力水平和性质的统一，表现为生产力的运行状态或发展态势\n\n\n\n\n生产力的基本要素\n\n劳动资料/劳动手段\n\n劳动资料是劳动者在劳动过程中所使用的物质资料或物质条件，最重要的是生产工具\n生产工具是区分社会经济时代的客观依据\n\n\n劳动对象\n\n一切自然物质都是可能的劳动对象\n劳动对象是现实生产的必要前提\n\n\n劳动者\n\n能够运用劳动资料作用于劳动对象，从事生产实践活动的人\n劳动者是生产力中最活跃的因素\n\n\n\n\n科学技术是生产力的重要因素\n\n科学技术能够应用于生产过程，与生产力中的其他因素相结合而转化为实际生产能力\n\n科学技术上的发明创造，会引起劳动资料、劳动对象和劳动者素质的深刻变革和巨大进步\n科学技术应用于生产的组织管理，能够大幅提升管理效率\n科学技术为劳动者所掌握，可以极大提高劳动生产率\n\n\n科学技术是先进生产力的集中体现和主要标志，是第一生产力\n\n\n\n\n生产关系\n\n是人们在物质生产过程中形成的不以人的意志为转移的经济关系\n生产关系的要素\n\n生产资料所有制关系\n\n是最基本的，是人们进行物质资料生产的前提\n是区分不同生产方式、判断社会经济结构性质的客观依据\n划分类型\n\n生产资料公有制\n生产资料私有制\n\n\n\n\n生产中人与人的关系\n产品分配关系\n\n\n\n\n生产力与生产关系的关系\n\n生产力决定生产关系\n\n生产力的状况决定生产关系的性质\n\n生产力状况是生产关系形成的客观前提和物质基础\n\n\n生产力的发展决定生产关系的变化\n\n生产关系是生产力发展需要的产物，只有当它为生产力提供足够的发展空间才能存在\n\n\n\n\n生产关系对生产力具有能动的反作用\n\n当生产关系适合生产力发展的客观要求时，生产关系对生产力的发展起推动作用\n当生产关系不适合生产力发展的客观要求时，生产关系对生产力的发展就会产生阻碍作用\n\n\n生产关系一定要适合生产力状况的规律是社会形态发展的普遍规律\n\n\n\n\n经济基础和上层建筑的矛盾运动及其规律\n\n经济基础\n\n是由社会一定发展阶段的生产力所决定的生产关系的总和\n\n\n上层建筑\n\n是建立在一定经济基础之上的意识形态以及与之相适应的制度、组织和设施\n由意识形态、政治法律制度及设施和政治组织两部分组成\n\n意识形态（观念上层建筑）\n政治法律制度及设施和政治组织（政治上层建筑）\n\n\n\n\n经济基础与上层建筑的关系\n\n经济基础决定上层建筑\n上层建筑反作用于经济基础\n\n\n\n\n\n 社会历史发展的动力\n\n\n\n\n\n\n\n\n\n【科学技术在社会发展中的作用（重大问题）】\n 科学技术在社会发展中的作用\n\n科技革命是推动经济和社会发展的强大杠杆\n\n对生产方式的影响\n\n改变社会生产力的构成要素\n改变人们的劳动形式\n改变社会经济结构，特别是导致产业结构发生变革\n\n\n对生活方式的影响\n\n现代化信息技术为学习、工作带来便利\n现代化交通为交往带来方便\n劳动生产率的提高，为人的全面发展创造更多条件\n\n\n对思维方式的变革\n\n能运用新的理论工具和现代化技术研究新现象、新领域\n\n\n\n\n正确把握科学技术的社会作用\n\n科学技术的发展标志着人类改造自然能力的增强，意味着人们能够创造更多的物质财富，对社会发展具有巨大的推动作用\n科学技术的消极后果\n\n自然环境问题\n社会制度问题\n\n\n正确认识和运用科学技术，首要就是有合理的社会制度保障科学技术的合理运用，始终坚持使科学技术为人类社会的健康发展服务\n\n\n\n\n\n\n\n\n\n\n\n\n【文化在社会发展中的作用（23版才有，重大问题）】\n 文化在社会发展中的作用\n\n文化为社会发展提供思想指引\n\n先进文化为社会发展指明变革方向，促进生产力发展和社会进步\n\n\n文化为社会发展提供精神动力\n\n一个民族的复兴需要强大的物质力量，也需要强大的精神力量\n\n\n文化为社会发展提供凝聚力量\n\n文化是一个民族的精神家园，是民族凝聚力量的重要纽带\n\n\n\n 人民群众在历史发展中的作用\n\n略\n\n 资本主义的本质及规律\n 商品经济和价值规律\n 商品经济的形成和发展\n\n商品经济产生的历史条件\n\n商品经济是以交换为目的而进行生产的经济形式，是一定社会条件下的产物\n产生的历史条件\n\n存在社会分工\n生产资料和劳动产品属于不同的所有者\n\n\n\n\n商品的二因素和生产商品的劳动的二重性\n\n商品的二因素\n\n使用价值\n\n指商品能够满足人们某种需要的有用性，反映的是人与自然的物质关系，是商品的自然属性，是一切劳动产品所共有的属性，离开它商品就不复存在\n使用价值构成社会财富的物质内容\n\n\n价值\n\n是凝结在商品中的无差别的一般人类劳动，是商品所特有的社会属性\n\n\n交换价值\n\n使用价值是交换价值的表现形式\n价值是交换价值的基础\n\n\n价值和使用价值的对立统一关系\n\n对立性\n\n商品的价值与使用价值是互斥的，二者不可兼得\n\n\n统一性\n\n作为商品，必须同时兼有使用价值和价值两个因素\n\n\n\n\n\n\n生产商品的劳动的二重性\n\n具体劳动\n\n指生产一定价值的具体形式劳动\n创造商品的使用价值\n反映人与自然的关系，是劳动的自然属性\n\n\n抽象劳动\n\n指撇开一切具体形式的、无差别的一般人类劳动\n形成商品的价值\n反映商品生产者的社会关系，是劳动的社会属性\n\n\n具体劳动和抽象劳动的对立统一关系\n\n\n\n\n商品价值量的决定\n\n商品价值量的决定因素是商品生产中所耗费的社会必要劳动时间\n\n社会必要劳动时间是在现有的社会正常的生产条件下，以社会平均的劳动熟练度和劳动强度制造某种使用价值所需要的劳动时间\n\n\n\n\n价值形式的发展与货币的产生\n\n\n\n\n\n\n\n\n\n\n【价值规律及其作用（重大问题）】\n 价值规律及其作用\n\n价值规律\n\n主要内容和客观要求\n\n商品的价值量由生产商品的社会必要劳动时间决定\n商品交换以价值量为基础，按照等价交换的原则进行\n\n\n表现形式\n\n商品的价格围绕商品的价值转发波动\n\n\n\n\n价值规律在市场配置资源过程中的作用\n\n自发调节生产资料和劳动力在社会各生产部门之间的分配比例\n自发刺激社会生产力的发展\n自发调节社会收入的分配\n自发调节的消极后果\n\n导致社会资源浪费\n阻碍技术进步\n导致收入两极分化\n\n\n\n\n\n 资本主义经济制度\n\n略\n\n 资本主义上层建筑\n\n略\n\n 资本主义的发展及其趋势\n 垄断资本主义的形成与发展\n 资本主义从自由竞争到垄断\n\n略\n\n 垄断资本主义的发展\n\n\n\n\n\n\n\n\n\n私人垄断主义/20世纪初——国家垄断主义/二战后\n\n国家垄断资本主义的形成及作用\n金融垄断资本主义的发展\n垄断资本向世界范围的扩展\n垄断资本主义的实质\n\n垄断组织在经济生活中起决定作用\n在金融资本的基础上形成金融寡头的统治\n资本输出有了特别重要的意义\n瓜分世界的资本家国际垄断同盟已经形成\n最大资本主义大国已把世界上的领土瓜分完毕\n\n\n\n 经济全球化及其影响\n\n略\n\n 正确认识当代资本主义的新变化\n\n\n\n\n\n\n\n\n\n【新时代资本主义的新变化（重大问题）】\n【变化的原因和实质（重大问题）】\n 第二次世界大战后资本主义的变化及其实质\n\n变化的主要表现\n\n生产资料所有制的变化\n劳资关系和分配关系的变化\n社会阶层和阶级结构的变化\n经济调节机制和经济危机形态的变化\n政治制度的变化\n\n\n变化的原因和实质\n\n原因\n\n科学技术革命和生产力的发展，是资本主义变化的根本推动力量\n工人阶级争取自身权利和利益的斗争，是资本主义变化的重要推动力量\n社会主义制度初步显示的优越性对资本主义产生重要影响\n主张改良主义的政党对资本主义制度的改革，也对资本主义产生了一定影响\n\n\n实质\n\n是人类社会发展一般规律和资本主义经济规律的结果\n是在资本主义制度基本框架内的变化，并不意味着资本主义生产关系的根本性质发生变化\n\n\n\n\n\n 资本主义的历史地位和发展趋势\n\n\n\n\n\n\n\n\n\n【资本主义被社会主义所替代的历史必然性（重大问题）】\n 资本主义为社会主义替代的历史必然性\n\n资本主义基本矛盾包含着现代的一切冲突的萌芽\n资本积累推动资本主义基本矛盾不断激化并最终否定资本主义自身\n国家垄断资本主义是资本社会化的更高形式，将成为社会主义的前奏\n资本主义社会存在着资产阶级和无产阶级两大阶级之间的矛盾和斗争\n5：【资本主义的发展规律（重大问题）?】\n\n 社会主义的发展及规律\n 社会主义五百年的历史进程\n 社会主义从空想到科学\n\n空想社会主义\n\n早期\n\n托马斯·莫尔《乌托邦》——开山之作\n康帕内拉《太阳城》\n摩莱里《自然新编》\n马布利《论法制或法律原则》\n\n\n最高阶段\n\n法国/圣西门：实业制度\n法国/傅立叶：和谐社会\n英国/欧文：共产主义实验\n\n\n\n\n\n 科学社会主义基本原则\n\n略\n\n 在实践中探索社会主义的发展规律\n\n\n\n\n\n\n\n\n\n【社会主义建设过程的长期性（重大问题）】\n 社会主义建设过程的长期性\n\n生产力发展状况的制约\n经济基础和上层建筑发展状况的制约\n国际环境的严峻挑战\n马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程\n\n\n\n\n\n\n\n\n\n\n【社会主义发展道路的多样性（重大问题）】\n 社会主义发展道路的多样性\n\n原因\n\n各个国家的生产力发展状况和社会发展阶段决定了社会主义发展道路具有不同特点\n历史文化传统的差异性是造成不同国家社会主义发展道路多样性的重要条件\n时代和实践的不断发展，是造成社会主义发展道路多样性的现实原因\n\n\n探索适合本国国情的发展道路\n\n必须坚持对待马克思主义的科学态度\n必须从当时当地的历史条件出发，坚持走自己的路\n必须充分吸收人类一切优秀文明成果\n\n\n\n 共产主义崇高理想及其最终实现\n 展望未来共产主义新社会\n 共产主义社会的基本特征\n\n物质财富极大丰富，消费资料按需分配\n社会关系高度和谐，人们精神境界极大提高\n实现每个人自由而全面的发展，人类从必然王国向自由王国飞跃\n\n 实现共产主义是历史发展的必然趋势\n\n略\n\n 共产主义远大理想与中国特色社会主义共同理想\n\n略\n\n","slug":"8-马克思主义复习","date":"2023-06-23T11:51:16.000Z","categories_index":"","tags_index":"","author_index":"Kevin"},{"id":"1213bb1667a1a27ac14ed9acb5d31b07","title":"编译原理复习","content":"\n\n\n\n\n\n\n\n\n复习要点提纲\n\n第二章(文法构造、句型的最左推导、句型的语法树、短语、直接短语、句柄)\n第三章 (词法分析、8个算法)(必考：子集法)\n第四章(LL(1)文法、FIRST集、FOLLOW集、SELECT集、LL(1)文法的判定、LL(1)文法的构造、LL(1)分析表的构造)\n第六章(LR(0)项、LR(0)项目集规范族、LR(0)分析表的构造、SLR(1)分析表的构造、LR(1)分析表的构造、LALR(1)分析表的构造)\n第七章(给定源代码翻译出目标代码的过程)\n第八章(符号表)\n第九章(划分基本块、寻找回边和循环)\n(给定文法，填写完整的PL0代码)\n\n 文法和语言\n 符号和符号串\n\n字母表记作：Σ、V\n符号串S的长度记作：|S|\n\n空串ε的长度为0\n\n\n符号运算\n\n连接（乘积）：符号串x连接符号串y记作符号串xy\n幂运算：符号串连接自身n次得到的符号串记作x^n\n闭包：符号串x的闭包记作x^* = x^0 ∪ x^1 ∪ x^2 ∪…（包含空串x^0）\n正闭包：符号串x的正闭包记作x^+ = x^1 ∪ x^2 ∪ x^3 ∪…（不包含空串）\n\n\n\n 例题\n\n\n\n\n 文法和语言的形式定义\n\n文法G = (VN, VT, P, S)\n\nVN：非终结符集合——大写字母\nVT：终结符集合——小写字母\nP：产生式集合/规则集合\nS：开始符号\n\n\n文法的写法\n\n使用单箭头\n大写字母-非终结符\n小写字母-终结符\nε-空串\n第一条产生式/规则的非终结符为开始符号S\n示例\n\n\n\n\n\n\n直接推导\n\n定义：若存在符号串α、β、γ，使得αAβ推导出αγβ，则称A→γ是一步推导（直接推导）\n\n\n\n\n\n 文法和语言的形式定义\n\n句型：根据文法G，从开始符号S推导出的符号串称为文法G的句型（可理解为产生式的右部，经过0~多次推导后的右部）\n句子：全为终结符的句型称为文法G的句子\n语言：文法G的所有句子的集合称为文法G的语言，记作L(G)\n\n 例题\n\n\n\n 文法的类型\n\n0型文法（短语结构文法）\n\n任意产生式都可以是形如α→β的形式，其中α∈(VN+VT)*，β∈(VN+VT)*\n左部：至少有一个非终结符VN\n右部：可以是任意符号串\n\n\n1型文法（上下文有关文法）\n\n任意产生式都可以是形如αAβ→αγβ的形式，其中A∈VN，γ∈(VN+VT)+，α、β∈(VN+VT)*\n\n即对非终结符进行替换时一般不允许替换成ε\n\n\n除（S→ε）以外，任意产生式的右部长度&gt;=左部的长度\n\n\n2型文法（上下文无关文法）\n\n任意产生式都可以是形如A→γ的形式，其中A∈VN，γ∈(VN+VT)*\n产生式的左部只能是一个非终结符\n\n\n3型文法（正规文法）\n\n任意产生式都可以是形如A→aB或A→a的形式，其中A、B∈VN，a∈VT，即产生式的右部只能是一个终结符或一个终结符后跟一个非终结符\n产生式的左部只能是一个非终结符\n产生式的右部只能是一个终结符或一个终结符后跟一个非终结符\n\n\n\n 例题（根据生成的语言反推文法）\n\n\n\n\n\n\n 语法树\n\n语法树\n\n定义：给定文法G，从开始符号S推导出符号串w的过程中，每一步推导都可以用一棵树来表示，这棵树称为语法树\n语法树的构造\n\n根节点：开始符号S\n叶节点：终结符或空串ε\n中间节点：非终结符\n\n\n\n\n最左/最右推导\n\n定义：在推导过程中，每一步都选择最左/最右的非终结符进行替换\n最左/最右推导的语法树\n\n最左推导：语法树的叶节点从左到右与推导过程中的符号串相同\n最右推导：语法树的叶节点从右到左与推导过程中的符号串相同\n\n\n最左/最右推导的语法树是唯一的\n最右推导的语法树称为规范推导树\n\n由规范推导所得到的句型称为规范句型\n\n\n示例\n\n\n\n\n\n\n二义性\n\n定义：若一个文法G存在两棵不同的语法树，都可以推导出同一个句子w，则称文法G是二义性的\n二义性的判定\n\n从左到右扫描句子w，若在某一步推导中，有两个或两个以上的非终结符可以进行替换，则文法G是二义性的\n\n\n\n\n\n 句型的分析\n\n\n\n\n\n\n\n\n\n句型可以由不同方式构成对应的语法树，一般采用最右推导的方式构造语法树，这种方式可以得到句柄\n\n短语：在一个句型中，若一个子串是某个非终结符的右部，则称这个子串为短语（包含非终结符的子串必须可以推导出全是终结符的句子）\n直接短语：若一个短语中不包含其他短语，则称这个短语为直接短语（理解为只有一步/直接推导）\n句柄：在一个句型中，若一个子串是某个非终结符的右部，且这个非终结符是最右推导中最左的非终结符，则称这个子串为句柄（理解为最右推导的最左符号串）\n示例\n\n最右推导：\n\n必须先选E+T替换E =&gt; E + T\n再选F替换T =&gt; E + F\n再选i替换F =&gt; E + i\n再选T替换E =&gt; T + i\n再选T*F替换T =&gt; T * F + i\n再选i替换F =&gt; T * i + i\n再选F替换T =&gt; F * i + i\n最后选i替换F =&gt; i * i + i\n\n\n\n\n\n\n 练习\n\n\n\n 词法分析\n 正规式和正规文法\n\n正规式\n\n定义：正规式是由正规运算符和正规符号构成的表达式\n正规式的运算符\n\n选择运算符：|，表示或\n连接运算符：，，表示连接\n闭包运算符：*，表示闭包\n\n\n正规符号\n\n终结符\n空串ε\n\n\n正规式的值\n\n正规式的值是一个正规集\n正规集是一个由正规符号构成的集合\n\n\n\n\n理解\n\n正规式是正规文法的一种简化表示\n\n正规式表示为符号串\n正规文法表示为产生式\n\n\n\n字母表的每个字母（终结符）都属于一个最简单的正规式\n正规式通过正规运算符可得到新的正规式\n\nL(正规式)=该正规式表示的正规集\n\nL(字母表)=该字母表所表示的所有句子集合\n\n\nL(正规式1 运算符 正规式2)=L(正规式1) 运算符 L(正规式2)\n\n\n\n可以用一个正规式描述3型文法的语言\n\n\n\n\n\n\n例题\n\n\n\n\n\n\n\n 有穷自动机\n\n定义：作为一种识别装置，它能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合\n分类\n\n确定的有穷自动机DFA\n不确定的有穷自动机NFA\n\n\n\n 确定的有穷自动机DFA\n\n定义：确定的有穷自动机是一个五元组M=(K,Σ,f,S,Z)，其中\n\nK是有穷状态集\nΣ是输入符号表\nf是状态转换函数，即f:K×Σ→K\nS是初始状态\nZ是终止状态集\n\n\nDFA的表示\n\n若DFA含有m个状态、n个输入符号，那么该状态图含有m个节点，每个节点最多有n条弧射出，每条弧上标有一个输入符号\n整个图含有唯一的一个初始状态，若干个终止状态\n\n初态结点冠以双箭头“=&gt;”或标以“-”\n终态结点冠以双圆圈“○”或标以“+”\n\n\n\n\n\n\nDFA的识别过程\n\n从初始状态开始，根据输入符号，沿着状态转换函数f的指示，依次进入下一个状态，直到输入符号串结束\n若最后所处的状态是终止状态，则认为该输入符号\n\n\n\n\n\n 不确定的有穷自动机NFA\n\n\n\n\n\n\n\n\n\n\n不确定主要是指后继状态可有多个。\nDFA是NFA的特例，即NFA是DFA的扩展\n\n\n定义：不确定的有穷自动机是一个五元组M=(S,Σ,f,S0,Z)，其中\n\nS是有穷状态集\nΣ是输入符号表\nf是状态转换函数，即f:S×Σ→2S(S的幂集)\nS0是初始状态集\nZ是终止状态集\n\n\nNFA的表示\n\n若NFA含有m个状态、n个输入符号，那么该状态图含有m个节点，每个节点最多有n条弧射出，每条弧上标有一个输入符号\n整个图含有若干个初始状态，若干个终止状态\n\n初态结点冠以双箭头“=&gt;”或标以“-”\n终态结点冠以双圆圈“○”或标以“+”\n\n\n\n\n\n\n NFA的确定化（NFA转化为DFA）\n\n状态集合的运算\n\n状态集合I的ε-闭包，记作ε-closure(I)，即从状态集合中的任何一个状态出发，经过任意多个ε弧可达的状态集合\n状态集合I的a弧转换，记作move(I,a)=J，即从状态集合I中的任何一个状态出发，经过1个a弧可达的状态集合J\n\n\n子集法\n\n画出NFA的状态矩阵，每个状态矩阵的行表示一个状态集合，每个状态矩阵的列表示一个输入符号\n将状态矩阵的初始状态0，求出其ε-闭包后，作为DFA的初始状态T0\n（第一行）DFA由初始状态T0开始，求出其a弧和其他弧转换后的状态集合的ε-闭包\n（第二行）查找上面未被推导的新状态作为下一行的初始状态，求出其a弧和其他弧转换后的状态集合的ε-闭包\n重复上述过程，直到所有状态集合都被推导出来\n重新命名状态集合，使其成为DFA的状态\n示例\n\n\n\n\n\n\n例题\n\n初始状态T0:{S,3,1}\n\nε-closure(S)={S,3,1}\n\n\n第一行\n\n{S,3,1}\nmove(T0,a)={3,5}\n\nε-closure(3,5)={3,1,5}\n\n\nmove(T0,b)={3,6}\n\nε-closure(3,6)={3,1,6}\n\n\n\n\n第二行\n\n{3,1,5}\nmove({3,1,5},a)={3,5,2}\n\nε-closure(3,5,2)={3,1,5,2,4,Z}\n\n\nmove({3,1,5},b)={3,6}\n\nε-closure(3,6)={3,1,6}\n\n\n\n\n第三行\n\n{3,1,6}\nmove({3,1,6},a)={3,5}\n\nε-closure(3,5)={3,1,5}\n\n\nmove({3,1,6},b)={3,6,2}\n\nε-closure(3,6,2)={3,1,6,2,4,Z}\n\n\n\n\n省略\n\n DFA的最小化（DFA的化简）\n\n分割法\n\n定义：把一个DFA的状态分成一些不相交的子集，使得任何不同的两子集的状态都是可区别的，而同一子集中的任何两个状态都是等价的\n将DFA的状态集按照终态和非终态分成两个子集，记作P0={F,Q-F}，其中F是终态集，Q-F是非终态集\n重复下面的过程，直到不能再分割为止\n\n对于Pi中的每个子集，对于每个输入符号a，求出其a弧转换后的状态集合，将Pi中的每个子集按照a弧转换后的状态集合分割成若干个子集，记作Pi+1\n若Pi与Pi+1相等，则停止分割\n\n\n划分到最后，得到的子集就是最小化的DFA的状态集\n对每个子集，取一个代表状态，作为最小化DFA的状态；若该子集中含有终态，则该代表状态为终态；若该子集中含有初态，则该代表状态为初态\n\n\n示例\n- \n- \n- \n- \n- \n\n 有穷自动机和正规式的等价性\n 有穷自动机转化为正规式\n\n替换规则\n\n\n\n\n示例\n\nNFA转化为正规式\n\n添加新的初态和终态（原初态指向新的初态，原终态指向新的终态）\n\n\n\n\n根据替换规则逐步转化为正规式\n\n\n\n\n\n\n\nDFA转化为正规式\n\n添加新的初态和终态（原初态指向新的初态，原终态指向新的终态）\n\n\n\n\n根据替换规则逐步转化为正规式\n\n\n\n\n\n\n\n\n\n 正规式转化为有穷自动机\n\n分裂规则\n\n\n\n\n示例\n\n由正规式a 构造一个如下仅有两个结点x,y的状态图，再按所引入的3条正规式分裂规则分裂a\n\n\n\n\n将所得的NFA M(因为包含ε弧)进行确定化就得到DFA\n\n\n\n\n\n\n\n\n 有穷自动机和正规文法的等价性\n 正规文法转化为有穷自动机\n\n\n\n\n\n\n\n\n\n正规文法分为右线性文法和左线性文法。但对一个正规文法，不能既是左线性，又是右线性。\n\n构造方法\n\n有穷自动机M的字母表与正规文法G的终结符相同。\n为G中的每一个非终结符生成M的一个状态，G的开始符S表示开始状态S\n增加一个新状态Z，作为NFA的终态\n对正规文法G中的形如A→tB的规则构造有穷自动机M的一个转换函数f(A,t)=B。\n对正规文法G中形如A→t的产生式，构造一个转换函数f(A,t)=Z。\n\n\n示例\n\n\n\n\n\n 有穷自动机转化为正规文法\n\n构造方法\n\n对转换函数f(A,t)=B,可写产生式： A → tB\n对终态增加产生式： Z → ε\n\n\n示例\n\n\n\n\n\n 练习\n\n正规式转化为DFA\n\n\n\n\nDFA最小化\n\n\n\n\n\n正规文法转化为DFA\n\n\n\n\n\nDFA转化为正规文法\n\n\n\n\nNFA最小化\n\n\n\n\n\n 语法分析\n\nFirst集：一个文法符号串的首符号的集合\n\nFirst(X) = {a|X =&gt;* aβ, a∈Vt, β∈V*}\n若X∈VT（终结符）,则FIRST(X)={X}\n若X属于VN（非终结符）,且有产生式X→a…，则把a加入到FIRST(X)中;若X→ε是一条产生式,则把ε也加到FIRST(X)中.\n\nFirst(A)判断方法\n\n找到所有左部为A的产生式\n\n若右部第一个符号为终结符,则把该符号加入到FIRST(A)中\n若右部第一个符号为ε,则把ε加入到FIRST(A)中\n若右部第一个符号的FIRST集合不包含ε,则把该非终结符的FIRST集合加入到FIRST(A)中\n若右部第一个符号的FIRST集合包含ε,则把右部第二个符号的FIRST集合加入到FIRST(A)中,以此类推,直到右部第一个符号的FIRST集合不包含ε,则停止，若一直到最后一个符号的FIRST集合都包含ε,则把ε加入到FIRST(A)中\n\n\n\n\n示例\n\n\n\n\n\n\nFollow集：一个文法符号串的后继符号的集合\n\nFollow(A) = {a|S=&gt;αAaβ, a∈Vt, α,β∈V}\n若A是文法的开始符号S,则把#加入到FOLLOW(S)中.\n若有产生式A→αBβ,则把FIRST(β)-{ε}加入到FOLLOW(B)中.\n若有产生式A→αB,或者A→αBβ且ε∈FIRST(β),则把FOLLOW(A)加入到FOLLOW(B)中.\nFollow(A)判断方法\n\n找到右部有A的产生式\n\n若A右边第一个为终结符号，则将其加入到Follow(A)中\n若A右边第一个为非终结符号，则将其First集中的非空元素加入到Follow(A)中\n\n若First集中有ε，则将Follow(产生式的左部)加入到Follow(A)中\n\n\n若A在右部最后，则将Follow(产生式的左部)加入到Follow(A)中\n\n\n若A为开始符号，则将#加入到Follow(A)中\nfollow集不包含ε\n\n\n示例\n\n\n\n\n\n\nSelect集：一个产生式的First集和Follow集的并集\n\nSelect(A→α)判断方法\n\n若α=&gt;*ε成立,则Select(A→α) = ( First(α) - {ε} )∪ Follow(A)\n若α=&gt;*ε不成立,则Select(A→α) = First(α)\n\n\n示例\n\n\n第四条右部为空，先求出First(ε)-{ε}=∅，再求出Follow(ε)=Follow(B)=\n\n\n\n\n\n","slug":"7-编译原理复习","date":"2023-06-23T11:48:38.000Z","categories_index":"","tags_index":"","author_index":"Kevin"},{"id":"1282d363af11675dd608d5f2af6828ad","title":"设计模式-3","content":" 设计模式-3\n 一、 行为型模式\n\n\n\n\n\n\n\n\n\n行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使代码更加地清晰。描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n\n模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n （一）策略模式\n 模式介绍\n\n模式动机：\n\n在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。\n在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。\n如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。\n\n\n模式定义：\n\n定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化\n策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。\n具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。\n环境（Context）类：持有一个策略类的引用，最终给客户端调用。\n\n\n模型评价：\n\n优点\n\n策略模式提供了对“开闭原则”的完美支持。\n策略模式提供了管理相关的算法族的办法。\n使用策略模式可以避免使用多重条件转移语句。\n\n\n缺点\n\n客户端必须知道所有的策略类，并自行决定使用哪一个策略类\n策略模式将造成产生很多策略类和对象，可以通过享元模式在一定程度上减少对象的数量。\n\n\n应用场景\n\n一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\n一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\n系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\n系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\n多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\n\n\n改进\n\n在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：\n&#x2F;&#x2F;(1) 学生凭学生证可享受票价8折优惠；\n&#x2F;&#x2F;(2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠；\n&#x2F;&#x2F;(3) 影院VIP用户除享受票价半价优惠外还可进行积分\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象策略类\npublic interface Discount&#123;\n\tpublic double calculate(double price);\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体策略类\n&#x2F;&#x2F;学生优惠\npublic class StudentDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;学生票：&quot;);\n\t\treturn price*0.8;\n\t&#125;\n&#125; \n\n\n&#x2F;&#x2F;儿童优惠\npublic class ChildDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;儿童票：&quot;);\n\t\treturn price-10;\n\t&#125;\n&#125; \n\n&#x2F;&#x2F;VIP优惠\npublic class VIPDiscount implements Discount&#123;\n    @Override\n    public double calculate(double price)&#123;\n\t\tSystem.out.println(&quot;VIP票：&quot;);\n\t\tSystem.out.println(&quot;增加积分！&quot;);\n\t\treturn price*0.5;\n\t&#125;\n&#125; \n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;环境类\npublic class MovieTicket &#123;\n\tprivate double price;\n\tprivate Discount discount;\n\tpublic void setPrice(double price)&#123;\n\t\tthis.price &#x3D; price;\n\t&#125;\n\tpublic void setDiscount(Discount d)&#123;\n\t\tthis.discount &#x3D; d;\n\t&#125;\n\tpublic double getPrice()&#123;\n\t\treturn discount.calculate(price);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;工具类XMLUtil\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\npublic class XMLUtil\n&#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取对应对象，并返回对象\n\tpublic static String getBean()\n\t&#123;\n\t\ttry\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;创建文档对象\n\t\t\tDocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc &#x3D; builder.parse(new File(&quot;config.xml&quot;)); \n\t\t\n\t\t\t&#x2F;&#x2F;获取包含类名的文本节点\n\t\t\tNodeList nl &#x3D; doc.getElementsByTagName(&quot;name&quot;);\n            Node classNode &#x3D; nl.item(0).getFirstChild();\n            String name &#x3D; classNode.getNodeValue().trim();\n            \n            return name;\n           &#125;   \n           \tcatch(Exception e)\n           \t&#123;\n           \t\te.printStackTrace();\n           \t\treturn null;\n           \t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n\t&lt;name&gt;VIPDiscount&lt;&#x2F;name&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tMovieTicket mt;\n\t\tDiscount discount;\n\t\tdiscount &#x3D; (Discount)XMLUtil.getBean();&#x2F;&#x2F;相当于获取特定的对象，如VIPDdiscount类\n\t\tmt &#x3D; new MovieTicket(discount);\n\t\tmt.setPrice(100);\n\t\tSystem.out.println(&quot;优惠后的价格：&quot;+mt.getPrice());\n\t&#125;\n&#125;\n\n （二）模板方法模式\n 模式介绍\n\n模式动机：\n\n在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\n这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等\n\n\n模式定义：\n\n定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n它是一种类行为型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象类/抽象模板（Abstract Class）：抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。\n\n模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n基本方法：是整个算法中的一个步骤，包含以下几种类型。\n\n抽象方法：在抽象类中声明，由具体子类实现。\n具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。\n钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\n\n\n\n\n具体子类/具体实现（Concrete Class）：具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。\n\n\n模型评价：\n\n优点\n\n它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。\n它在父类中提取了公共的部分代码，便于代码复用。\n部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。\n\n\n缺点\n\n对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。\n父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\n由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。\n\n\n应用场景\n\n算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\n当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。\n当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展\n\n\n改进\n\n在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;含钩子方法的抽象类\nabstract class HookAbstractClass &#123;\n    &#x2F;&#x2F;模板方法\n    public void TemplateMethod() &#123;\n        abstractMethod1();\n        HookMethod1();\n        if (HookMethod2()) &#123;\n            SpecificMethod();\n        &#125;\n        abstractMethod2();\n    &#125;\n    &#x2F;&#x2F;具体方法\n    public void SpecificMethod() &#123;\n        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);\n    &#125;\n    &#x2F;&#x2F;钩子方法1-需要子类重写的空方法\n    public void HookMethod1() &#123;\n    &#125;\n    &#x2F;&#x2F;钩子方法2-调用钩子方法控制某步骤是否执行\n    public boolean HookMethod2() &#123;\n        return true;\n    &#125;\n    &#x2F;&#x2F;抽象方法1\n    public abstract void abstractMethod1();\n    &#x2F;&#x2F;抽象方法2\n    public abstract void abstractMethod2();\n&#125;\n&#x2F;&#x2F;含钩子方法的具体子类\nclass HookConcreteClass extends HookAbstractClass &#123;\n    @Override\n    public void abstractMethod1() &#123;\n        System.out.println(&quot;抽象方法1的实现被调用...&quot;);\n    &#125;\n    @Override\n    public void abstractMethod2() &#123;\n        System.out.println(&quot;抽象方法2的实现被调用...&quot;);\n    &#125;\n    @Override\n    public void HookMethod1() &#123;\n        System.out.println(&quot;钩子方法1被重写...&quot;);\n    &#125;\n    @Override\n    public boolean HookMethod2() &#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class HookTemplateMethod &#123;\n    public static void main(String[] args) &#123;\n        HookAbstractClass tm &#x3D; new HookConcreteClass();\n        tm.TemplateMethod();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;运行结果：\n\n抽象方法1的实现被调用...\n钩子方法1被重写...\n抽象方法2的实现被调用...\n\n （三）备忘录模式\n 模式介绍\n\n模式动机：\n\n每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。\n其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。\n备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态\n\n\n模式定义：\n\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。\n该模式又叫快照模式。\n备忘录模式是一种对象行为型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。\n备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。\n管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。\n\n\n模型评价：\n\n优点\n\n提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。\n实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。\n简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。\n\n\n缺点\n\n资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。\n\n\n应用场景\n\n需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。\n需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。\n\n\n改进\n\n备忘录的封装性\n\n就是原发器可以访问备忘录类外其他不应该访问，所以在c++可以使用friend关键字，java可以将两个类放入一个包中，使他们之间可以满足默认的包可见性，也可以将备忘录类作为原发器的内部类。\n\n\n多备份的实现\n\n很多时候，负责人保存的状态不止一个的，所以对于备忘录类，可以设置一个集合容器存储多个历史状态。比如HashMap、ArrayList和栈\n\n\n备忘录模式可以有另一种实现方式\n\n将容器存储不单独成一个类，而是做一个容器放置在类属性，当我们需要存储历史状态时，我们可以通过克隆添加容器内,这样可能开发更为容易，但是有个问题就是克隆其实是整个对象整体克隆，就会占内存\n\n\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;备忘录\n&#x2F;&#x2F;这里是没有public的，采用默认的可见符，即包内可见\nclass Memento &#123;\n    private String account;\n    private String password;\n    private String telNo;\n\n    &#x2F;&#x2F;下面是三个属性构成的有参构造函数，getter、setter，这里不多展示\n&#125;\n&#x2F;&#x2F;发起人\npublic class UserInfoDTO &#123;\n    private String account;\n    private String password;\n    private String telNo;\n    \n    &#x2F;&#x2F;获取此时的快照，利用备忘录类作为载体返回\n    public Memento saveMemento()&#123;\n        return new Memento(account, password, telNo);\n    &#125;\n    \n    &#x2F;&#x2F;将历史记录快照进行恢复出来\n    public void restoreMemento(Memento memento)&#123;\n        this.account &#x3D; memento.getAccount();\n        this.password &#x3D; memento.getPassword();\n        this.telNo &#x3D; memento.getTelNo();\n    &#125;\n    \n    public void show()&#123;\n        System.out.println(&quot;Account:&quot; + this.account);\n        System.out.println(&quot;Password:&quot; + this.password);\n        System.out.println(&quot;TelNo:&quot; + this.telNo);\n    &#125;\n\n    &#x2F;&#x2F;下面是三个属性的setter、getter这里不多展示\n&#125;\n\n&#x2F;&#x2F;管理者\npublic class Caretaker &#123;\n    private Memento memento;&#x2F;&#x2F;容器存储历史状态\n    public Memento getMemento()&#123;\n        return memento;\n    &#125;\n    public void  setMemento(Memento memento)&#123;\n        this.memento &#x3D; memento;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserInfoDTO user &#x3D; new UserInfoDTO();\n        Caretaker c &#x3D; new Caretaker();\n        \n        user.setAccount(&quot;张三&quot;);\n        user.setPassword(&quot;123456&quot;);\n        user.setTelNo(&quot;13000000000&quot;);\n        System.out.println(&quot;状态一：&quot;);\n        user.show();\n        \n        c.setMemento(user.saveMemento());&#x2F;&#x2F;存储状态\n        System.out.println(&quot;-----------------------&quot;);\n        \n        user.setPassword(&quot;654321&quot;);\n        user.setTelNo(&quot;14000000000&quot;);\n        System.out.println(&quot;状态二：&quot;);\n        user.show();\n\n        System.out.println(&quot;-----------------------&quot;);\n        \n        user.restoreMemento(c.getMemento());&#x2F;&#x2F;恢复状态\n        System.out.println(&quot;回到状态一：&quot;);\n        user.show();\n    &#125;\n&#125;\n\n\n （四）观察者模式\n 模式介绍\n\n模式动机：\n\n在某些场景中，需要建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。\n\n\n模式定义：\n-定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。\n\n观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。\n具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。\n抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。\n具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。\n\n\n模型评价：\n\n优点\n\n观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。\n观察者模式在观察目标和观察者之间建立一个抽象的耦合，这样设计在增加观察者或被观察者的时候，都非常容易扩展，不修改原有代码只需要增加具体实现就可以进行扩展，符合“开闭原则”。\n建立一套触发机制，观察者模式可以更方便地实现具体业务中的复杂逻辑关系，形成逻辑链条。\n观察者模式支持广播通信。\n\n\n缺点\n\n如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。\n观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n\n\n应用场景\n\n对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。\n当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。\n实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。\n多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;抽象目标\nabstract class Subject &#123;\n    protected List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n    &#x2F;&#x2F;增加观察者方法\n    public void add(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n    &#x2F;&#x2F;删除观察者方法\n    public void remove(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n    public abstract void notifyObserver(); &#x2F;&#x2F;通知观察者方法\n&#125;\n&#x2F;&#x2F;具体目标\nclass ConcreteSubject extends Subject &#123;\n    public void notifyObserver() &#123;\n        System.out.println(&quot;具体目标发生改变...&quot;);\n        System.out.println(&quot;--------------&quot;);\n        for (Object obs : observers) &#123;\n            ((Observer) obs).response();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象观察者\ninterface Observer &#123;\n    void response(); &#x2F;&#x2F;反应\n&#125;\n&#x2F;&#x2F;具体观察者1\nclass ConcreteObserver1 implements Observer &#123;\n    public void response() &#123;\n        System.out.println(&quot;具体观察者1作出反应！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;具体观察者1\nclass ConcreteObserver2 implements Observer &#123;\n    public void response() &#123;\n        System.out.println(&quot;具体观察者2作出反应！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class ObserverPattern &#123;\n    public static void main(String[] args) &#123;\n        Subject subject &#x3D; new ConcreteSubject();\n        Observer obs1 &#x3D; new ConcreteObserver1();\n        Observer obs2 &#x3D; new ConcreteObserver2();\n        subject.add(obs1);\n        subject.add(obs2);\n        subject.notifyObserver();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体目标发生改变...\n--------------\n具体观察者1作出反应！\n具体观察者2作出反应！\n\n （五）迭代器模式\n 模式介绍\n\n模式动机：\n\n在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：暴露了聚合类的内部表示，使其数据不安全；增加了客户的负担。\n“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。\n迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。\n\n\n模式定义：\n\n提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n迭代器模式是一种对象行为型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。\n具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。\n抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。\n具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。\n\n\n模型评价：\n\n优点\n\n访问一个聚合对象的内容而无须暴露它的内部表示。\n遍历任务交由迭代器完成，这简化了聚合类。\n它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。\n增加新的聚合类和迭代器类都很方便，无须修改原有代码。\n封装性良好，为遍历不同的聚合结构提供一个统一的接口。\n\n\n缺点\n\n增加了类的个数，这在一定程度上增加了系统的复杂性。\n\n\n应用场景\n\n当需要为聚合对象提供多种遍历方式时。\n当需要为遍历不同的聚合结构提供一个统一的接口时。\n当访问一个聚合对象的内容而无须暴露其内部细节的表示时。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;抽象聚合\ninterface Aggregate &#123;\n    public void add(Object obj);\n    public void remove(Object obj);\n    public Iterator getIterator();\n&#125;\n&#x2F;&#x2F;具体聚合\nclass ConcreteAggregate implements Aggregate &#123;\n    private List&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();\n    public void add(Object obj) &#123;\n        list.add(obj);\n    &#125;\n    public void remove(Object obj) &#123;\n        list.remove(obj);\n    &#125;\n    public Iterator getIterator() &#123;\n        return (new ConcreteIterator(list));\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象迭代器\ninterface Iterator &#123;\n    Object first();\n    Object next();\n    boolean hasNext();\n&#125;\n&#x2F;&#x2F;具体迭代器\nclass ConcreteIterator implements Iterator &#123;\n    private List&lt;Object&gt; list &#x3D; null;\n    private int index &#x3D; -1;\n    public ConcreteIterator(List&lt;Object&gt; list) &#123;\n        this.list &#x3D; list;\n    &#125;\n    public boolean hasNext() &#123;\n        if (index &lt; list.size() - 1) &#123;\n            return true;\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n    public Object first() &#123;\n        index &#x3D; 0;\n        Object obj &#x3D; list.get(index);\n        ;\n        return obj;\n    &#125;\n    public Object next() &#123;\n        Object obj &#x3D; null;\n        if (this.hasNext()) &#123;\n            obj &#x3D; list.get(++index);\n        &#125;\n        return obj;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class IteratorPattern &#123;\n    public static void main(String[] args) &#123;\n        Aggregate ag &#x3D; new ConcreteAggregate();\n        ag.add(&quot;中山大学&quot;);\n        ag.add(&quot;华南理工&quot;);\n        ag.add(&quot;清华大学&quot;);\n        System.out.print(&quot;聚合的内容有：&quot;);\n        Iterator it &#x3D; ag.getIterator();\n        while (it.hasNext()) &#123;\n            Object ob &#x3D; it.next();\n            System.out.print(ob.toString() + &quot;\\t&quot;);\n        &#125;\n        Object ob &#x3D; it.first();\n        System.out.println(&quot;\\nFirst：&quot; + ob.toString());\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n聚合的内容有：中山大学\t华南理工\t清华大学\nFirst：中山大学\n\n （六）命令模式\n 模式介绍\n\n模式动机：\n\n在软件开发系统中，“方法的请求者”与“方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与实现者解耦？”变得很重要，命令模式就能很好地解决这个问题。\n在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。\n再比如，我们去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现。\n\n\n模式定义：\n\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。\n命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。\n具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。\n实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。\n调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。\n\n\n模型评价：\n\n优点\n\n通过引入中间件（抽象接口）降低系统的耦合度。\n扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。\n可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。\n可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。\n\n\n缺点\n\n可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。\n命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难\n\n\n应用场景\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。\n&#x2F;&#x2F;设计是将命令进行单独的封装，遥控器去使用命令，命令去操控电视，做到这些关系的分离与关联即可。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 实现者&#x2F;接收者（Receiver）\npublic class TV\n&#123;\n\tpublic void open()&#123;\n\t\tSystem.out.println(&quot;打开电视机！&quot;);\n\t&#125;\n\tpublic void close()&#123;\n\t\tSystem.out.println(&quot;关闭电视机！&quot;);\n\t&#125;\n\tpublic void changeChannel()&#123;\n\t\tSystem.out.println(&quot;切换电视频道！&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象命令类（Command）\npublic interface AbstractCommand&#123;\n\tpublic void execute();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体命令类（Concrete Command）\n&#x2F;&#x2F;打开电视机命令\npublic class TVOpenCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVOpenCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.open();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;关闭电视机命令\npublic class TVCloseCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVCloseCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.close();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;切换电视机频道命令\npublic class TVChangeCommand implements AbstractCommand&#123;\n\tprivate TV tv;\n\tpublic TVChangeCommand()&#123;\n\t\ttv &#x3D; new TV();\t\n\t&#125;\n\tpublic void execute()&#123;\n\t\ttv.changeChannel();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;调用者&#x2F;请求者（Invoker）-遥控器类\npublic class Controller\n&#123;\n\tprivate AbstractCommand openCommand,closeCommand,changeCommand;\n\tpublic Controller(AbstractCommand openCommand,\n\t\tAbstractCommand closeCommand,\n\t\tAbstractCommand changeCommand)&#123;\n\t\t\n\t\tthis.openCommand &#x3D; openCommand;\n\t\tthis.closeCommand &#x3D; closeCommand;\n\t\tthis.changeCommand &#x3D; changeCommand;\n\t&#125;\n\t\n\tpublic void open()&#123;\n\t\topenCommand.execute();\n\t&#125;\n\tpublic void close()&#123;\n\t\tcloseCommand.execute();\n\t&#125;\n\tpublic void changeChannel()&#123;\n\t\tchangeCommand.execute();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n\t\tAbstractCommand openCommand,closeCommand,changeCommand;\n\t\t\n\t\topenCommand &#x3D; new TVOpenCommand();\n\t\tcloseCommand &#x3D; new TVCloseCommand();\n\t\tchangeCommand &#x3D; new TVChangeCommand();\n\t\t&#x2F;&#x2F;定制遥控器\n\t\tController control &#x3D; new Controller(openCommand,closeCommand,changeCommand);\n\n\t\tcontrol.open();\n\t\tcontrol.change();\n\t\tcontrol.close();\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果：\n打开电视机！\n切换电视频道！\n关闭电视机！\n\n （七）状态模式\n 模式介绍\n\n模式动机：\n模式定义：\n\n允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。\n抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。\n具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。\n模型评价：\n\n优点\n\n结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。\n将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。\n状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。\n\n\n缺点\n\n状态模式的使用必然会增加系统的类与对象的个数。\n状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。\n状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码\n\n\n应用场景\n\n对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。\n代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;环境类\nclass Context &#123;\n    private State state;\n    &#x2F;&#x2F;定义环境类的初始状态\n    public Context() &#123;\n        this.state &#x3D; new ConcreteStateA();\n    &#125;\n    &#x2F;&#x2F;设置新状态\n    public void setState(State state) &#123;\n        this.state &#x3D; state;\n    &#125;\n    &#x2F;&#x2F;读取状态\n    public State getState() &#123;\n        return (state);\n    &#125;\n    &#x2F;&#x2F;对请求做处理\n    public void Handle() &#123;\n        state.Handle(this);\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象状态类\nabstract class State &#123;\n    public abstract void Handle(Context context);\n&#125;\n&#x2F;&#x2F;具体状态A类\nclass ConcreteStateA extends State &#123;\n    public void Handle(Context context) &#123;\n        System.out.println(&quot;当前状态是 A.&quot;);\n        context.setState(new ConcreteStateB());\n    &#125;\n&#125;\n&#x2F;&#x2F;具体状态B类\nclass ConcreteStateB extends State &#123;\n    public void Handle(Context context) &#123;\n        System.out.println(&quot;当前状态是 B.&quot;);\n        context.setState(new ConcreteStateA());\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class StatePatternClient &#123;\n    public static void main(String[] args) &#123;\n        Context context &#x3D; new Context();    &#x2F;&#x2F;创建环境      \n        context.Handle();    &#x2F;&#x2F;处理请求\n        context.Handle();\n        context.Handle();\n        context.Handle();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果：\n当前状态是 A.\n当前状态是 B.\n当前状态是 A.\n当前状态是 B.\n\n （八）职责链模式\n 模式介绍\n\n模式动机：\n\n在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。\n在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些，都可以考虑使用责任链模式来实现。\n\n\n模式定义：\n\n避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，属于对象行为模式。\n在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。\n\n\n模式结构：\n\n\n\n\n\n角色分析：\n\n抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程\n\n\n模型评价：\n\n优点\n\n降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。\n增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。\n增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。\n责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else语句。\n责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\n\n\n缺点\n\n不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。\n对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。\n职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用\n\n\n应用场景\n\n多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。\n可动态指定一组对象处理请求，或添加新的处理者。\n需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;抽象处理者角色\nabstract class Handler &#123;\n    private Handler next;\n    public void setNext(Handler next) &#123;\n        this.next &#x3D; next;\n    &#125;\n    public Handler getNext() &#123;\n        return next;\n    &#125;\n    &#x2F;&#x2F;处理请求的方法\n    public abstract void handleRequest(String request);\n&#125;\n&#x2F;&#x2F;具体处理者角色1\nclass ConcreteHandler1 extends Handler &#123;\n    public void handleRequest(String request) &#123;\n        if (request.equals(&quot;one&quot;)) &#123;\n            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);\n        &#125; else &#123;\n            if (getNext() !&#x3D; null) &#123;\n                getNext().handleRequest(request);\n            &#125; else &#123;\n                System.out.println(&quot;没有人处理该请求！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;具体处理者角色2\nclass ConcreteHandler2 extends Handler &#123;\n    public void handleRequest(String request) &#123;\n        if (request.equals(&quot;two&quot;)) &#123;\n            System.out.println(&quot;具体处理者2负责处理该请求！&quot;);\n        &#125; else &#123;\n            if (getNext() !&#x3D; null) &#123;\n                getNext().handleRequest(request);\n            &#125; else &#123;\n                System.out.println(&quot;没有人处理该请求！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class ChainOfResponsibilityPattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;组装责任链\n        Handler handler1 &#x3D; new ConcreteHandler1();\n        Handler handler2 &#x3D; new ConcreteHandler2();\n        handler1.setNext(handler2);\n        &#x2F;&#x2F;提交请求\n        handler1.handleRequest(&quot;two&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体处理者2负责处理该请求！\n\n （九）中介者模式\n 模式介绍\n\n模式动机：\n\n对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机\n在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。\n如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。\n在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。\n\n\n模式定义：\n\n用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n中介者模式又称为调停者模式，它是一种对象行为型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\n具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\n抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\n具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\n\n\n模型评价：\n\n优点\n\n类之间各司其职，符合迪米特法则。\n降低了对象之间的耦合性，使得对象易于独立地被复用。\n将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。\n\n\n缺点\n\n中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。\n\n\n应用场景\n\n系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。\n一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。\n想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类\n我们所常知道的MVC模式中，controller就是我们所谓的中介者。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;抽象中介者\nabstract class Mediator &#123;\n    public abstract void register(Colleague colleague);\n    public abstract void relay(Colleague cl); &#x2F;&#x2F;转发\n&#125;\n&#x2F;&#x2F;具体中介者\nclass ConcreteMediator extends Mediator &#123;\n    private List&lt;Colleague&gt; colleagues &#x3D; new ArrayList&lt;Colleague&gt;();\n    public void register(Colleague colleague) &#123;\n        if (!colleagues.contains(colleague)) &#123;\n            colleagues.add(colleague);\n            colleague.setMedium(this);\n        &#125;\n    &#125;\n    public void relay(Colleague cl) &#123;\n        for (Colleague ob : colleagues) &#123;\n            if (!ob.equals(cl)) &#123;\n                ((Colleague) ob).receive();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象同事类\nabstract class Colleague &#123;\n    protected Mediator mediator;\n    public void setMedium(Mediator mediator) &#123;\n        this.mediator &#x3D; mediator;\n    &#125;\n    public abstract void receive();\n    public abstract void send();\n&#125;\n&#x2F;&#x2F;具体同事类\nclass ConcreteColleague1 extends Colleague &#123;\n    public void receive() &#123;\n        System.out.println(&quot;具体同事类1收到请求。&quot;);\n    &#125;\n    public void send() &#123;\n        System.out.println(&quot;具体同事类1发出请求。&quot;);\n        mediator.relay(this); &#x2F;&#x2F;请中介者转发\n    &#125;\n&#125;\n&#x2F;&#x2F;具体同事类\nclass ConcreteColleague2 extends Colleague &#123;\n    public void receive() &#123;\n        System.out.println(&quot;具体同事类2收到请求。&quot;);\n    &#125;\n    public void send() &#123;\n        System.out.println(&quot;具体同事类2发出请求。&quot;);\n        mediator.relay(this); &#x2F;&#x2F;请中介者转发\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class MediatorPattern &#123;\n    public static void main(String[] args) &#123;\n        Mediator md &#x3D; new ConcreteMediator();\n        Colleague c1, c2;\n        c1 &#x3D; new ConcreteColleague1();\n        c2 &#x3D; new ConcreteColleague2();\n        md.register(c1);\n        md.register(c2);\n        c1.send();\n        System.out.println(&quot;-------------&quot;);\n        c2.send();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体同事类1发出请求。\n具体同事类2收到请求。\n-------------\n具体同事类2发出请求。\n具体同事类1收到请求。\n\n （十）访问者模式\n 模式介绍\n\n模式动机：\n-在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。\n-这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。\n-这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。\n模式定义：\n\n将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。\n访问者（Visitor）模式是一种对象行为型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。\n具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。\n抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。\n具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。\n对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。\n\n\n模型评价：\n\n优点\n\n扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。\n灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。\n符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。\n\n\n缺点\n\n增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\n破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。\n违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。\n\n\n应用场景\n\n对象结构相对稳定，但其操作算法经常变化的程序。\n对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。\n对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;抽象访问者\ninterface Visitor &#123;\n    void visit(ConcreteElementA element);\n    void visit(ConcreteElementB element);\n&#125;\n&#x2F;&#x2F;具体访问者A类\nclass ConcreteVisitorA implements Visitor &#123;\n    public void visit(ConcreteElementA element) &#123;\n        System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationA());\n    &#125;\n    public void visit(ConcreteElementB element) &#123;\n        System.out.println(&quot;具体访问者A访问--&gt;&quot; + element.operationB());\n    &#125;\n&#125;\n&#x2F;&#x2F;具体访问者B类\nclass ConcreteVisitorB implements Visitor &#123;\n    public void visit(ConcreteElementA element) &#123;\n        System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationA());\n    &#125;\n    public void visit(ConcreteElementB element) &#123;\n        System.out.println(&quot;具体访问者B访问--&gt;&quot; + element.operationB());\n    &#125;\n&#125;\n&#x2F;&#x2F;抽象元素类\ninterface Element &#123;\n    void accept(Visitor visitor);\n&#125;\n&#x2F;&#x2F;具体元素A类\nclass ConcreteElementA implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n    public String operationA() &#123;\n        return &quot;具体元素A的操作。&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;具体元素B类\nclass ConcreteElementB implements Element &#123;\n    public void accept(Visitor visitor) &#123;\n        visitor.visit(this);\n    &#125;\n    public String operationB() &#123;\n        return &quot;具体元素B的操作。&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;对象结构角色\nclass ObjectStructure &#123;\n    private List&lt;Element&gt; list &#x3D; new ArrayList&lt;Element&gt;();\n    public void accept(Visitor visitor) &#123;\n        Iterator&lt;Element&gt; i &#x3D; list.iterator();\n        while (i.hasNext()) &#123;\n            ((Element) i.next()).accept(visitor);\n        &#125;\n    &#125;\n    public void add(Element element) &#123;\n        list.add(element);\n    &#125;\n    public void remove(Element element) &#123;\n        list.remove(element);\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\nimport java.util.*;\npublic class VisitorPattern &#123;\n    public static void main(String[] args) &#123;\n        ObjectStructure os &#x3D; new ObjectStructure();\n        os.add(new ConcreteElementA());\n        os.add(new ConcreteElementB());\n        Visitor visitor &#x3D; new ConcreteVisitorA();\n        os.accept(visitor);\n        System.out.println(&quot;------------------------&quot;);\n        visitor &#x3D; new ConcreteVisitorB();\n        os.accept(visitor);\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n具体访问者A访问--&gt;具体元素A的操作。\n具体访问者A访问--&gt;具体元素B的操作。\n------------------------\n具体访问者B访问--&gt;具体元素A的操作。\n具体访问者B访问--&gt;具体元素B的操作。\n\n （十一）解释器模式\n 模式介绍\n\n模式动机：\n\n在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。\n\n\n模式定义：\n\n定义语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”意思是使用规定格式和语法的代码，它是一个类行为型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。\n终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。\n非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。\n环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。\n客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。\n\n\n模型评价：\n\n优点\n\n扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。\n容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。\n\n\n缺点\n\n执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。\n会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。\n可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。\n\n\n应用场景\n\n当语言的文法较为简单，且执行效率不是关键问题时。\n当问题重复出现，且可以用一种简单的语言来进行表达时。\n当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\npackage net.biancheng.c.interpreter;\n&#x2F;&#x2F;抽象表达式类\ninterface AbstractExpression &#123;\n    public void interpret(String info);    &#x2F;&#x2F;解释方法\n&#125;\n&#x2F;&#x2F;终结符表达式类\nclass TerminalExpression implements AbstractExpression &#123;\n    public void interpret(String info) &#123;\n        &#x2F;&#x2F;对终结符表达式的处理\n    &#125;\n&#125;\n&#x2F;&#x2F;非终结符表达式类\nclass NonterminalExpression implements AbstractExpression &#123;\n    private AbstractExpression exp1;\n    private AbstractExpression exp2;\n    public void interpret(String info) &#123;\n        &#x2F;&#x2F;非对终结符表达式的处理\n    &#125;\n&#125;\n&#x2F;&#x2F;环境类\nclass Context &#123;\n    private AbstractExpression exp;\n    public Context() &#123;\n        &#x2F;&#x2F;数据初始化\n    &#125;\n    public void operation(String info) &#123;\n        &#x2F;&#x2F;调用相关表达式类的解释方法\n    &#125;\n&#125;\n\n 参考文献/博客\n\n\n\n\n\n\n\n\n\n[1] 设计模式\n[2] 15分钟入门23种设计模式：图解，范例和对比\n[3] 万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解\n[4] 一孔之见️\n[5] Jerry_1116\n[6] Java技术教程\n","slug":"6-设计模式-3","date":"2023-05-08T15:06:41.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"Kevin"},{"id":"a39375e630b00cc66be242014aeafe21","title":"设计模式-2","content":" 设计模式-2\n 一、 结构型模式\n\n\n\n\n\n\n\n\n\n结构型模式关注的是类或对象如何组织,描述如何将类或对象按某种布局组成更大的结构。  它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。\n装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。\n外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n\n\n\n\n （一）外观模式\n 模式介绍\n\n模式动机：\n\n一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道\n引入一个新的外观类（Facade）来负责多个业务类或者说是子系统，而客户类只需要与外观类进行交互\n\n\n模式定义：\n\n为子系统的一组接口提供一个统一的入口，外观模定义一个高层的接口，这个接口使得子系统更加统一使用\n外观模式属于对象结构型模式，又称为门面模式，是迪米特法则的一种具体实现\n通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统系统之间的耦合度。\n\n所指的子系统是一个广义的概念，他可以是一个类，一个功能模块，系统的一个组成部分或者一个完整的系统。\n\n\n\n\n模式结构：\n\n\n\n\n角色分析：\n\nFacade 外观角色：为多个子系统对外提供一个共同的接口\nSubSystem 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它\n\n\n模型评价：\n\n优点\n\n对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易\n实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可\n子系统的内部变化不会影响到外观对象，一个子系统的修改对其他子系统也没有任何影响\n\n\n缺点\n\n不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性\n如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则\n\n\n应用场景\n\n要为访问一系列复杂的子系统提供一个简单入口\n客户端程序与多个子系统之间存在很大的依赖性\n在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中\n&#x2F;&#x2F;具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。\n&#x2F;&#x2F;这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。\n&#x2F;&#x2F;现使用外观模式设计该文件加密模块。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件保存类\n * @Description:\n *&#x2F;\npublic class FileWriter &#123;\n    public void write(String encryptString,String path)&#123;\n        System.out.println(&quot;保存密文，写入文件。&quot;);\n        try &#123;\n            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(path);\n            &#x2F;&#x2F;写入\n            fileOutputStream.write(encryptString.getBytes());\n            fileOutputStream.close();\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在！&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n&#x2F;**\n * @Theme: 子系统-文件读取类\n * @Description:\n *&#x2F;\npublic class FileReader &#123;\n    public String read(String path)&#123;\n        System.out.println(&quot;读取文件，获得明文：&quot;);\n        StringBuffer stringBuffer &#x3D; new StringBuffer();\n        try &#123;\n            FileInputStream fileInputStream &#x3D; new FileInputStream(path);\n            int data;\n            while((data &#x3D; fileInputStream.read()) !&#x3D; -1)&#123;\n                stringBuffer &#x3D; stringBuffer.append((char) data);\n            &#125;\n            &#x2F;&#x2F;关闭\n            fileInputStream.close();\n            System.out.println(stringBuffer.toString());\n        &#125; catch (FileNotFoundException e) &#123;\n            System.out.println(&quot;文件不存在&quot;);\n        &#125; catch (IOException e) &#123;\n            System.out.println(&quot;文件操作错误&quot;);\n        &#125;\n\n        return stringBuffer.toString();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 子系统-文件加密类\n * @Description:\n *&#x2F;\npublic class CipherMachine &#123;\n    public String encrypt(String plainText)&#123;\n\n        System.out.println(&quot;数据加密，将明文转换为密文：&quot;);\n        String es &#x3D; &quot;&quot;;\n        for (int i &#x3D; 0; i &lt; plainText.length(); i++) &#123;\n            String s &#x3D; String.valueOf(plainText.charAt(i) % 7);\n            es +&#x3D; s;\n        &#125;\n\n        System.out.println(es);\n        return es;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 外观类：加密外观类\n * @Description:\n *&#x2F;\npublic class EncryptFacade &#123;\n    &#x2F;&#x2F;维持对子系统的引用\n    private FileReader fileReader;\n    private CipherMachine cipherMachine;\n    private FileWriter fileWriter;\n\n    public EncryptFacade() &#123;\n        this.fileReader &#x3D; new FileReader();\n        this.cipherMachine &#x3D; new CipherMachine();\n        this.fileWriter &#x3D; new FileWriter();\n    &#125;\n\n    &#x2F;&#x2F;调用子系统的业务方法\n    public void fileEncrypt(String pathSrc,String pathDes)&#123;\n        String read &#x3D; fileReader.read(pathSrc);\n        String encrypt &#x3D; cipherMachine.encrypt(read);\n        fileWriter.write(encrypt,pathDes);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        EncryptFacade encryptFacade &#x3D; new EncryptFacade();\n        encryptFacade.fileEncrypt(&quot;file.txt&quot;,&quot;des.txt&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nfile.text:happy birthday to you!\ndes.text:\n&#x2F;&#x2F;运行结果：\n    读取文件，获得明文：\n    happy birthday to you!\n    数据加密，将明文转换为密文：\n    331403442436545\n    保存密文，写入文件\n&#x2F;&#x2F;增加抽象外观类，使用配置文件更换外观类\n&#x2F;&#x2F;核心代码\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;增加抽象外观类\npublic abstract class AbstractEncryptFacade &#123;\n    public abstract void fileEncrypt(String fileNameSrc, String fileNameDes);\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;实现新的外观类\npublic class NewEncryptFacade extends AbstractEncryptFacade &#123;\n    private FileReader reader;\n    private NewCipherMachine cipher;\n    private FileWriter writer;\n\t\n    public NewEncryptFacade() &#123;\n        reader &#x3D; new FileReader();\n        cipher &#x3D; new NewCipherMachine();\n        writer &#x3D; new FileWriter();\n    &#125;\n\t\n    public void fileEncrypt(String fileNameSrc, String fileNameDes) &#123;\n        String plainStr &#x3D; reader.read(fileNameSrc);\n        String encryptStr &#x3D; cipher.encrypt(plainStr);\n        writer.write(encryptStr,fileNameDes);\n    &#125;\n&#125; \n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\npublic class Client &#123;\n    public static void main(String args[]) &#123;\n        AbstractEncryptFacade ef;\n        ef &#x3D; (AbstractEncryptFacade)XMLUtil.getBean();\n        ef.fileEncrypt(&quot;src.txt&quot;,&quot;des.txt&quot;);    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;使用配置文件更换外观类\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n    &lt;className&gt;NewEncryptFacade&lt;&#x2F;className&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n （二）适配器模式\n 模式介绍\n\n模式动机：\n\n把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作\n\n\n模式定义：\n\n将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作\n既是对象结构型模式，又是类结构型模式\n别名：包装器模式\n定义中所指的接口是指广义的接口，他可以表示一个方法或者方法的集合\n\n\n模式结构：\n\n类适配器\n\n对象适配器\n\n\n\n角色分析：\n\nTarget 目标抽象类：期待得到的目标，相当于插座\nAdapter 适配器类：连接目标和源的中间对象，相当于插头转换器\nAdaptee 适配者类：需要被适配的对象或类型，相当于插头\n\n\n模型评价：\n\n优点\n\n将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构\n增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用\n灵活性和扩展性非常好\n类适配器模式：置换一些适配者的方法很方便\n对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类\n\n\n缺点\n\n类适配器模式：\n\n一次最多只能适配一个适配者类，不能同时适配多个适配者\n适配者类不能为最终类\n目标抽象类只能为接口，不能为类\n\n\n对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦\n\n\n应用场景\n\n系统需要使用一些现有的类（适配者），而这些类的接口不符合系统的需要，甚至没有这些类的源代码\n创建一个可以重复使用的类（目标类/适配者），用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;类适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter extends Adaptee implements Target &#123;\n\n    &#x2F;**\n     * 采用继承的方式实现转换功能\n     *&#x2F;\n    @Override\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用继承的方法，对其进行增强或处理\n        this.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;对象适配器\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;目标接口\npublic interface Target &#123;\n    &#x2F;**\n     * 定义新插座的规范是新插座的形状应该是一个双头插座\n     *&#x2F;\n    public void doubleHoleSocket();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配者类\npublic class Adaptee &#123;\n    &#x2F;**\n     * 需要被适配的功能\n     * 这里用插座转换举例\n     *&#x2F;\n    public void commonThreeHoleSocket()&#123;\n        System.out.println(&quot;hi，我是一个常见的三孔插座&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;适配器类\npublic class Adapter implements Target &#123;\n    &#x2F;**\n     * 这是两种实现方式唯一的不同之处\n     *&#x2F;\n    private Adaptee adaptee;\n\n    public Adapter() &#123;\n        this.adaptee &#x3D; new Adaptee();\n    &#125;\n\n    &#x2F;**\n     * 采用组合的方式实现转换功能\n     *&#x2F;\n    public void doubleHoleSocket() &#123;\n        &#x2F;&#x2F; 调用组合成员的方法，对其进行增强或处理\n        this.adaptee.commonThreeHoleSocket();\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;开始转换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(&quot;oh，我变成了两孔插座&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Target newPlug &#x3D; new Adapter();\n        &#x2F;&#x2F; 对于使用者来说，它只需要知道适配器提供了一个两孔插头即可\n        newPlug.doubleHoleSocket();\n        System.out.println(&quot;这是一个两孔插头&quot;);\n    &#125;\n&#125;\n\n （三）组合模式\n 模式介绍\n\n模式动机：\n\n组合模式依据树形结构来组合对象，用来表示部分以及整体层次\n\n\n模式定义：\n\n将多个对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得客户端对单个对象和组合对象的使用具有一致性\n组合模式又称为整体-部分模式，属于对象结构型模式。\n\n\n模式结构：\n\n透明组合模式\n\n在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的\n但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。\n\n\n\n安全组合模式\n\n在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了透明方式的安全性问题\n但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。\n\n\n\n\n\n角色分析：\n\n抽象构件（Component）角色：总的抽象类或接口，为树叶构件和树枝构件声明公共接口，并实现它们的默认行为\n\n在透明式的组合模式中，抽象构件还声明访问和管理子类的接口\n在安全式的组合模式中，抽象构件仅仅做子类的声明，然后由树枝构件进行实现\n\n\n树叶构件（Leaf）角色：树叶对象，是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件\n\n树叶构件在组合中表示叶节点对象，它实现了在抽象构件中定义的行为\n\n\n树枝构件/容器构件（Composite）角色 ：树枝对象，是组合中的分支节点对象，它有子节点，用于继承或实现抽象构件\n\n容器构件定义有枝节点的行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove\n\n\n\n\n模型评价：\n\n优点\n\n组合模式使得客户端代码可以一致地处理单个对象和组合对象，无需关心自己处理的是单个对象，还是组合对象，这简化了客户端代码\n更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改源代码，满足“开闭原则”\n\n\n缺点\n\n设计较复杂，客户端需要花更多时间理清类之间的层次关系\n不容易限制容器中的构件\n不容易用继承的方法来增加构件的新功能\n在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则\n\n\n应用场景\n\n在需要表示一个对象整体与部分的层次结构的场合。\n要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;透明组合模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件\ninterface Component &#123;\n    public void add(Component c);\n    public void remove(Component c);\n    public Component getChild(int i);\n    public void operation();\n&#125;\n&#x2F;&#x2F;树叶构件\nclass Leaf implements Component &#123;\n    private String name;\n    public Leaf(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    &#x2F;&#x2F; 叶子节点没有子节点所以add和remove方法实现它没有意义，但这样做可以消除叶节点和枝节点对象在抽象层次的区别，它们具备完全一致的接口\n    public void add(Component c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void remove(Component c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    &#x2F;&#x2F; 叶子节点没有子节点所以返回null或者抛出异常也是可以的\n    public Component getChild(int i) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void operation() &#123;\n        System.out.println(&quot;树叶&quot; + name + &quot;：被访问！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;树枝构件\nclass Composite implements Component &#123;\n    private ArrayList&lt;Component&gt; children &#x3D; new ArrayList&lt;Component&gt;();\n    public void add(Component c) &#123;\n        children.add(c);\n    &#125;\n    public void remove(Component c) &#123;\n        children.remove(c);\n    &#125;\n    public Component getChild(int i) &#123;\n        return children.get(i);\n    &#125;\n    &#x2F;&#x2F; 遍历所有子节点并输出\n    public void operation() &#123;\n        for (Object obj : children) &#123;\n            ((Component) obj).operation();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class CompositePattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 构造根节点，注意声明类型为Component\n        Component c0 &#x3D; new Composite();\n        Component c1 &#x3D; new Composite();\n        Component leaf1 &#x3D; new Leaf(&quot;1&quot;);\n        Component leaf2 &#x3D; new Leaf(&quot;2&quot;);\n        Component leaf3 &#x3D; new Leaf(&quot;3&quot;);\n        c0.add(leaf1);\n        c0.add(c1);\n        c1.add(leaf2);\n        c1.add(leaf3);\n        c0.operation();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n    树叶1：被访问！\n    树叶2：被访问！\n    树叶3：被访问！\n&#x2F;&#x2F;安全组合模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件\ninterface Component &#123;\n    public void operation();\n&#125;\n&#x2F;&#x2F;树叶构件\nclass Leaf implements Component &#123;\n    private String name;\n    public Leaf(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    public void operation() &#123;\n        System.out.println(&quot;树叶&quot; + name + &quot;：被访问！&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;树枝构件\nclass Composite implements Component &#123;\n    private ArrayList&lt;Component&gt; children &#x3D; new ArrayList&lt;Component&gt;();\n    public void add(Component c) &#123;\n        children.add(c);\n    &#125;\n    public void remove(Component c) &#123;\n        children.remove(c);\n    &#125;\n    public Component getChild(int i) &#123;\n        return children.get(i);\n    &#125;\n    &#x2F;&#x2F; 遍历所有子节点并输出\n    public void operation() &#123;\n        for (Object obj : children) &#123;\n            ((Component) obj).operation();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class CompositePattern &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 构造根节点，注意声明类型为Composite，便于使用构件管理方法add和remove等\n        Composite c0 &#x3D; new Composite();\n        Composite c1 &#x3D; new Composite();\n        Component leaf1 &#x3D; new Leaf(&quot;1&quot;);\n        Component leaf2 &#x3D; new Leaf(&quot;2&quot;);\n        Component leaf3 &#x3D; new Leaf(&quot;3&quot;);\n        c0.add(leaf1);\n        c0.add(c1);\n        c1.add(leaf2);\n        c1.add(leaf3);\n        c0.operation();\n    &#125;\n&#125;\n&#x2F;&#x2F;运行结果\n    树叶1：被访问！\n    树叶2：被访问！\n    树叶3：被访问！\n\n （四）代理模式\n\n\n\n\n\n\n\n\n\n建议阅读：设计模式之——代理模式\n 模式介绍\n\n模式动机：\n\n在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦，如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。\n代理模式就是为这些对象提供一种代理以控制对这些对象的访问，即通过代理对象访问目标对象。这样做的好处是：可以在不修改目标对象的前提下扩展目标对象的功能，同时可以为多个不同的客户端提供同一个目标对象，而这些客户端并不需要知道目标对象本身以及具体的操作细节，代理对象会封装所有的操作。\n\n\n\n\n\n\n\n\n\n\n\n\n在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买;明星都有自己的经纪人，有事需要找他们的时候就要先找他们的经纪人，经纪人也相当于是一个代理；再比如打官司都需要找一个律师，有什么问题直接由律师去沟通解决，那律师就是自己的一个代理。\n\n模式定义：\n\n代理模式又叫委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问\n代理模式是一种对象结构型模式。\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n\n模型评价：\n\n静态代理\n\n优点\n\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n代理对象可以扩展目标对象的功能；\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n\n缺点\n\n如果需要为不同的真实主题类提供代理，或代理一个真实主题类的不同方法时，不得不为每一个真实主题类或每一个方法都进行代理，这样会导致静态代理类爆炸，不易管理和维护。\n如果需要代理的方法很多且都使用增强方法，则导致代理类的不同方法中存在大量相同的代码，无法实现代码重用。\n\n\n\n\n动态代理\n\n优点\n\n动态代理可以在运行时动态地创建代理对象，而不需要事先定义代理类，这样可以减少代码量和提高开发效率。\n动态代理可以根据不同的目标对象和需求，灵活地生成不同的代理对象，这样可以增加系统的可扩展性和可维护性。\n动态代理可以实现对目标对象的透明访问，客户端只需要使用抽象主题的接口，而不需要关心真实对象和代理对象的细节\n\n\n缺点\n\n动态代理需要使用反射和字节码技术来生成代理对象，这样会增加系统的复杂度和开销，也可能会影响系统的性能和稳定性。\n动态代理需要遵循一些约束和限制，例如JDK动态代理只能代理实现了接口的类，CGLIB动态代理不能代理final类或方法等，这样会降低系统的灵活性和通用性。\n动态代理比静态代理更难以理解和掌握，需要有一定的基础知识和经验才能使用好动态代理。\n\n\n\n\n代理模式-应用场景\n\n当我们需要访问一个远程对象时，可以使用远程代理，它可以隐藏远程对象的位置和通信细节，让客户端像访问本地对象一样访问远程对象。\n\nJDK动态代理实现RPC\nRMI实现RPC\n\n\n当我们需要创建一个开销很大的对象时，可以使用虚拟代理，它可以在真正需要的时候才创建真实对象，从而实现延迟加载和节省资源。\n当我们需要给一个对象增加一些额外的功能时，可以使用装饰代理，它可以在不修改原有对象的情况下，给对象添加一些新的行为或属性。\n当我们需要给一个对象增加一些访问控制或安全保护时，可以使用保护代理，它可以根据不同的用户或角色，对对象的访问进行限制或检查。\n当我们需要给一个对象增加一些日志记录或性能监控时，可以使用日志代理或性能代理，它可以在调用对象的方法之前或之后，记录相关的信息或数据。\n\n\n\n\n\n 模式实现\n\n\n\n\n\n\n\n\n\n代理模式的不同方式\n\n\n静态代理：\n\n由程序员创建或特定工具自动生成源代码，再对其进行编译。\n在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。\n\n\n动态代理：\n\n动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。\n代理类和委托类的关系是在程序运行时确定。\n动态代理的2种实现方式\n\n\nJDK动态代理\nCGLIB动态代理\n\n\n\njava实现\n\n&#x2F;&#x2F;静态代理\n&#x2F;&#x2F; 抽象主题接口\npublic interface Subject &#123;\n    &#x2F;&#x2F; 定义一个抽象方法\n    void request();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 真实主题类\npublic class RealSubject implements Subject &#123;\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 真实的业务逻辑\n        System.out.println(&quot;RealSubject is doing something...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 代理主题类\npublic class Proxy implements Subject &#123;\n    &#x2F;&#x2F; 持有一个真实主题的引用\n    private RealSubject realSubject;\n\n    &#x2F;&#x2F; 构造方法，传入一个真实主题对象\n    public Proxy(RealSubject realSubject) &#123;\n        this.realSubject &#x3D; realSubject;\n    &#125;\n\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 在调用真实主题之前，可以执行一些额外操作\n        System.out.println(&quot;Proxy is doing something before...&quot;);\n        &#x2F;&#x2F; 调用真实主题的方法\n        realSubject.request();\n        &#x2F;&#x2F; 在调用真实主题之后，可以执行一些额外操作\n        System.out.println(&quot;Proxy is doing something after...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 客户端类\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个真实主题对象\n        RealSubject realSubject &#x3D; new RealSubject();\n        &#x2F;&#x2F; 创建一个代理对象，并传入真实主题对象\n        Proxy proxy &#x3D; new Proxy(realSubject);\n        &#x2F;&#x2F; 使用代理对象来调用抽象方法\n        proxy.request();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\nProxy is doing something before...\nRealSubject is doing something...\nProxy is doing something after...\n\n&#x2F;&#x2F;JDK动态代理\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;从静态代理会发现——每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类。\n&#x2F;&#x2F;所以我们想办法通过一个代理类完成全部的代理功能，那么我们就需要用动态代理。\n&#x2F;&#x2F;在上面示例中，一个代理只能代理一种类型，而且是在编译器就已经确定被代理的对象。\n&#x2F;&#x2F;而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。\n&#x2F;&#x2F;在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类的支持。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象主题接口\npublic interface Subject &#123;\n    &#x2F;&#x2F; 定义一个抽象方法\n    void request();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 真实主题类\npublic class RealSubject implements Subject &#123;\n    &#x2F;&#x2F; 实现抽象方法\n    @Override\n    public void request() &#123;\n        &#x2F;&#x2F; 真实的业务逻辑\n        System.out.println(&quot;RealSubject is doing something...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 日志处理器（代理主题）类，实现了InvocationHandler接口，用于定义代理逻辑\npublic class LogHandler implements InvocationHandler &#123;\n    &#x2F;&#x2F; 持有一个目标对象的引用\n    private Object target;\n\n    &#x2F;&#x2F; 构造方法，传入一个目标对象\n    public LogHandler(Object target) &#123;\n        this.target &#x3D; target;\n    &#125;\n\n    &#x2F;&#x2F; 实现invoke方法，用于调用目标对象的方法，并在之前和之后执行日志操作\n        &#x2F;&#x2F;参数说明：\n        &#x2F;&#x2F;  Object proxy 被代理对象；\n        &#x2F;&#x2F;  Method method 要调用的方法；\n        &#x2F;&#x2F;  Object[] args 方法调用时所需要的参数\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        &#x2F;&#x2F; 在调用目标对象之前，记录开始时间\n        long startTime &#x3D; System.currentTimeMillis();\n        System.out.println(&quot;开始执行&quot; + method.getName() + &quot;方法...&quot;);\n\n        &#x2F;&#x2F; 调用目标对象的方法，并获取返回值\n        Object result &#x3D; method.invoke(target, args);\n\n        &#x2F;&#x2F; 在调用目标对象之后，记录结束时间和耗时\n        long endTime &#x3D; System.currentTimeMillis();\n        long duration &#x3D; endTime - startTime;\n        System.out.println(&quot;结束执行&quot; + method.getName() + &quot;方法，耗时&quot; + duration + &quot;毫秒&quot;);\n        &#x2F;&#x2F; 返回结果\n        return result;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 客户端类\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个真实主题对象\n        RealSubject realSubject &#x3D; new RealSubject();\n        &#x2F;&#x2F; 创建一个日志处理器对象，并传入真实主题对象\n        LogHandler logHandler &#x3D; new LogHandler(realSubject);\n        &#x2F;&#x2F; 使用Proxy类的静态方法newProxyInstance来动态地创建一个代理对象，传入真实主题对象的类加载器、接口和处理器\n            &#x2F;&#x2F;参数说明：\n            &#x2F;&#x2F;  ClassLoader loader 类的加载器；\n            &#x2F;&#x2F;  Class&lt;?&gt;[] interfaces 得到全部的接口；\n            &#x2F;&#x2F;  InvocationHandler h 得到InvocationHandler接口的子类的实例\n        Subject proxy &#x3D; (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), logHandler);\n        &#x2F;&#x2F; 使用代理对象来调用抽象方法\n        proxy.request();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n开始执行request方法...\nRealSubject is doing something...\n结束执行request方法，耗时1毫秒\n\n （五）桥接模式\n\n\n\n\n\n\n\n\n\n建议阅读：设计模式（八）—— 桥接模式（定义、案例分析、特点、缺点）\n 模式介绍\n\n\n模式动机：\n\n在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。\n这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。\n\n\n\n模式定义：\n\n桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。\n\n\n\n模式结构：\n\n\n\n\n\n角色分析：\n\n抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。\n扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\n实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。\n具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。\n\n\n\n模型评价：\n\n优点\n\n当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。\n分离抽象接口及其实现部分（桥接模式中属性的定义是直接在接口类就定义了而没有到实现类才设置属性，这就是面向抽象编程）\n可以取代多层继承方案，极大地减少了子类的个数\n提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则\n\n\n缺点\n\n会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程。\n正确识别出系统中两个独立变化的维度并不是一件容易的事情。\n\n\n应用场景\n\n需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系\n抽象部分和实现部分可以以继承的方式独立扩展而互不影响\n一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展\n不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5&#x3D;15支蜡笔，也就是说必须准备15个具体的蜡笔类。\n&#x2F;&#x2F;而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5&#x3D;8个类就可以实现15支蜡笔的功能。\n&#x2F;&#x2F;本实例使用桥接模式来模拟毛笔的使用过程\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;实现类接口——color\npublic interface Color&#123;\n\tpublic void bepaint(String penType, String name);\n&#125;\n\n&#x2F;&#x2F;具体实现类1——red等其他颜色\npublic class Red implements Color&#123;\n\tpublic void bepaint(String penType, String name)&#123;\n\t\tSystem.out.println(penType + &quot;红色的&quot; + name);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象类——pen\npublic abstract Pen\n&#123;\n    &#x2F;&#x2F;可视为接口作为属性通过setter注入，将实现化对象聚合到抽象类中，达成多层继承的效果\n\tprotected Color color;\n\tpublic void setColor(Color color)&#123;\n\t\tthis.color &#x3D; color;\n\t&#125;\n\tpublic abstract void draw(String name);\n&#125;\n\n&#x2F;&#x2F;扩充抽象类1——bigpen\npublic class BigPen extends Pen\n&#123;\n\tpublic void draw(String name)&#123;\n\t\tString penType &#x3D; &quot;大号毛笔绘制&quot;;\n\t\tthis.color.bepaint(penType, name);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class Client&#123;\n\tpublic static void main(String args[])&#123;\n         Color color;\n         Pen pen;\n\t\t\n\t\t&#x2F;&#x2F;利用xml反射读取指定对象\n\t\t color &#x3D; (Color)XMLUtil.getBean(&quot;color&quot;);&#x2F;&#x2F;理解成color &#x3D; new Red();\n\t\t pen&#x3D; (Pen)XMLUtil.getBean(&quot;pen&quot;);&#x2F;&#x2F;理解成pen &#x3D; new BigPen();\n         pen.setColor(color);&#x2F;&#x2F;把桥的另一边设置进来\n         pen.draw(&quot;鲜花&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;配置文件\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n\t&lt;color&gt;Red&lt;&#x2F;color&gt;\n\t&lt;pen&gt;BigPen&lt;&#x2F;pen&gt;\n&lt;&#x2F;config&gt;\n&#x2F;&#x2F;工具类XMLUtil\nimport javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\nimport java.io.*;\npublic class XMLUtil\n&#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取品牌名称，并返回该品牌名称\n\tpublic static String getBean(String str)\n\t&#123;\n\t\ttry\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;创建文档对象\n\t\t\tDocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n\t\t\tDocument doc;\t\t\t\t\t\t\t\n\t\t\tdoc &#x3D; builder.parse(new File(&quot;config.xml&quot;)); \n\t\t\n\t\t\t&#x2F;&#x2F;获取包含类名的文本节点\n\t\t\tif(str.equals(&quot;color&quot;))&#123;\n\t\t\t\tNodeList nl &#x3D; doc.getElementsByTagName(&quot;color&quot;);\n            \tNode classNode &#x3D; nl.item(0).getFirstChild();\n            \tString name &#x3D; classNode.getNodeValue().trim();\n            \treturn name;\n            &#125;else if(str.equals(&quot;pen&quot;)&#123;\n            \tNodeList nl &#x3D; doc.getElementsByTagName(&quot;pen&quot;);\n            \tNode classNode &#x3D; nl.item(0).getFirstChild();\n            \tString name &#x3D; classNode.getNodeValue().trim();\n            \treturn name;\n            &#125;\n            \n           &#125;   \n           \tcatch(Exception e)\n           \t&#123;\n           \t\te.printStackTrace();\n           \t\treturn null;\n           \t&#125;\n\t\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n大号毛笔绘制红色的鲜花\n\n\n （六）装饰模式\n\n\n\n\n\n\n\n\n\n建议阅读：设计模式（十）—— 装饰模式（定义、案例分析、特点、缺点\n 模式介绍\n\n\n模式动机：\n\n有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。\n在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现\n\n\n\n模式定义：\n\n指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式\n装饰模式属于对象结构型模式\n\n\n\n模式结构：\n\n\n半透明(Semi-transparent)装饰模式\n\n用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义\n对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的\n可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便\n客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用扩展新增的方法\n最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象\n\n\n透明(Transparent)装饰模式\n\n要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型\n对于客户端而言，具体构件对象和具体装饰对象没有任何区别\n可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别\n可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象\n无法在客户端单独调用新增拓展方法。（只能内嵌使用）\n\n\n\n\n\n角色分析：\n\n抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。\n具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。\n抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。\n具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\n\n\n\n模型评价：\n\n优点\n\n装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用\n通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果\n装饰器模式完全遵守开闭原则\n\n\n缺点\n\n装饰器模式会增加许多子类，过度使用会增加程序得复杂性\n\n\n应用场景\n\n当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。\n当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。\n当对象的功能要求可以动态地添加，也可以再动态地撤销时。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;半透明装饰模式\n&#x2F;&#x2F;变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。试用装饰模式设计该变形金刚\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件类-变形金刚\npublic abstract class Transform\n&#123;\n\tpublic abstract void move();\n&#125;\n&#x2F;&#x2F;具体构件类-汽车\npublic final class Car extends Transform&#123;\n\tpublic void Car()&#123;\n\t\tSystem.out.println(&quot;变形金刚是一辆车&quot;);\n\t&#125;\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;在陆地上移动&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;抽象装饰类Changer\npublic class Changer extends Transform&#123;\n\tprivate Transform t ;\n\tpublic Changer(Transform t)&#123;\n\t\tthis.t &#x3D; t;\n\t&#125;\n\tpublic void move()&#123;\n\t\tt.move();&#x2F;&#x2F;调用关联类自己的方法\n\t&#125;\t\n&#125;\n&#x2F;&#x2F;具体装饰类-机器人\npublic class Robot extends Changer&#123;\n\tpublic Robot(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成机器人&quot;);\n\t&#125;\n\tpublic void say()&#123;\n\t\tSystem.out.println(&quot;武器发射&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;具体装饰类-飞机\npublic class AirPlane extends Changer&#123;\n\tpublic AirPlane(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成飞机&quot;);\n\t&#125;\n\tpublic void fly()&#123;\n\t\tSystem.out.println(&quot;起飞&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;客户端\npublic class Client&#123;\n\tpublic static void main(String args[])&#123;\n\t\tTransform camaro;\n\t\tcamaro &#x3D; new Car();\n\t\tcamaro.move();\n\n\t\tRobot bumblebee &#x3D; new Robot(camaro);\n\t\tbumblebee.move();\n\t\tbumblebee.say();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;透明装饰模式\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象构件类\npublic abstract class Transform\n&#123;\n\tpublic abstract void move();\n&#125;\n&#x2F;&#x2F;具体构件类-汽车Car\npublic final class Car extends Transform&#123;\n\tpublic void Car()&#123;\n\t\tSystem.out.println(&quot;变形金刚是一辆车&quot;);\n\t&#125;\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;在陆地上移动&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;抽象装饰类Changer\npublic class Changer extends Transform&#123;\n\tprivate Transform t ;\n\tpublic Changer(Transform t)&#123;\n\t\tthis.t &#x3D; t;\n\t&#125;\n\tpublic void move()&#123;\n\t\tt.move();&#x2F;&#x2F;调用关联类自己的方法\n\t&#125;\t\n&#125;\n\n&#x2F;&#x2F;具体装饰类-机器人Robot\npublic class Robot extends Changer&#123;\n\tpublic Robot(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成机器人&quot;);\n\t&#125;\n    &#x2F;&#x2F;实现新增功能\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;武器发射&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F;具体装饰类-飞机AirPlane\npublic class AirPlane extends Changer&#123;\n\tpublic AirPlane(Transform transform)&#123;\n\t\tsuper(transform);\n\t\tSystem.out.println(&quot;变成飞机&quot;);\n\t&#125;\n    &#x2F;&#x2F;实现新增功能\n\tpublic void move()&#123;\n\t\tSystem.out.println(&quot;起飞&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;客户端\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n        &#x2F;&#x2F;装饰前使用抽象构件声明\n\t\tTransform camaro;\n\t\tcamaro &#x3D; new Car();\n\t\tcamaro.move();\n        &#x2F;&#x2F;装饰后依然使用抽象构件声明\n\t\tTransform bumblebee;\n\t\tbumblebee &#x3D; new Robot(camaro);\n\t\tbumblebee.move();\n        &#x2F;&#x2F;装饰后依然使用抽象构件声明\n\t\tTransform plane;\n\t\tplane &#x3D; new AirPlane(camaro);\n\t\tplane.move();\n\t&#125;\n&#125;\n\n\n （七）享元模式\n 模式介绍\n\n模式动机：\n\n在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。\n例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景\n\n\n模式定义：\n\n运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。\n由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。\n细粒度的对象数量众多并且性质相近，就可以将这些对象信息分为两个部分：内部状态(intrinsic)和外部状态(extrinsic)。\n\n内部状态是对象可以共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。内部状态可以作为一个对象的动态附加信息，不必直接存储于具体某个对象中，属于可共享的部分\n外部状态是对象的特有标记，随环境改变而改变，是对象不可以共享的状态\n\n\n\n\n模式结构：\n\n角色分析：\n\n抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。\n具体享元角色（Concrete Flyweight）：实现抽象享元角色中所规定的接口。\n非享元角色（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。\n享元工厂角色（Flyweight Factory）：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象\n\n\n模型评价：\n\n优点\n\n可以减少内存中对象的数量，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能\n外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享\n\n\n缺点\n\n使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化\n为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长\n\n\n应用场景\n\n使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化\n为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长\n\n\n改进\n\n单纯享元模式：就是所有的具体享元类都是可共享的。\n复合享元模式：将纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是他们可以分解成单纯享元对象，而后者则可以共享。这样复合享元类中所包含的每个单纯享元类都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。\n享元模式和其他模式的联用\n\n享元模式的享元工厂类（就是享元池）中通常有一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。\n在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。\n如果只有一个具体构件类没有抽象构建类，那么可以将抽象装饰类作为具体构建类子类。\n享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。\n\n\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发，如图所示，现用享元模式模拟共享网络设备的设计原理。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;抽象享元角色：网络设备\npublic abstract class NetworkDevice&#123;\n\tpublic String getType();\n\tpublic void use();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体享元角色1：交换机\n&#x2F;&#x2F;Switch交换机\npublic class Switch extends NetworkDevice&#123;\n\tprivate String type;\n\tpublic Switch(String type)&#123;\n\t\tthis.type &#x3D; type;\n\t&#125;\n\tpublic String getType()&#123;\n\t\treturn this.type;\n\t&#125;\n\tpublic void use()&#123;\n\t\tSystem.out.println(&quot;Linked by switch, type is&quot; + this.type);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体享元角色2：集线器\n&#x2F;&#x2F;Hub集线器\npublic class Hub extends NetworkDevice&#123;\n\tprivate String type;\n\tpublic Hub(String type)&#123;\n\t\tthis.type &#x3D; type;\n\t&#125;\n\tpublic String getType()&#123;\n\t\treturn this.type;\n\t&#125;\n\tpublic void use()&#123;\n\t\tSystem.out.println(&quot;Linked by switch, type is&quot; + this.type);\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;享元工厂角色DeviceFactory\npublic class DeviceFactory &#123;\n\tprivate ArrayList devices &#x3D; new ArrayList();\n\tprivate int totalTerminal &#x3D; 0;\n\t\n\tpublic DeviceFactory()&#123;\n\t\tNetworkDevice nd1 &#x3D; new Switch(&quot;Cisco-WS-C2950-24&quot;);\n\t\tdevices.add(nd1);\n\t\tNetworkDevice nd2 &#x3D; new Hub(&quot;TP-LINK-HF8M&quot;);\n\t\tdevices.add(nd2);\n\t&#125;\n\n\tpublic NetworkDevice getNetworkDevice(String type)&#123;\n\t\tif(type.equalsIgnoreCase(&quot;cisco&quot;))&#123;\n\t\t\ttotalTerminal++;\n\t\t\treturn (NetworkDevice)devices.get(0);\n\t\t&#125; else if(type.equalsIgnoreCase(&quot;tp&quot;))&#123;\n\t\t\ttotalTerminal++;\n\t\t\treturn (NetworkDevice)devices.get(1);\n\t\t&#125;else&#123;\n\t\t\treturn null;\n\t\t&#125;\n\t&#125;\n\tpublic int getTotalDevice()&#123;\n\t\treturn devices.size();\n\t&#125;\t\n\tpublic int getTotalTerminal()&#123;\n\t\treturn totalTerminal;\n\t&#125;\t\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端测试代码\npublic class Client\n&#123;\n\tpublic static void main(String args[])\n\t&#123;\n\t\tNetworkDevice nd1,nd2,nd3,nd4,nd5;\n\t\tDeviceFactory df &#x3D; new DeviceFactory();\n\n\t\tnd1 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd1.use();\n\n\t\tnd2 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd2.use();\n\n\t\tnd3 &#x3D; df.getNetworkDevice(&quot;cisco&quot;);\n\t\tnd3.use();\n\n\t\tnd4 &#x3D; df.getNetworkDevice(&quot;tp&quot;);\n\t\tnd4.use();\n\n\t\tnd5 &#x3D; df.getNetworkDevice(&quot;tp&quot;);\n\t\tnd5.use();\n\n\t\tSystem.out.println(&quot;Total Device:&quot; + df.getTotalDevice());\n\t\tSystem.out.println(&quot;Total Terminal:&quot; + df.getTotalTerminal());\n\t&#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is Cisco-WS-C2950-24\n    Linked by switch, type is TP-LINK-HF8M\n    Linked by switch, type is TP-LINK-HF8M\n    Total Device:2\n    Total Terminal:5\n\n 参考文献/博客\n\n\n\n\n\n\n\n\n\n[1] 设计模式\n[2] 15分钟入门23种设计模式：图解，范例和对比\n[3] 万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解\n[4] 纸短勤常在\n[5] 小薯条学技术\n[6] 一次性搞懂设计模式–适配器模式\n[7] 27 设计模式——组合模式（详解版）\n[8] 一孔之见️\n","slug":"5-设计模式-2","date":"2023-05-08T14:06:39.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"Kevin"},{"id":"088ebac38bba3124d962899c15781d5f","title":"软件架构复习大纲","content":" 软件架构复习\n 软件体系结构概论\n\n软件危机\n构件与软件重用\n\n构件模型及实现\n构件获取\n构件管理\n\n构件描述\n构件分类与组织\n\n\n构件重用\n\n\n软件体系结构的兴起与发展\n\n软件体系结构的定义\n软件体系结构的应用现状\n\n\n\n 软件体系结构建模\n\n建模的种类\n\n结构模型\n框架模型\n动态模型\n过程模型\n功能模型\n\n\n4+1模型\n\n概述\n逻辑视图\n开发视图\n进程视图\n物理视图\n场景视图\n\n\n软件体系结构的核心模型\n软件体系结构的生命周期\n\n 软件体系结构风格\n\n软件体系结构风格的定义\n经典的软件体系结构风格\n\n管道与过滤器\n数据抽象和面向对象组织\n基于事件的隐式调用\n分层系统\n仓库系统\nC2风格\n\n\nC/S风格\n\n概述\n模型\n组成\n任务分配\n处理流程\n优点\n缺点\n\n\n三层C/S风格\n\n模型\n处理流程\n物理结构\n优点\n缺点\n\n\n三层B/S风格\n\n概述\n模型\n工作流程\n优点\n缺点\n\n\n公共对象请求代理(CORBA)\n\n概述\n特点\n体系结构\n优点\n技术规范\n\n接口定义语言（IDL）\n接口池（IR）\n动态调用接口（DII）\n对象适配器（OA）\n\n\n\n\n正交软件体系结构\n\n概述\n模型\n特点\n特征\n优点\n\n\nHMB风格\n\n系统模型概述\n构件模型\n构件接口\n消息总线\n消息过滤\n构件静态结构\n构件动态行为\n运行时刻的系统演化\n\n\n异构风格\n\n概述\n组合方式\n内外有别模型\n\n\n互连系统构成的系统\n领域特定的软件体系结构\nMVC体系结构风格\nMVVM体系结构风格\n\n 软件体系结构描述\n\n描述方法的分类\n图形表达工具\n模块内连接语言(MIL)\n基于软件体系结构描述语言ADL\nIEEE P1471标准\nRational\n\n 统一建模语言\n 可扩展标记语言\n 动态软件体系结构\n 基于服务的体系结构\n 富互联网应用体系结构\n 软件体系结构的分析与测试\n 软件体系结构的评估\n","slug":"4-软件架构复习","date":"2023-05-07T13:05:25.000Z","categories_index":"软件架构","tags_index":"软件架构","author_index":"Kevin"},{"id":"b09a4c99d2d41cfb593f51df663274d6","title":"LR分析","content":" LR分析\n 概述\n LR方法\n LR分析法\nLR分析器\n\n下推栈\n分析表\n总控程序\n\n LR(0)分析\n LR(0)分析表构造\n 基本概念\n 构造过程\n\n\n罗列所有的LR(0)项目\n\n在文法的每个产生式右部添加一个圆点，就成为G的一个LR(0)项目（简称项目）\n\n\n\n拓广文法：保证文法开始符号不出现在任何产生式右部，即增加产生式S’ -&gt; S，并令S’-&gt; •S作为初态项目\n\n\n构造DFA\n\n·后跟着非终结符的，补充非终结符的项目\n当前状态根据项目的·情况，发射对应射出弧，构造对应的状态\n重复上述过程，直到所有状态都没有新的弧为止\n\n\n\nSLR\n\n选定一个含有冲突的状态\n求出归约项的左部的follow集\n求出移进项的•后的first集的并集A\n验证follow集是否有交集B\n验证A是否属于follow集\n当B为空且A不属于follow集时，可以消除冲突\n\n以follow集为依据，遇到对应的元素作归约\n以first集为依据，遇到对应的元素作移进\n\n\n\n\n\nLR(1)\n\n由开始项目推出对应的项目集\n求推导该项目的上一步的符号后剩余符号串的first集（若没有则取上一步的搜索符），将其作为搜索符\n\n\n\n","slug":"3-LR分析","date":"2023-05-07T08:35:07.000Z","categories_index":"编译原理 - LR分析","tags_index":"编译原理","author_index":"Kevin"},{"id":"7674181de4c9b5a5cfd21fdfe784296a","title":"设计模式-1","content":" 设计模式-1\n\n\n\n\n\n\n\n\n\nAI为入门者设计的学习思路：\n\n\n先理解什么是设计模式以及它的重要性和好处。可以阅读一些设计模式概述的文章或者书籍第一章。\n了解设计模式的分类和各个类别的主要模式。比如创建型模式有工厂模式、单例模式、建造者模式;结构型模式有代理模式、外观模式、适配器模式;行为型模式有策略模式、观察者模式、模板方法模式等。\n选择几个常用和简单的设计模式开始学习,比如工厂模式、单例模式、代理模式以及观察者模式。可以阅读相关书籍的内容,并做coding实践。\n继续学习其他常用模式,比如适配器模式、装饰器模式、外观模式、模板方法模式等。同样通过理论学习和coding实践进行深入理解。\n学习了常用设计模式后,可以了解一些不太常用但也很有用的设计模式,比如桥接模式、组合模式、命令模式、迭代器模式等。\n回顾设计模式学习,理解不同设计模式之间的区别和使用场景,学习如何选择合适的设计模式。\n项目实践,在实际项目中运用适当的设计模式,解决设计问题。实践出真知,项目实践是学习设计模式的最好方式。\n保持设计模式的学习和运用,跟踪设计模式的发展和演变,不断学习新的设计模式和案例\n\n\n 一、 设计模式相关概念\n （一）设计模式的简介\n 1.简述：\n\n软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。\n\n 2.历史：\n\n1995 年，GoF（Gang of Four，四人组）合作出版了Design Patterns: Elements of Reusable Object-Oriented Software一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称【GoF设计模式】。\n\n （二）设计模式的七大原则\n\n\n\n\n\n\n\n\n\n设计模式有7大原则，目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。\n\n 1.开闭原则（Open Closed Principle，OCP）\n\n含义： 软件实体应当对扩展开放，对修改关闭\n表现：\n\n扩展时，不修改原有代码或者尽量少修改原有代码\n修改时，尽量不修改原有代码或者尽量少修改原有代码\n\n\n实现方法： 通过抽象约束、封装变化来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。\n\n 2.依赖倒置原则（Dependence Inversion Principle，DIP）\n\n含义： 要面向接口编程，不要面向实现编程, 降低类间的耦合性\n表现：\n\n高层模块不应该依赖低层模块，两者都应该依赖其抽象\n抽象不应该依赖具体类，具体类应该依赖抽象\n\n\n实现方法：\n\n使用接口或抽象类进行变量类型声明、参数类型说明、方法返回类型声明、以及数据类型的转换等\n\n在需要时，可将具体类通过依赖注入的方式注入到其他对象中\n\n\n一个具体类应只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法\n任何类都不应该从具体类派生\n使用继承时尽量遵循里氏替换原则\n\n\n\n 3.里氏代换原则（Liskov Substitution Principle，LSP）\n\n含义：所有引用基类的地方必须能 透明/不受影响 地使用其子类的对象（继承必须确保超类所拥有的性质在子类中仍然成立）\n表现：\n\n子类可以替换任何基类，而程序逻辑不变\n子类可以扩展父类的功能，但不能改变父类原有的功能（即 子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法）\n\n\n实现方法：\n\n子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法\n子类中可以增加自己特有的方法\n当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松\n当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等\n在类方法设计时，方法参数应尽量使用抽象类型（抽象类或接口）\n\n\n\n 4.合成复用原则（Composite Reuse Principle，CRP）\n\n含义：在一个新的对象里使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象委派以达到复用的目的\n表现：\n\n在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现；如果要使用继承关系，则必须严格遵循里氏替换原则\n\n\n\n 5.单一职责原则（Single Responsibility Principle，SRP）\n\n含义：规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分\n\n 6.迪米特原则（Law of Demeter，LoD）/最少知识原则（Least Knowledge Principle，LKP)\n\n含义：\n\n一个软件实体应当尽可能少地与其他实体发生相互作用\n只与你的直接朋友交谈，不跟陌生人说话\n\n迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n\n\n\n\n表现：\n\n如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用\n\n\n实现方法：\n\n在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。\n在类的结构设计上，尽量降低类成员的访问权限。\n在类的设计上，优先考虑将一个类设置成不变类。\n在对其他类的引用上，将引用其他对象的次数降到最低。\n不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。\n谨慎使用序列化（Serializable）功能。\n\n\n\n 7.接口隔离原则（Interface Segregation Principle，ISP）\n\n含义：使用多个专门的接口比使用单一的总接口要好\n表现：\n\n客户端不应该被迫依赖于它不使用的方法\n一个类对另一个类的依赖应该建立在最小的接口上\n\n\n实现方法：\n\n接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。\n为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。\n了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。\n提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n\n\n\n    \n        设计原则一句话归纳目的\n    \n    \n        开闭原则对扩展开放，对修改关闭降低维护带来的新风险\n        依赖倒置原则高层不应该依赖低层，要面向接口编程更利于代码结构的升级扩展\n        单一职责原则一个类只干一件事，实现类要单一便于理解，提高代码的可读性\n        接口隔离原则一个接口只干一件事，接口要精简单一功能解耦，高聚合、低耦合\n        迪米特法则不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度只和朋友交流，不和陌生人说话，减少代码臃肿\n        里氏替换原则不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义防止继承泛滥\n        合成复用原则尽量使用组合或者聚合关系实现代码复用，少使用继承降低代码耦合\n    \n\n （三）设计模式的类型\n\n按目的划分\n\n基本设计模式分为三大类：创建型、结构型、行为型。\n\n创建型模式：处理的是对象的创建过程（通过各种方式创建对象，使对象创建和管理变得简单）\n结构型模式：处理的是对象/类的组合\n行为型模式：处理类和对象间的交互方式和任务分布。（只有类可以创建对象，接口只能被实现）\n\n\n其他设计模式：J2EE模式\n\n\n\n\n\n    序号模式 &amp; 描述包括\n    \n        1\n        创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n        \n            \n            工厂模式（Factory Pattern）\n            抽象工厂模式（Abstract Factory Pattern）\n            单例模式（Singleton Pattern）\n            建造者模式（Builder Pattern）\n            原型模式（Prototype Pattern）\n            \n        \n    \n    \n        2\n        结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。\n        \n            \n            适配器模式（Adapter Pattern）\n            桥接模式（Bridge Pattern）\n            过滤器模式（Filter、Criteria Pattern）\n            组合模式（Composite Pattern）\n            装饰器模式（Decorator Pattern）\n            外观模式（Facade Pattern）\n            享元模式（Flyweight Pattern）\n            代理模式（Proxy Pattern）\n            \n        \n    \n    \n        3\n        行为型模式这些设计模式特别关注对象之间的通信。\n        \n            \n            责任链模式（Chain of Responsibility Pattern）\n            命令模式（Command Pattern）\n            解释器模式（Interpreter Pattern）\n            迭代器模式（Iterator Pattern）\n            中介者模式（Mediator Pattern）\n            备忘录模式（Memento Pattern）\n            观察者模式（Observer Pattern）\n            状态模式（State Pattern）\n            空对象模式（Null Object Pattern）\n            策略模式（Strategy Pattern）\n            模板模式（Template Pattern）\n            访问者模式（Visitor Pattern）\n            \n        \n    \n    \n        4\n        J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。\n        \n            \n            MVC 模式（MVC Pattern）\n            业务代表模式（Business Delegate Pattern）\n            组合实体模式（Composite Entity Pattern）\n            数据访问对象模式（Data Access Object Pattern）\n            前端控制器模式（Front Controller Pattern）\n            拦截过滤器模式（Intercepting Filter Pattern）\n            服务定位器模式（Service Locator Pattern）\n            传输对象模式（Transfer Object Pattern）\n            \n        \n    \n\n\n按作用范围划分\n\n类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器均属于该模式\n对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式\n\n\n\n 二、 创建型模式\n\n\n\n\n\n\n\n\n\n创建型模式的关注点是怎样创建对象，特点是将对象的创建与使用分离，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成\n\n工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n单例（Singleton）模式：类只能产生一个实例，保证全局使用的是同一对象。\n原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n\n （一）工厂模式\n\n\n\n\n\n\n\n\n\n工厂模式是常用的设计模式，一般分为简单工厂模式、工厂方法模式、抽象工厂模式三类。\n工厂方法模式是对简单工厂模式的推广，抽象工厂模式是对工厂方法模式的推广。\n 简单工厂模式\n\n\n\n\n\n\n\n\n\n简单工厂模式是学习其他创建型模式的基础，不属于23种GOF设计模式之一。\n 模式介绍\n\n\n模式动机：\n\n把对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的，只用告诉工厂我想要什么就行了。\n\n\n\n\n模式定义：\n\n专门定义一个类并提供静态方法来负责创建其他具有共同父类的类的实例，根据静态方法传入的参数的不同返回不同类的实例。\n专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。\n简单工厂模式也称为静态工厂方法模式（Static Factory Method Pattern），属于类创建型模式。\n\n\n\n模式结构：\n\n\n\n\n\n角色分析：\n\nFactory（工厂角色）：可提供创建产品时的静态方法\nProduct（抽象产品角色）：产品的接口，是所有产品的父类\nConcreteProduct（具体产品角色）：具体的产品实现类\n\n\n\n模式评价：\n\n优点\n\n实现了对象创建和使用的分离\n客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可\n通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性\n\n\n缺点\n\n新增产品需要修改工厂类的代码，违反了开闭原则\n工厂类需要负责创建所有产品，如果产品类型过多，工厂类的代码会变得过于复杂\n由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展\n\n\n应用场景\n\n当需要创建的对象具有相同的行为和属性时，可以使用简单工厂模式\n当一个类不知道它所需要的对象的类时，可以使用简单工厂模式，将创建对象的职责交给工厂类处理\n当需要在客户端中动态地根据条件创建不同的对象时，可以使用简单工厂模式\n\n\n改进\n\n当系统中需要创建的具体产品类不断增多时，使用简单工厂模式会导致工厂类变得过于复杂，此时可以考虑使用工厂方法模式或者抽象工厂模式来解决问题，这两种方法根据系统的具体情况来确定，其中抽象工厂模式是更好的选择\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F; 核心思路\n&#x2F;&#x2F; 抽象产品类\ninterface Product &#123;\n    void operation();\n&#125;\n\n&#x2F;&#x2F; 具体产品类A\nclass ConcreteProductA implements Product &#123;\n    public void operation() &#123;\n        System.out.println(&quot;This is ConcreteProductA.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 具体产品类B\nclass ConcreteProductB implements Product &#123;\n    public void operation() &#123;\n        System.out.println(&quot;This is ConcreteProductB.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 工厂类\nclass Factory &#123;\n    public static Product createProduct(String type) &#123;\n        if (type.equals(&quot;A&quot;)) &#123;\n            return new ConcreteProductA();\n        &#125; else if (type.equals(&quot;B&quot;)) &#123;\n            return new ConcreteProductB();\n        &#125; else &#123;\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 客户端\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Product productA &#x3D; Factory.createProduct(&quot;A&quot;);\n        Product productB &#x3D; Factory.createProduct(&quot;B&quot;);\n        productA.operation();\n        productB.operation();\n    &#125;\n&#125;\n&#x2F;&#x2F; 具体例子（此处采用具体类作产品父类，可改用接口作产品父类）\n&#x2F;&#x2F; Factory.java\n&#x2F;**\n * @Theme:工厂类\n * @Description:水果工厂\n *&#x2F;\npublic class Factory &#123;\n    public static Fruit createFruit(String type)&#123;\n        if(&quot;Pear&quot;.equals(type))&#123;\n            System.out.println(&quot;正在创建---------梨&quot;);\n            Pear pear &#x3D; new Pear();\n            pear.name &#x3D; &quot;梨&quot;;\n            pear.color &#x3D; &quot;黄色&quot;;\n            return pear;\n        &#125;else if(&quot;Apple&quot;.equals(type))&#123;\n            System.out.println(&quot;正在创建---------苹果&quot;);\n            Apple apple &#x3D; new Apple();\n            apple.name &#x3D; &quot;苹果&quot;;\n            apple.color &#x3D; &quot;红色&quot;;\n            return apple;\n        &#125;else &#123;\n            System.out.println(&quot;正在创建---------&quot;+type);\n            System.out.println(&quot;该工厂无法创建该产品：&quot;+type);\n            return null;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Fruit.java\n&#x2F;**\n * @Theme:抽象产品类\n * @Description:水果类\n *&#x2F;\npublic class Fruit &#123;\n    public String name;\n    public String color;\n    public void eat()&#123;\n        System.out.println(&quot;----------吃完啦----------&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Pear.java\n&#x2F;**\n * @Theme:具体产品类\n * @Description:具体产品-梨\n *&#x2F;\npublic class Pear extends Fruit &#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(this.name+&quot;正在被吃······&quot;);\n        super.eat();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;NAME:&quot;+this.name+&quot;----COLOR:&quot;+this.color;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Apple.java\n&#x2F;**\n * @Theme: 具体产品类\n * @Description: 具体产品-苹果\n *&#x2F;\npublic class Apple extends Fruit&#123;\n    @Override\n    public void eat() &#123;\n        System.out.println(this.name+&quot;正在被吃······&quot;);\n        super.eat();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;NAME:&quot;+this.name+&quot;----COLOR:&quot;+this.color;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Client.java\n\n&#x2F;**\n * @Theme: 客户端\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;现在想让该水果工厂给我生产水果给我吃\n\n        &#x2F;&#x2F;1.吃苹果\n        Fruit fruit;\n        fruit &#x3D; Factory.createFruit(&quot;Apple&quot;);\n        System.out.println(fruit.toString());\n        fruit.eat();\n\n        &#x2F;&#x2F;1.吃梨\n        fruit &#x3D; Factory.createFruit(&quot;Pear&quot;);\n        System.out.println(fruit.toString());\n        fruit.eat();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 运行结果\n\n    正在创建---------苹果\n    NAME:苹果----COLOR:红色\n    苹果正在被吃······\n    ----------吃完啦----------\n    正在创建---------梨\n    NAME:梨----COLOR:黄色\n    梨正在被吃······\n    ----------吃完啦----------\n 工厂方法模式\n 模式介绍\n\n\n模式动机：\n\n在不修改已有具体工厂类的情况下引进新的产品，即满足开闭原则的要求\n\n\n\n模式定义：\n\n定义一个用于创建对象的接口，可让子类去决定将哪一个类进行实例化\n将产品类的实例化过程延迟到工厂子类完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类\n工厂方法模式简称工厂模式，又可称虚拟构造器或者多态工厂模式，属于类创建型模式\n\n\n\n模式结构：\n\n\n\n\n\n角色分析：\n\n抽象产品Product：定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类\n具体产品ConcreteProduct：实现抽象产品所定义的接口，负责具体产品的业务逻辑\n抽象工厂Factory：定义工厂的接口，是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口\n具体工厂ConcreteFactory：实现抽象工厂定义的接口，负责实例化具体的产品对象\n\n\n\n模式评价：\n\n优点\n\n封装对象的创建过程：工厂模式将对象的创建过程封装到工厂类中，避免了客户端直接依赖具体的产品类，从而提高了代码的可维护性和可扩展性。\n创建多个产品族或产品等级结构：当需要创建多个产品族或产品等级结构时，工厂模式可以提供一个统一的接口，方便客户端进行调用。\n符合开闭原则：当需要添加新的产品时，只需要增加相应的产品类和工厂方法即可，不需要修改原有的代码，符合开闭原则。\n\n\n缺点\n\n产品等级结构复杂时，会有大量的与之对应的工厂类，增加了系统的复杂度\n增加了系统的抽象性和理解难度\n\n\n应用场景\n\n需要创建多个产品族或产品等级结构：当需要创建多个产品族或产品等级结构时，工厂模式可以提供一个统一的接口，方便客户端进行调用。\n需要封装对象的创建过程：当对象的创建过程比较复杂，或者需要依赖其他类的时候，可以使用工厂模式来封装对象的创建过程。\n需要动态切换产品：当需要动态切换产品时，工厂模式可以提供一个统一的接口，方便客户端进行调用。\n\n\n改进\n\n当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;某系统运行日志记录器(Logger)可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。\n&#x2F;&#x2F;为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;LoggerFactory.java\n\n&#x2F;**\n * @Theme:抽象工厂接口\n * @Description:包含一个抽象工厂方法\n *&#x2F;\npublic interface LoggerFactory &#123;\n    &#x2F;&#x2F;工厂方法\n    Logger createLogger();\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;FileLoggerFactory.java\n\n&#x2F;**\n * @Theme: 文件日志器记录器工厂\n * @Description:\n *&#x2F;\npublic class FileLoggerFactory implements LoggerFactory&#123;\n    @Override\n    public Logger createLogger() &#123;\n        System.out.println(&quot;-----正在创建文件日志记录器----&quot;);\n        return new FileLogger();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;DatabaseLoggerFactory.java\n\n&#x2F;**\n * @Theme: 数据库日志器记录器工厂\n * @Description:\n *&#x2F;\npublic class DataBaseLoggerFactory implements LoggerFactory&#123;\n    @Override\n    public Logger createLogger() &#123;\n        System.out.println(&quot;-----正在创建数据库日志记录器----&quot;);\n        return new DataBaseLogger();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Logger.java\n\n&#x2F;**\n * @Theme: 抽象产品接口\n * @Description: 包含一个写日志方法抽象方法\n *&#x2F;\npublic interface Logger &#123;\n    void writeLog();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;FileLogger.java\n\n&#x2F;**\n * @Theme: 文件日志记录器\n * @Description:\n *&#x2F;\npublic class FileLogger implements Logger &#123;\n    @Override\n    public void writeLog() &#123;\n        System.out.println(&quot;正在使用文件日志记录器记录日志&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;DataBaseLogger.java\n\n&#x2F;**\n * @Theme: 数据库日志记录器\n * @Description:\n *&#x2F;\npublic class DataBaseLogger implements Logger&#123;\n    @Override\n    public void writeLog() &#123;\n        System.out.println(&quot;正在使用数据库日志记录器记录日志&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Client.java\n\n&#x2F;**\n * @Theme: 客户端类\n * @Description: 测试\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        LoggerFactory factory;\n        Logger logger;\n\n        &#x2F;&#x2F;创建工厂类,并强制转换\n        factory &#x3D; (LoggerFactory)XMLUtil.getBean();\n\n        &#x2F;&#x2F;调用工厂方法，创建产品对象\n        logger &#x3D; factory.createLogger();\n\n        &#x2F;&#x2F;调用日志记录方法\n        logger.writeLog();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;XMLUtil.java\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.File;\n\n&#x2F;**\n * @Theme: 配置文件+反射实现 对象生成\n * @Description:工具类\n *&#x2F;\npublic class XMLUtil &#123;\n    &#x2F;&#x2F;该方法用于从XML配置文件中提取类的类型，并创建对象\n    public static Object getBean()&#123;\n        try &#123;\n            &#x2F;&#x2F;创建文档对象\n            DocumentBuilderFactory dFactory &#x3D; DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder &#x3D; dFactory.newDocumentBuilder();\n            Document doc;\n            doc &#x3D; builder.parse(new File(&quot;&#x2F;config.xml&quot;));\n\n            &#x2F;&#x2F;获取类名的文本节点\n            NodeList nl &#x3D; doc.getElementsByTagName(&quot;className&quot;);\n            Node classNode &#x3D; nl.item(0).getFirstChild();\n            String className &#x3D; classNode.getNodeValue().trim();\n\n            &#x2F;&#x2F;通过类名生成实例对象并返回\n            Class c &#x3D; Class.forName(className);\n            Object o &#x3D; c.newInstance();\n            return o;\n        &#125;\n        catch(Exception e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;config.xml\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;config&gt;\n    &lt;className&gt;FileLoggerFactory&lt;&#x2F;className&gt;\n&lt;&#x2F;config&gt;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n\n    -----正在创建文件日志记录器----\n    正在使用文件日志记录器记录日志\n （二）抽象工厂模式\n\n\n\n\n\n\n\n\n\n\n产品等级结构也就是产品的继承结构——产品等级结构中的产品是从属关系，也就是说某一个产品是由某一个产品衍生出来的\n产品族是指同一个工厂生产的，位于不同产品等级结构中的一组产品——产品族中的产品是平行关系\n从产品等级结构和产品族看工厂\n\n\n\n工厂方法模式\n​    :每个具体工厂只有一个或者一组重载的工厂方法们，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必增加系统的开销。\n\n\n\n\n\n\n\n\n\n\n\n抽象工厂模式\n:一个工厂可以生产一系列产品（一族产品），极大地减少了工厂类的数量\n\n\n在工厂方法模式中，我们只需要实现一个工厂方法，它负责创建一个特定类型的对象。而在抽象工厂模式中，我们需要实现一个工厂接口，它负责创建一组相关的对象。\n\n\n 模式介绍\n\n模式动机：\n\n抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品\n当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率\n抽象工厂模式的主要用途是创建一组相关的对象，它在多个对象之间存在一系列的约束，抽象工厂模式将这些约束条件统一到一个接口中，使得在调用方不需要关心具体的约束条件\n\n\n\n模式定义：\n\n提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类\n抽象工厂模式又称为Kit模式，属于对象创建型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n抽象工厂AbstactFactory:提供了创建产品的接口，它包含多个创建产品的方法createProduct()\n具体工厂ConcreteFactory:实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中\n抽象产品AbstractProduct:为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法\n具体产品ConcreteProduct:定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法\n\n\n模式评价：\n\n优点\n\n可以封装一组相关对象的创建逻辑，从而提高代码的可维护性和可扩展性。\n可以帮助客户端代码与具体类的解耦，从而提高代码的灵活性和可移植性。\n可以通过工厂的切换来实现对不同平台或不同产品系列/族的支持，同时又不会对客户端代码造成影响\n\n\n缺点\n\n在新增产品等级结构时，需要修改工厂接口及所有具体工厂类的实现，从而增加了代码的维护成本。\n\n\n应用场景\n\n抽象工厂模式通常在需要支持多种产品系列、动态切换产品系列或稳定不变的产品族和产品等级结构的场景中被使用。\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节\n系统中有多于一个的产品族，但每次只使用其中某一产品族\n属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来\n产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象工厂接口\ninterface GUIFactory &#123;\n    Button createButton();\n    TextBox createTextBox();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 具体工厂类 - Windows工厂\nclass WinFactory implements GUIFactory &#123;\n    public Button createButton() &#123;\n        return new WinButton();\n    &#125;\n\n    public TextBox createTextBox() &#123;\n        return new WinTextBox();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 具体工厂类 - Mac工厂\nclass MacFactory implements GUIFactory &#123;\n    public Button createButton() &#123;\n        return new MacButton();\n    &#125;\n\n    public TextBox createTextBox() &#123;\n        return new MacTextBox();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象按钮类\nabstract class Button &#123;\n    public abstract void paint();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 抽象文本框类\nabstract class TextBox &#123;\n    public abstract void paint();\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Windows按钮类\nclass WinButton extends Button &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Windows按钮&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Windows文本框类\nclass WinTextBox extends TextBox &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Windows文本框&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Mac按钮类\nclass MacButton extends Button &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Mac按钮&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Mac文本框类\nclass MacTextBox extends TextBox &#123;\n    public void paint() &#123;\n        System.out.println(&quot;Mac文本框&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\npublic class client&#123;\n    public static void main(String []args)&#123;\n        GUIFactory factory1 &#x3D; new WinFactory();\n        Button button1 &#x3D; factory1.createButton();\n        TextBox textBox1 &#x3D; factory1.createTextBox();\n        button1.paint();\n        textBox1.paint();\n        \n        GUIFactory factory2 &#x3D; new MacFactory();\n        Button button2 &#x3D; factory2.createButton();\n        TextBox textBox2 &#x3D; factory2.createTextBox();\n        button2.paint();\n        textBox2.paint();\n        \n    &#125;\n&#125;\n&#x2F;&#x2F;结果\n        Windows按钮\n        Windows文本框\n        Mac按钮\n        Mac文本框\n （三）单例模式\n\n\n\n\n\n\n\n\n\n单例模式是一种对象创建型模式，单例模式又称为单件模式或单态模式\n 模式介绍\n\n模式动机：\n\n确保一个类只能创建一个实例，并提供一种全局访问这个实例的方式\n在单例类的外部无法使用运算符new创建，否则该类的对象就不是单例\n\n\n模式定义：\n\n确保一个类只有一个实例，并提供一个全局的访问点来访问这个唯一的实例\n单例模式属于对象创建型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\n单例Singleton：负责保存自己的唯一实例，并提供给外部访问该实例的方法\n\n提供一个自身类型的静态私有成员变量instance，用于保存自身的唯一实例\n构造函数私有化，以确保外部无法通过构造函数创建自身的实例\n提供一个公有的静态工厂方法getInstance()，用于获取自身的唯一实例\n\n如果instance为null，则创建自身的唯一实例并返回\n如果instance不为null，则直接返回instance\n\n\n\n\n\n\n模式评价：\n\n优点\n\n提供了对唯一实例的受控访问\n可以节约系统资源，提高系统的性能\n允许可变数目的实例（多例类）\n\n\n缺点\n\n扩展困难（缺少抽象层）\n单例类的职责过重\n由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失\n\n\n应用场景\n\n在需要确保全局只有一个实例的场景中使用\n\n线程池：在多线程环境下，线程池需要保证只有一个实例。\n数据库连接池：同样地，数据库连接池也需要保证只有一个实例。\n日志对象：日志对象通常是全局可见的，因此需要保证只有一个实例。\n配置文件：在某些情况下，需要全局共享的配置文件也需要保证只有一个实例。\n\n\n系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象\n客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例\n\n\n改进\n\n线程安全性：如上所述，如果多个线程同时访问getInstance()方法，可能会导致多个实例的创建。因此，需要确保getInstance()方法是线程安全的，可以通过synchronized关键字来实现。\n序列化问题：如果单例类实现了Serializable接口，那么在反序列化时可能会创建多个实例。解决方法是在类中添加readResolve()方法，并返回单例实例。\n反射问题：通过反射机制，可以调用私有构造函数创建实例。解决方法是在构造函数中添加判断，如果已经存在实例则抛出异常\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;1懒汉式单例模式\n&#x2F;&#x2F;懒汉式单例模式指的是在第一次使用单例对象时才创建实例。\n&#x2F;&#x2F;具体实现方式是在getInstance()方法中判断实例是否已经被创建，如果没有则创建一个新实例并返回。\n**懒汉式单例模式的缺点是线程不安全，在多线程环境下可能会创建多个实例。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Singleton instance;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;2饿汉式单例模式\n&#x2F;&#x2F;饿汉式单例模式指的是在类加载时就创建实例，而不管是否需要使用该实例。\n&#x2F;&#x2F;具体实现方式是在类加载时就创建实例，并使用静态私有成员变量保存唯一实例。\n&#x2F;&#x2F;由于在类加载时就创建了实例，因此不存在线程安全性问题。\n**饿汉式单例模式的缺点是在类加载时就创建实例，如果该实例在整个系统中都没有被使用过，则会造成内存的浪费。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; new Singleton();\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;3双重检验锁懒汉式单例模式\n&#x2F;&#x2F;双重检验锁单例模式是一种线程安全的单例模式实现方式，它通过使用synchronized关键字来确保线程安全性。\n&#x2F;&#x2F;具体实现方式是在getInstance()方法中添加双重检验锁，这可以避免不必要的锁竞争和实例化。\n&#x2F;&#x2F;使用双重检查锁定需要在静态成员变量前加上volatile关键字，是为了取消虚拟机所做的一些代码优化，并且只能在JDK1.5上面执行。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123; \n    private volatile static Singleton instance &#x3D; null; \n    private Singleton() &#123; &#125; \n    public static Singleton getInstance() &#123; \n        &#x2F;&#x2F;第一重判断\n        if (instance &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F;锁定代码块\n            synchronized (Singleton.class) &#123;\n                &#x2F;&#x2F;第二重判断\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton(); &#x2F;&#x2F;创建单例实例\n                &#125;\n            &#125;\n        &#125;\n        return instance; \n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;4静态内部类单例模式\n&#x2F;&#x2F;静态内部类单例模式是一种线程安全的单例模式实现方式，它通过使用静态内部类和类的初始化来保证线程安全性。\n&#x2F;&#x2F;静态内部类单例模式是利用了静态内部类只会在被使用时才会加载的特点，避免了饿汉式单例模式的资源浪费和懒汉式单例模式的线程不安全问题。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static class SingletonHolder &#123;\n        private static final Singleton INSTANCE &#x3D; new Singleton();\n    &#125;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return SingletonHolder.INSTANCE;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;5枚举单例模式\n&#x2F;&#x2F;枚举单例模式是一种更为简单和安全的单例模式实现方式，它利用了Java中枚举类型本身就是单例的特点。\n&#x2F;&#x2F;枚举单例模式是一种天然线程安全的单例模式实现方式，而且可以防止反射和序列化等攻击。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic enum Singleton &#123;\n    INSTANCE;\n    \n    &#x2F;&#x2F; 其他方法\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;6ThreadLocal单例模式\n&#x2F;&#x2F;ThreadLocal单例模式是一种可以在多线程环境下确保单例对象的线程安全单例模式实现方式。\n&#x2F;&#x2F;具体实现方式是在ThreadLocal中保存单例对象，每个线程都有自己的ThreadLocal副本，从而避免了线程安全性问题。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static final ThreadLocal&lt;Singleton&gt; INSTANCE &#x3D; new ThreadLocal&lt;Singleton&gt;() &#123;\n        @Override\n        protected Singleton initialValue() &#123;\n            return new Singleton();\n        &#125;\n    &#125;;\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance() &#123;\n        return INSTANCE.get();\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;7注册式单例模式\n&#x2F;&#x2F;注册式单例模式指的是通过一个注册表来管理所有单例对象，从而实现单例模式。\n&#x2F;&#x2F;具体实现方式是在一个静态的Map中保存所有单例对象，然后在需要使用单例对象时通过Map来获取。\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\npublic class Singleton &#123;\n    private static Map&lt;String, Singleton&gt; instances &#x3D; new HashMap&lt;&gt;();\n    \n    private Singleton() &#123;\n        &#x2F;&#x2F; 私有构造函数\n    &#125;\n    \n    public static Singleton getInstance(String name) &#123;\n        if (!instances.containsKey(name)) &#123;\n            instances.put(name, new Singleton());\n        &#125;\n        return instances.get(name);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;具体例子：\nimport java.sql.Connection;\nimport java.sql.DriverManager;\n \npublic class DBHelper &#123;\n\t\n\tprivate static final String driver &#x3D; &quot;com.mysql.jdbc.Driver&quot;;&#x2F;&#x2F;数据库驱动\n\tprivate static final String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gumysql?useUnicon&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;;\n\tprivate static final String username &#x3D; &quot;root&quot;;\n\tprivate static final String password &#x3D; &quot;root&quot;;\n\t\n\tstatic\n\t&#123;\n\t\ttry \n\t\t&#123;\n\t\t\tClass.forName(driver);\n\t\t&#125;\n\t\tcatch (Exception e)\n\t\t&#123;\n\t\t\t\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n\t\n\tprivate static Connection conn &#x3D; null;\n\t&#x2F;&#x2F;单例模式返回数据库连接\n\tpublic static Connection getConnection() throws Exception\n\t&#123;\n\t\tif(conn &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tconn &#x3D; DriverManager.getConnection(url, username, password);\n\t\t\treturn conn;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn conn;\n\t\t&#125;\n\t&#125;\n&#125;\n （四）建造者模式\n 模式介绍\n\n\n模式动机：\n\n主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n\n\n\n模式定义：\n\n将一个复杂对象的构建与它的表示相分离，使得同样的构建过程可以创建不同的表示\n建造者模式通过将复杂对象的构建过程分解为多个简单的步骤来实现\n建造者模式属于对象创建型模式\n\n\n\n模式结构：\n\n\n\n角色分析：\n\n抽象建造者Builder：为创建一个产品对象的各个部件指定抽象接口和返回完整产品的抽象方法\n具体建造者ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口\n产品Product：表示被构造的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口\n指挥者Director：构造一个使用Builder接口的对象，指导构建过程，包含一个建造者的成员变量，用于指导建造过程，如何创建一个完整的产品对象\n\n\n\n模式评价：\n\n优点\n\n客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象\n可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则\n可以更容易地控制对象的创建过程，同时使得代码更易于维护和扩展\n\n\n缺点\n\n建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制\n如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本\n\n\n应用场景\n\n当需要创建多个相似对象时，例如使用相同的构建过程创建不同的表示。\n当创建一个对象需要多个步骤时，例如需要设置多个属性或调用多个方法。\n当需要在不同的上下文中创建不同的对象表示时，例如根据用户的选择创建不同的表示。\n当需要控制对象的创建过程，并且希望代码易于维护和扩展时。\n\n\n改进\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子\n&#x2F;&#x2F;假设我们正在构建一个游戏，游戏中有多种类型的角色，每种角色都有不同的属性和装备。为了避免在创建每个角色时重复的代码，我们可以使用建造者模式。\n&#x2F;&#x2F;Actor角色类:复合产品\nclass Actor &#123;\n    private String type;\n    private String sex;\n    private String skill;\n\n    &#x2F;&#x2F;Getter and Setter: 略\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;角色建造器:抽象建造者\nabstract class ActorBuilder &#123;\n    protected Actor actor &#x3D; new Actor();\n\n    public abstract void buildType();\n    public abstract void buildSex();\n    public abstract void buildSkill();\n\n    public Actor createActor()&#123;\n        return actor;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;吸血鬼建造器:具体建造者\nclass VampireBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;吸血鬼&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;男&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;吸血&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;狼人建造器:具体建造者\nclass WerewolfBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;狼人&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;男&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;撕咬&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;女巫建造器:具体建造者\nclass WitchBuilder extends ActorBuilder&#123;\n\n    @Override\n    public void buildType() &#123;\n        actor.setType(&quot;女巫&quot;);\n    &#125;\n\n    @Override\n    public void buildSex() &#123;\n        actor.setSex(&quot;女&quot;);\n    &#125;\n\n    @Override\n    public void buildSkill() &#123;\n        actor.setSkill(&quot;魔法&quot;);\n    &#125;\n&#125;\n&#x2F;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;Actor角色创建控制器:指挥者\nclass ActorController &#123;\n    public Actor construct(ActorBuilder ab)&#123;\n        Actor actor;\n        ab.buildType();\n        ab.buildSex();\n        ab.buildSkill();\n        actor &#x3D; ab.createActor();\n        return actor;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;客户端\nclass Client &#123;\n    public static void main(String[] args) &#123;\n        ActorController ac &#x3D; new ActorController();\n        \n        ActorBuilder ab &#x3D; new VampireBuilder();\n        Actor vampire &#x3D; ac.construct(ab);\n        System.out.println(vampire.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+vampire.getSex());\n        System.out.println(&quot;技能:&quot;+vampire.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n        \n        ActorBuilder ab2 &#x3D; new WerewolfBuilder();\n        Actor werewolf &#x3D; ac.construct(ab2);\n        System.out.println(werewolf.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+werewolf.getSex());\n        System.out.println(&quot;技能:&quot;+werewolf.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n        \n        ActorBuilder ab3 &#x3D; new WitchBuilder();\n        Actor witch &#x3D; ac.construct(ab3);\n        System.out.println(witch.getType()+&quot;的游戏设定:&quot;);\n        System.out.println(&quot;性别:&quot;+witch.getSex());\n        System.out.println(&quot;技能:&quot;+witch.getSkill());\n        System.out.println(&quot;---------------------------&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    吸血鬼的游戏设定:\n    性别:男\n    技能:吸血\n    ---------------------------\n    狼人的游戏设定:\n    性别:男\n    技能:撕咬\n    ---------------------------\n    女巫的游戏设定:\n    性别:女\n    技能:魔法\n    ---------------------------\n （五）原型模式\n 模式介绍\n\n模式动机：\n\n原型模式通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。\n\n\n模式定义：\n\n使用原型对象实例指定待创建的对象的类型，并且通过复制这个原型来创建新的对象\n属于对象创建型模式\n\n\n模式结构：\n\n\n\n\n角色分析：\n\nPrototype 抽象原型类：规定了具体原型对象必须实现的接口clone()\nConcretePrototype 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象\nClient 客户类：让一个原型对象克隆自身从而创建一个新的对象\n\n\n模式评价：\n\n优点：\n\n原型模式允许在运行时动态改变具体的实现类型\n原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了\n原型模式配合多线程使用时，要注意线程安全问题\n\n\n缺点：\n\n需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”\n在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦\n\n\n应用场景\n\n创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改\n系统要保存对象的状态，而对象的状态变化很小\n需要避免使用分层次的工厂类来创建分层次的对象\n\n\n\n\n深克隆与浅克隆\n\n浅克隆\n\n当原型对象被复制时，只是复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制\n\n\n\n深克隆\n\n除了对象本身被复制外，对象所包含的所有成员变量也将被复制\n\n\n\n\n\n\n 模式实现\n\njava实现\n\n&#x2F;&#x2F;具体例子-浅克隆\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 照片类\n * @Description:\n *&#x2F;\npublic class Photo &#123;\n    &#x2F;&#x2F;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 简历类\n * @Description:\n *&#x2F;\npublic class Resume implements Cloneable&#123;\n    private Photo photo;&#x2F;&#x2F;照片\n\n    public Photo getPhoto() &#123;\n        return photo;\n    &#125;\n\n    public void setPhoto(Photo photo) &#123;\n        this.photo &#x3D; photo;\n    &#125;\n\n    &#x2F;&#x2F;使用clone()方法来实现浅克隆\n    public Resume clone()&#123;\n        Object o &#x3D; null;\n        try &#123;\n            o &#x3D; super.clone();\n            return (Resume) o;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            System.out.println(&quot;不支持复制&quot;);\n            e.printStackTrace();\n        &#125;\n\n        return null;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Resume  previousResume,newResume;\n\n        previousResume &#x3D; new Resume();\n        &#x2F;&#x2F;添加照片\n        Photo photo &#x3D; new Photo();\n        previousResume.setPhoto(photo);\n\n        &#x2F;&#x2F;开始复制\n        newResume &#x3D; previousResume.clone();\n\n        &#x2F;&#x2F;比较简历\n        System.out.println(&quot;简历是否相同？&quot; + (previousResume &#x3D;&#x3D; newResume));\n        &#x2F;&#x2F;比较照片\n        System.out.println(&quot;照片是否相同（是：直接引用原照片|否：新照片）？&quot; + (previousResume.getPhoto() &#x3D;&#x3D; newResume.getPhoto()));\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    简历是否相同？false\n    照片是否相同（是：直接引用原照片|否：新照片）？true\n&#x2F;&#x2F;具体例子-深克隆\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 照片类\n * @Description:\n *&#x2F;\npublic class Photo &#123;\n    &#x2F;&#x2F;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme: 简历类\n * @Description:\n *&#x2F;\nimport java.io.*;\n\npublic class Resume  implements Serializable &#123;\n    private Photo photo;&#x2F;&#x2F;照片\n\n    public Photo getPhoto() &#123;\n        return photo;\n    &#125;\n\n    public void setPhoto(Photo photo) &#123;\n        this.photo &#x3D; photo;\n    &#125;\n\n\n    &#x2F;&#x2F;实现深克隆\n    public Resume deepClone() throws IOException, ClassNotFoundException &#123;\n\n        &#x2F;&#x2F;1.将对象写到流\n        ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bao);\n        oos.writeObject(this);\n        &#x2F;&#x2F;将对象从流中取出\n        ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bao.toByteArray());\n        ObjectInputStream ois &#x3D; new ObjectInputStream(bis);\n        return (Resume) ois.readObject();\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;**\n * @Theme:\n * @Description:\n *&#x2F;\nimport java.io.IOException;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        Resume previousResume,newResume;\n\n        previousResume &#x3D; new Resume();\n        &#x2F;&#x2F;添加照片\n        Photo photo &#x3D; new Photo();\n        previousResume.setPhoto(photo);\n\n        &#x2F;&#x2F;开始复制\n        try &#123;\n            newResume &#x3D; previousResume.deepClone();\n        &#125; catch (Exception e) &#123;\n            System.out.println(&quot;克隆失败&quot;);\n        &#125;\n\n        &#x2F;&#x2F;比较简历\n        System.out.println(&quot;简历是否相同？&quot; + (previousResume &#x3D;&#x3D; newResume));\n        &#x2F;&#x2F;比较照片\n        System.out.println(&quot;照片是否相同（是：直接引用原照片|否：新照片）？&quot; + (previousResume.getPhoto() &#x3D;&#x3D; newResume.getPhoto()));\n\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;运行结果\n    简历是否相同？false\n    照片是否相同（是：直接引用原照片|否：新照片）？false\n\n 参考文献/博客\n\n\n\n\n\n\n\n\n\n[1] 设计模式\n[2] 15分钟入门23种设计模式：图解，范例和对比\n[3] 万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解\n[4] 纸短勤常在\n[5] 小薯条学技术\n","slug":"2-设计模式-1","date":"2023-05-06T12:38:18.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"Kevin"},{"id":"0957f802a029d0594b09e3b585318be7","title":"软件架构实验","content":" 软件架构实验\n 题目1\n\n\n\n\n\n\n\n\n\n使用原始socket()实现一个C/S架构的应用，支持服务器时间回显示\n\n要求：从客户端发送命令，接收服务器的时间并显示到终端\n\n 相关原理\n C/S结构\n socket\n python实现\n\n\n环境：python3.9.13\n\n\n编辑器：vscode\n\n\n终端：powershell/Windows terminal\n\n\n服务器端\n\n\nimport socket\nimport time\n# 主机地址\nhost &#x3D; &#39;localhost&#39;\n# 端口号\nport &#x3D; 8888\n# 接收数据的最大字节数\ndata_payload &#x3D; 2048\n# 最大连接数\nbacklog &#x3D; 5\n\ndef server():\n    # 定义IP地址和端口号\n    server_address &#x3D; (host, port)\n    # 创建一个TCP套接字\n    sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)  \n    # 绑定IP地址和端口号\n    sock.bind(server_address)\n    print(&quot;正在开启服务端&quot;)\n    # 监听客户端连接请求，backlog指定最大连接数\n    sock.listen(backlog)  \n    print(&quot;等待客户端连接...&quot;)\n    # 接收客户端连接请求，返回一个新的套接字和客户端地址，阻塞函数，直到有客户端连接才会返回\n    # 创建了一个新的通道并获得了客户端的IP地址\n    client, client_address &#x3D; sock.accept()  \n    \n    while True:\n        # 接收客户端发送的数据并解码\n        client_data &#x3D; client.recv(data_payload).decode() \n        # 如果客户端发送的数据为exit或者为空，则退出 \n        if client_data &#x3D;&#x3D; &quot;exit&quot;:\n            exit(&quot;客户端连接关闭&quot;)\n        print(&quot;接收到客户端数据： %s&quot; % client_data)\n        # 设置变量currentTime来获取系统的当前时间\n        currentTime &#x3D; time.ctime() + &quot;\\r\\n&quot;\n        print(currentTime)\n        # 将当前时间字符串进行编码后发送给客户端\n        client.sendall(currentTime.encode())\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    server()\n\n客户端\n\nimport socket\n \nhost &#x3D; &#39;localhost&#39;\nport &#x3D; 8888\ndata_payload &#x3D; 2048\n \ndef client():\n    server_address &#x3D; (host , port)\n    sock &#x3D; socket.socket(socket.AF_INET , socket.SOCK_STREAM)\n    # 连接服务端\n    sock.connect(server_address)\n    print(&quot;连接服务端 %s %s&quot; %server_address)# %server_address是一个包含两个参数的元组，需要两个%s来对应 \n    while True:\n        data&#x3D; input(&quot;请输入要发送的数据：&quot;).strip()\n        if not data:\n            continue\n        # 发送数据给服务端\n        sock.sendall(data.encode())  \n        # 如果发送的数据为exit，则退出\n        if data&#x3D;&#x3D;&quot;exit&quot;:\n            print(&quot;已退出客户端&quot;)\n            break\n        # 接收服务端返回的数据\n        reply&#x3D;sock.recv(2048).decode()\n        print(&quot;接收到服务端数据：%s&quot; %reply)\n    sock.close()\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:  \n    client()\n\n终端测试结果\n\n# 开启服务器端\npython server.py\n# 开启客户端\npython client.py\n# 测试连接\ntest\ntest2\ntest3\n# 退出客户端，关闭连接\nexit\n\n\n\n Java实现\n 参考文章\n\n\n\n\n\n\n\n\n\npython网络编程\n\n\njava网络编程\n\n\n 题目2\n\n\n\n\n\n\n\n\n\n使用epoll方式实现一个C/S架构的应用\n\n要求：服务器同时支持多个客户端连接，一个客户端发送消息，服务器转发到其他客户端并回显消息\n\n 相关原理\n C/S结构\n socket\n\n\n\n\n\n\n\n\n\nwsl2·Ubuntu18.04+vscode+pip+venv配置python3环境\n\nwsl2安装\nUbuntu18.04安装\nvscode配置\nvscode开启远程连接\n更换python版本为3.8\n\n\n安装libpython3.8\n安装python3.8\n切换默认版本为python3.8\n\n\n\n\n\n\n\n\n\n\n\npip安装\n\n\n卸载旧的pip\n安装新的pip\n\n\n\n\n\n\n\n\n\n\n\nvenv新建虚拟环境\n\n\n建立软链接：sudo ln -s apt_pkg.cpython-36m-x86_64-linux-gnu.so apt_pkg.so\n安装3.8的venv：sudo apt-get install python3.8-venv\n\n\n\n\n\n\n\n\n\n\n\npython3环境配置\n创建项目并激活虚拟环境\n运行项目\n\n python实现\n\n服务端\n\n# 测试命令：\n# python server.py\n# python client.py\n# 测试数据：\n# 123\n# 789\n# 我我我\n# 你你你\n# 通天塔\n\nimport socket\nimport threading\n\nSERVER_HOST &#x3D; &#39;localhost&#39;\nSERVER_PORT &#x3D; 8000\nBUFFER_SIZE &#x3D; 1024\n\ndef handle_client(client_socket, client_address, clients):\n    &quot;&quot;&quot;\n    处理客户端连接的线程函数\n    &quot;&quot;&quot;\n    print(&#39;连接新的客户端： &#123;&#125;:&#123;&#125;&#39;.format(client_address[0], client_address[1]))\n\n    # 将新的客户端添加到客户端列表中\n    clients.append(client_socket)\n\n    while True:\n        try:\n            # 接收客户端发送的消息\n            message &#x3D; client_socket.recv(BUFFER_SIZE).decode(&#39;utf-8&#39;)\n            if not message:\n                # 客户端关闭连接\n                break\n\n            # 将收到的消息转发给所有其他客户端\n            for c in clients:\n                if c !&#x3D; client_socket:\n                    c.sendall(&#39;来自&#123;&#125;:&#123;&#125;的客户端 发送了: &#123;&#125;&#39;.format(client_address[0], client_address[1], message).encode(&#39;utf-8&#39;))\n        except Exception as e:\n            # 发生异常，关闭连接\n            print(&#39;Exception: &#123;&#125;&#39;.format(e))\n            break\n\n    # 从客户端列表中删除已关闭的客户端\n    clients.remove(client_socket)\n    client_socket.close()\n    print(&#39;Closed connection from &#123;&#125;:&#123;&#125;&#39;.format(client_address[0], client_address[1]))\n\ndef main():\n    # 创建 TCP 服务器套接字\n    server_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    # 绑定服务器地址\n    server_socket.bind((SERVER_HOST, SERVER_PORT))\n\n    # 监听客户端连接\n    server_socket.listen(5)\n    print(&#39;开始启动监听-来自 &#123;&#125;:&#123;&#125;&#39;.format(SERVER_HOST, SERVER_PORT))\n\n    # 客户端列表\n    clients &#x3D; []\n\n    while True:\n        # 接受客户端连接\n        client_socket, client_address &#x3D; server_socket.accept()\n\n        # 创建一个新的线程来处理客户端连接\n        client_thread &#x3D; threading.Thread(target&#x3D;handle_client, args&#x3D;(client_socket, client_address, clients))\n        client_thread.start()\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n    \n\n客户端\n\nimport socket\nimport threading\n\ndef recv_msg(sock):\n    &quot;&quot;&quot;接收并显示从服务器端转发的消息&quot;&quot;&quot;\n    while True:\n        data &#x3D; sock.recv(1024).decode(&#39;utf-8&#39;)\n        print(&#39;\\n&#39;+data)\n\n# 创建 socket 对象并连接到服务器端\nsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((&#39;localhost&#39;, 8000))\n\n# 启动接收消息的线程\nt &#x3D; threading.Thread(target&#x3D;recv_msg, args&#x3D;(sock,))\nt.start()\n\n# 循环读取用户输入并发送消息到服务器端\nwhile True:\n    msg &#x3D; input(&#39;发送消息： &#39;)\n    sock.send(msg.encode(&#39;utf-8&#39;))\n    if msg&#x3D;&#x3D;&#39;exit&#39;:\n        break\n\n#  关闭 socket\nsock.close()\n 题目3\n\n\n\n\n\n\n\n\n\n\n使用springboot实现一个支持RESTful接口的WEB应用服务器（java）；\n使用django实现一个支持RESTful接口的WEB应用服务器（python);\n\n\n要求：从浏览器发送消息，可以回显示消息和图片；\n\n django\n\n\n\n\n\n\n\n\n\n在虚拟环境下安装django和rest：pip install django3.2 -i https://pypi.douban.com/simple 和 pip install djangorestframework\n\n\n\n\n\n\n\n\n\n\n创建项目：django-admin startproject third\n创建应用：python manage.py startapp third_app或者django-admin startapp third_app\n\n 题目4\n\n\n\n\n\n\n\n\n\n使用netty+kafka实现一个支持MQTT协议的消息队列应用框架，模拟多消息生产者和多消费者（java）；\n\n要求：实现一个客户端模拟气象传感器，定时发送（温度、湿度、气速）数据到接收服务器（netty实现），\n支持多对多生产者和消费者方式，即任意一个生产者产生的消息，所有消费者客户端都能接收和显示\n\n","slug":"1-软件架构实验","date":"2023-05-03T06:47:49.000Z","categories_index":"","tags_index":"软件架构,实验","author_index":"Kevin"},{"id":"71c983416622a77db3751ceb30048d18","title":"英语词汇学习","content":" 考研词汇学习\n\n\n\n\n\n\n\n\n\n用于本人考研英语词汇学习，包括词汇的同义词、反义词、形近词、领域词汇、熟词僻义、词汇变形等。\n 同义词汇\n\n\n\n\n\n\n\n\n\n格式：同义=（word-异意）\n 动词\n\n\n\n同义\nword\n异意\n\n\n\n\n断言\nassert\n维护；坚持自己的主张；生效，起作用\n\n\n\naffirm\n宣称拥护，支持；认可（判决，协议），批准\n\n\n\nallege\n(未经证实地）宣称，指控\n\n\n\nassure\n\n\n\n\nclaim\n\n\n\n保持\nretain\n\n\n\n\nmaintain\n\n\n\n撤退\nretreat\nv.（军队）撤退；后退，离开；（水、雪或土地）范围缩小；改变意见，改变看法；n.撤军，撤兵；后退，离开；\n\n\n\nwithdrew\nv.提，取（银行账户中的钱款）；停止提供，不再给予； 退出，不参加；（军队）撤离；（主意、观点、决定的）改变；\n\n\n争论\ndispute\n\n\n\n\ncontradict\n\n\n\n减少\nalleviate\nv.减轻，缓和\n\n\n\ndecline\nv.下降，衰退；拒绝，谢绝；n.减少，衰退\n\n\n\ndecrease\nv.（使）减少，（使）降低n.减少，降低\n\n\n\ndescend\nv.下来，下降；下倾，下斜；降临，来临；（情绪、气氛等）笼罩；突然到来，突然造访；降低身份，堕落；衰落，陷入；遗传\n\n\n\ndiminish\nv.减少，降低；缩小，变小\n\n\n\nrelieve\nv.缓解（疼痛或不快的感觉）；减轻（问题的严重性）；接替，替下；调剂，排遣； 给（城镇）解围，解救；救济，救援；免去，解除；上厕所，排便\n\n\n\nreduce\nv.减少，降低；\n\n\n\nshrink\nv.（使）缩小，减少；缩水，皱缩；退缩，畏缩；畏避，回避；\n\n\n合并\nconverge\n\n\n\n\ncoalesce\n\n\n\n\nincorporate\n\n\n\n\nmerge\n\n\n\n合作\ncooperate\n\n\n\n\ncooperate\n\n\n\n想象\nconceive\n\n\n\n\nimagine\n\n\n\n\nsuppose\n\n\n\n\nassume\n\n\n\n统治\nsovereign\n\n\n\n\ngovern\n\n\n\n\nempire\n\n\n\n努力\n\n\n\n\n\nendeavor\n\n\n\n\nstruggle\n\n\n\n\nstrive\n\n\n\n促进\n\n\n\n\n\npromote\n\n\n\n\nimprove\n\n\n\n\nmotivate\n\n\n\n\npropel\n\n\n\n使愤怒\nrage\n\n\n\n\nirritate\n\n\n\n\nprovoke\n\n\n\n\naggravate\n\n\n\n妨碍\nhandicap\n\n\n\n\nobstacle\n\n\n\n\nbarrier\n\n\n\n扩大\namplify\n\n\n\n\nmagnify\n\n\n\n\nexaggerate\n\n\n\n繁荣\nflourish\n\n\n\n\nboom\n\n\n\n\nthrive\n\n\n\n保证\nassure\n\n\n\n\ncertify\n\n\n\n\nguarantee\n\n\n\n\npromise\n\n\n\n丢弃\nabandon\n\n\n\n\nabort\n\n\n\n\ndiscard\n\n\n\n劝告/建议\ncounsel\n\n\n\n\nadvise\n\n\n\n装饰\nornament\n\n\n\n\ndecorate\n\n\n\n企图\nattempt\n\n\n\n\ndesign\n\n\n\n\nessay\n\n\n\n认为\ndeem\n\n\n\n\ninsist\n\n\n\n\nregard\n\n\n\n\nthink\n\n\n\n\n\n 名词\n\n\n\n同义\nword\n异意\n\n\n\n\n会议\n\n\n\n\n\nconvention\n习俗，惯例；公约，协定；传统手法，传统风格\n\n\n\nconference\n大型、正式的\n\n\n\nmeeting\n会议，集会；偶遇，会面；交汇处；会面；会合\n\n\n可能性\n\n\n\n\n\nprospect\n\n\n\n\npossibility\n\n\n\n\nprobability\n\n\n\n视野\n\n\n\n\n\nhorizon\n\n\n\n\nscope\n\n\n\n观点\n\n\n\n\n\nviewport\n\n\n\n管理\n\n\n\n\n\nadministration\n\n\n\n\nmanagement\n\n\n\n部分\n\n\n\n\n\nsegment\n\n\n\n\npart\n\n\n\n\nportion\n\n\n\n\nsection\n\n\n\n愚昧\n\n\n\n\n\nignorance\n\n\n\n\n\n\n\n\n尊敬\n\n\n\n\n\nesteem\n\n\n\n方案\n\n\n\n\n\nscheme\n\n\n\n律师\n\n\n\n\n\nattorney\n\n\n\n\nlawyer\n\n\n\n机构\n\n\n\n\n\napparatus\n\n\n\n\ninstitution\n\n\n\n\norganization\n\n\n\n影响\n\n\n\n\n\nimpact\n\n\n\n\ninfluence\n\n\n\n\naffect\n\n\n\n\neffect\n\n\n\n瀑布\n\n\n\n\n\ncascade\n\n\n\n\nwaterfall\n\n\n\n拒绝\n\n\n\n\n\ndenial\n\n\n\n\nobjection\n\n\n\n\nrefusal\n\n\n\n痛苦\n\n\n\n\n\nagony\n\n\n\n忠诚\n\n\n\n\n\nallegiance\n\n\n\n\nfaith\n\n\n\n资产\n\n\n\n\n\nasset\n\n\n\n\n\n\n\n\n资金\n\n\n\n\n\ncapital\n\n\n\n\nfund\n\n\n\n契约\n\n\n\n\n\npact\n\n\n\n\nbargain\n\n\n\n\ncontract\n\n\n\n条款\n\n\n\n\n\nprovision\n\n\n\n\npact\n\n\n\n补贴\n\n\n\n\n\nsubsidy\n\n\n\n赔偿\n\n\n\n\n\nsatisfaction\nn.满意，称心；赔偿，补偿\n\n\n\ncompensation\nn.赔偿金，补偿金；弥补，抵消；报酬，薪水\n\n\n\noffset\nn.抵消物，补偿；偏离量，偏离距离；\n\n\n开始\n\n\n\n\n\noutset\n\n\n\n\ncommencement\n\n\n\n\nbeginning\n\n\n\n停止\n\n\n\n\n\nhalt\n\n\n\n\npause\n\n\n\n\nstop\n\n\n\n\nabort\n\n\n\n\nstall\n\n\n\n终点\n\n\n\n\n\nterminal\n\n\n\n\nending\n\n\n\n骚动\n\n\n\n\n\nuproar\n\n\n\n\ndisturbance\n\n\n\n\nturmoil\n\n\n\n职业\n\n\n\n\n\nvocation\n\n\n\n\ncareer\n\n\n\n\noccupation\n\n\n\n谷物\n\n\n\n\n\ncereal\n\n\n\n主题\n\n\n\n\n\ntopic\n\n\n\n\ntheme\n\n\n\n\ntitle\n\n\n\n选择\n\n\n\n\n\noption\n\n\n\n\nchoice\n\n\n\n\nselection\n\n\n\n错误\n\n\n\n\n\nblunder\nv.跌跌撞撞地走，摸索；犯愚蠢的错误，出漏子；误入，不小心陷入困境n.愚蠢的错误，疏忽\n\n\n\nfault\n\n\n\n\nerror\n\n\n\n\nmistake\n\n\n\n冲突\n\n\n\n\n\nwarfare\n\n\n\n\nclash\n\n\n\n谨慎\n\n\n\n\n\nprecaution\n\n\n\n\n\n\n\n\n批准\n\n\n\n\n\nadmission\n\n\n\n\nsanction\n\n\n\n墓地\n\n\n\n\n\ngraveyard\n\n\n\n\ncemetery\n\n\n\n坟墓\n\n\n\n\n\ngrave\n\n\n\n\ntomb\n\n\n\n代表\n\n\n\n\n\ndelegate\n\n\n\n\nrepresent\n\n\n\n\ndeputy\n\n\n\n范围\n\n\n\n\n\nsphere\n\n\n\n\nzone\n\n\n\n\n\n\n\n\n烟雾\n\n\n\n\n\nsmog\n\n\n\n\nfume\n\n\n\n\nfog\n\n\n\n碰撞\n\n\n\n\n\nimpact\n\n\n\n\ncollide\n\n\n\n\nclash\n\n\n\n\n\n 形容词\n\n\n\n同义\nword\n异意\n\n\n\n\n共有的\n\n\n\n\n\nmutual\n\n\n\n丰富的\n\n\n\n\n\naffluent\n\n\n\n\nabundant\n\n\n\n\nsubstantial\n\n\n\n\nrich\n\n\n\n悲伤的\n\n\n\n\n\nmournful\n\n\n\n著名的\n\n\n\n\n\nprominent\n\n\n\n\nforemost\n\n\n\n详细的\n\n\n\n\n\nelaborate\n\n\n\n\nconcrete\n\n\n\n\nexplicit\n\n\n\n\nspecific\n\n\n\n普通的\n\n\n\n\n\naverage\n\n\n\n\ncommon\n\n\n\n\nnormal\n\n\n\n少量的\n\n\n\n\n\ntrifle\n\n\n\n\nrare\n\n\n\n\nscarce\n\n\n\n无用的\n\n\n\n\n\nfutile\n\n\n\n\nuseless\n\n\n\n\ninvalid\n\n\n\n悲惨的\n\n\n\n\n\ntragic\n\n\n\n\n\n\n\n\n故意的\n\n\n\n\n\ndeliberate\n\n\n\n\npurposed\n\n\n\n\n\n\n\n\n总共的\n\n\n\n\n\naggregate\n\n\n\n\ntotal\n\n\n\n\noverall\n\n\n\n有毒的\n\n\n\n\n\npoisonous\n\n\n\n\ntoxic\n\n\n\n费劲的\n\n\n\n\n\nstiff\n\n\n\n\n\n\n\n\n侧面的\n\n\n\n\n\nlateral\n\n\n\n\nsideway\n\n\n\n粗糙的\n\n\n\n\n\ncoarse\n\n\n\n\ncrude\n\n\n\n渴望的\n\n\n\n\n\nkeen\n\n\n\n\nthirsty\n\n\n\n基本的\n\n\n\n\n\nelementary\n\n\n\n严肃的\n\n\n\n\n\nsolemn\n\n\n\n\nserious\n\n\n\n\nstiff\n\n\n\n\ngrave\n\n\n\n\ngrim\n\n\n\n敏锐的\n\n\n\n\n\nacute\nadj.严重的，危险的；急性的，剧烈的；灵敏的；敏锐的，有洞察力的；锐角的；声音高的、尖的\n\n\n\nkeen\nadj.渴望的，热衷的；喜爱的，着迷的；热情的，热心的；v.为死者恸哭，哀号；n.痛哭，挽歌\n\n\n精致的\n\n\n\n\n\nexquisite\nadj.精致的，精美的；剧烈的；细致的，有鉴赏力的；n.花花公子\n\n\n\nelegant\n\n\n\n清楚的\n\n\n\n\n\nintelligible\nadj.容易理解的，容易领悟的\n\n\n\nclear\n\n\n\n智力\n\n\n\n\n\nwit\n\n\n\n\nintellect\n\n\n\n最重要的\n\n\n\n\n\ncardinal\n\n\n\n\nprincipal\n\n\n\n\nchief\n\n\n\n\nprimary\n\n\n\n必要的\n\n\n\n\n\nessential\n\n\n\n\nnecessary\n\n\n\n\nindispensable\n\n\n\n\ninevitable\n\n\n\n中间的\n\n\n\n\n\nmedial\n\n\n\n\nmedial\n\n\n\n\nmiddle\n\n\n\n\nmoderate\n\n\n\n相反的\n\n\n\n\n\ncounter\n\n\n\n\ncontrary\n\n\n\n\nadverse\n\n\n\n\nconverse\n\n\n\n\ninversed\n\n\n\n复杂的\n\n\n\n\n\ncomplicated\n\n\n\n\ncomplex\n\n\n\n\nintricate\n\n\n\n易碎的\n\n\n\n\n\nbrittle\n\n\n\n\nfragile\n\n\n\n\n\n 形近词汇\n 后缀词汇\n ABCDE\n\n\n\n后缀\nword\n含义\n\n\n\n\n-ax\n\n\n\n\n\nfax\n\n\n\n\nmax\n\n\n\n\ntax\n\n\n\n\nwax\n\n\n\n-cede\n\n\n\n\n\nconcede\nv.（通常指不情愿地）承认；认（输），承认（失败）；授予，让与；让对手得分\n\n\n\nprecede\nv.处在……之前，先于；在……之前做（或说）；比……更重要，比……（级别）更高\n\n\n\nrecede\nv.逐渐远离，渐渐退去；（质量）下降，（问题或疾病等）逐渐减弱；\n\n\n-ceive\n\n\n\n\n\nconceive\nv.设想，构想；怀孕，怀胎；\n\n\n\ndeceive\nv.欺骗，蒙蔽；使产生错觉\n\n\n\nperceive\nv.察觉，发觉；认为，意识到；理解，领悟\n\n\n\nreceive\nv.收到，接到；接待，接见；接受，采纳；\n\n\n-cident\n\n\n\n\n\naccident\nn.意外，事故；\n\n\n\ncoincident\nadj.巧合的，同时发生的；一致的，符合的\n\n\n\nincident\nn.事件，事变；插曲，片段；adj.附带的，伴随的；易发生的，有可能发生的\n\n\n-claim\n\n\n\n\n\nacclaim\nv.欢呼，喝彩；称赞，赞扬；n.欢呼，喝彩；称赞，赞扬\n\n\n\nclaim\nv.要求，请求；声称，断言；n.要求，请求；声称，断言；权利，所有权\n\n\n\nexclaim\nv.呼喊，惊叫；大声说\n\n\n\nproclaim\nv.宣告，声明；表明，显示\n\n\n\nreclaim\nv.要求归还；开垦；改造；回收（废料）\n\n\n\nunclaimed\nadj.无人认领的，无人要求的\n\n\n-cline\n\n\n\n\n\ndecline\nv.下降，减少；衰落，衰退；谢绝，拒绝；n.下降，减少；衰落，衰退；斜坡\n\n\n\nincline\nv.倾斜，使倾向；倾向于，偏向；n.斜坡，斜面；倾向，爱好\n\n\n\nrecline\nv.斜倚，躺卧；\n\n\n-duce\n\n\n\n\n\nabduce\nv.诱拐，诱骗\n\n\n\nadduce\nv.举出，引证\n\n\n\nconduce\nv.有助于，有益于\n\n\n\ndeduce\nv.演绎，推断\n\n\n\nduce\nn.导体；导线\n\n\n\neduce\nv.引出，引起\n\n\n\ninduce\nv.引诱，劝使；引起，导致\n\n\n\nintroduce\nv.介绍；引进，传入；提出，提议；\n\n\n\nproduce\nv.生产，制造；引起，导致；n.产品，农产品；\n\n\n\nreduce\nv.减少，降低；缩小，简化；\n\n\n-duct\n\n\n\n\n\nconduct\nv.引导，带领；指挥，管理；n.行为，举止；\n\n\n\ndeduct\nv.扣除，减去；演绎，推断\n\n\n\ninduct\nv.引导；感应；使就职，使入伍；使正式就任；使入门\n\n\n\nproduct\nn.产品，产物；结果，效果；乘积\n\n\n-eem\n\n\n\n\n\ndeem\nv.认为，相信\n\n\n\nesteem\nv.尊重，尊敬；n.尊重，尊敬\n\n\n\nseem\nv.似乎，好像\n\n\n-een\n\n\n\n\n\nbetween\nprep.在……之间；adv.在中间；adj.中间的\n\n\n\nforeseen\nv.预见，预知\n\n\n\ngreen\nadj.绿色的；未成熟的；无经验的；n.绿色；草地；绿色植物；v.绿化；使变绿\n\n\n\nkeen\nadj.热心的，渴望的；敏锐的，敏捷的；锋利的，刺耳的；v.热衷于，渴望\n\n\n\nteen\nn.青少年；adj.十几岁的\n\n\n-ender\n\n\n\n\n\ndefender\nn.保卫者，防御者；辩护者，辩护律师\n\n\n\noffender\nn.罪犯，违法者\n\n\n\npretender\nn.冒牌者，假装者；（对王位的）冒称者\n\n\n\nrender\nv.使成为；提供；表演；翻译\n\n\n\nsurrender\nv.投降，放弃；交出，放弃；n.投降，放弃；\n\n\n\ntender\nadj.嫩的，柔软的；温柔的，亲切的；v.提出，提供；投标；n.投标，投标人；\n\n\n\n FGHIJ\n\n\n\n后缀\nword\n含义\n\n\n\n\n-fer\n\n\n\n\n\nconfer\nv.商讨，商议；授予，赋予\n\n\n\ndefer\nv.推迟，延期；遵从，听从\n\n\n\ndiffer\nv.不同，相异；不一致，有分歧\n\n\n\ninfer\nv.推断，推论；猜想，猜测\n\n\n\noffer\nv.提供，提出；提供，出价；n.提供，出价；\n\n\n\nprefer\nv.更喜欢，宁愿\n\n\n\nrefer\nv.提到，谈到；提交，上呈；参考，查阅；\n\n\n\ntransfer\nv.转移，转让；调动，调任；n.转移，转让；\n\n\n-form\n\n\n\n\n\nconform\nv.遵守，遵照；符合，一致\n\n\n\ndeform\nv.使变形，使残废\n\n\n\nform\nn.形状，形式；表格；v.形成，组成；构成；\n\n\n\ninform\nv.通知，告诉；告发，告密；\n\n\n\nperform\nv.表演，演出；执行，履行；完成，做完；\n\n\n\nreform\nv.改革，改造；n.改革，改造；\n\n\n\ntransform\nv.改变，转换；改造，改造；\n\n\n\nuniform\nadj.统一的，一致的；n.制服；\n\n\n-fuse\n\n\n\n\n\nconfuse\nv.使混乱，使困惑；混淆，混同\n\n\n\ndefuse\nv.拆除引信，缓和紧张局势\n\n\n\ndiffuse\nv.扩散，散播；传播；adj.扩散的，弥漫的；\n\n\n\neffuse\nv.流出，散发；泄露；adj.流出的，散发的；\n\n\n\nfuse\nv.熔化，熔合；n.保险丝；导火线；\n\n\n\ninfuse\nv.灌输，使充满；鼓励，激励；\n\n\n\nprofuse\nadj.丰富的，大量的；浪费的，挥霍的；\n\n\n\nrefuse\nv.拒绝，谢绝；n.废物，垃圾；\n\n\n-ject\n\n\n\n\n\nabject\nadj.可怜的，卑下的；\n\n\n\neject\nv.喷射，排出；驱逐，逐出；\n\n\n\ninject\nv.注射，注入；\n\n\n\nobject\nn.物体，事物；目标，目的；v.反对，不赞成；\n\n\n\nproject\nv.投射，放映；规划，设计；n.项目，工程；\n\n\n\nreject\nv.拒绝，抵制；排斥，驳回；n.被拒之人；\n\n\n\nsubject\nn.主题，题目；学科；v.使隶属，使服从；\n\n\n\n KLMNO\n\n\n\n后缀\nword\n含义\n\n\n\n\n-miss\n\n\n\n\n\ndismiss\nv.解散，遣散；解雇，开除；不予考虑，摒弃；\n\n\n\nemiss\nn.使者，代表；\n\n\n\nmiss\nv.错过，未看到；想念，怀念；未达到，未做到；n.未击中目标；\n\n\n\nremiss\nadj.疏忽的，不留心的；不负责任的；\n\n\n-mit\n\n\n\n\n\nadmit\nv.承认，供认；准许进入，准许加入；\n\n\n\ncommit\nv.犯罪，犯错；承诺，保证；把…交托给；\n\n\n\nemit\nv.发出，放射；发表，发表；\n\n\n\nomit\nv.省略，删去；遗漏，疏忽；\n\n\n\npermit\nv.允许，准许；n.许可证，执照；\n\n\n\nremit\nv.汇款，汇出；免除，豁免；\n\n\n\nsubmit\nv.提交，呈递；服从，屈服；\n\n\n\nsummit\nn.顶点，最高点；最高级会议；v.达到顶点；\n\n\n\ntransmit\nv.传送，传播；传达，传递；\n\n\n-oom\n\n\n\n\n\nbloom\nn.花；开花；v.开花；\n\n\n\nboom\nn.繁荣，兴旺；隆隆声；v.发出隆隆声；繁荣，兴旺；\n\n\n\ndoom\nn.厄运，劫数；v.注定，命定；\n\n\n\ngloom\nn.阴暗，昏暗；忧郁，沮丧；v.变阴暗，变昏暗；\n\n\n\nloom\nv.隐约出现，阴森地逼近；n.织布机；\n\n\n\nroom\nn.房间；空间；v.住宿；容纳；\n\n\n\nzoom\nv.急速上升，猛增；n.嗡嗡声；\n\n\n\n PQRS\n\n\n\n后缀\nword\n含义\n\n\n\n\n-pact\n\n\n\n\n\ncompact\nadj.紧凑的，紧密的；简洁的，简明的；n.合同，协议；\n\n\n\nimpact\nn.影响，作用；冲击，碰撞；v.影响，作用；冲击，碰撞；\n\n\n\npact\nn.协定，条约；公约，公约；\n\n\n-part\n\n\n\n\n\napart\nadv.分离，分开；相距；adj.分离的，分开的；\n\n\n\ndepart\nv.离开，出发；违反，背离；\n\n\n\nimpart\nv.传授，给予；告知，通知；\n\n\n\npart\nn.部分，部份；角色，角色；v.分开，分离；离开，分手；\n\n\n-partment\n\n\n\n\n\napartment\nn.公寓，套房；\n\n\n\ncompartment\nn.隔间，车厢；\n\n\n\ndepartment\nn.部，部门；系，科；部，部门；系，科；\n\n\n\nimpartment\nn.传授，给予；\n\n\n-ply\n\n\n\n\n\napply\nv.申请，请求；应用，实施；涂，敷；\n\n\n\ncomply\nv.遵从，顺从；答应，应允；\n\n\n\nimply\nv.暗示，意味；\n\n\n\nmultiply\nv.乘，使相乘；增加，繁殖；\n\n\n\nreply\nv.回答，答复；n.回答，答复；\n\n\n\nsupply\nv.供给，提供；n.供给，供应；\n\n\n-plicate\n\n\n\n\n\ncomplicate\nv.使复杂化；使陷入困境；\n\n\n\nduplicate\nadj.复制的，复印的；n.复制品，副本；v.复制，复印；\n\n\n\nimplicate\nv.牵连，涉及；暗示，暗指；\n\n\n\nplicate\nadj.折叠的；v.折叠；\n\n\n-plicit\n\n\n\n\n\ncomplicit\nadj.串通的，共谋的；\n\n\n\nexplicit\nadj.详述的，明确的；直言的，坦率的；\n\n\n\nimplicit\nadj.含蓄的，暗示的；绝对的，无疑问的；\n\n\n\nplicit\nadj.明确的；\n\n\n-plify\n\n\n\n\n\namplify\nv.放大，增强；详述，详加解释；\n\n\n\nexemplify\nv.举例说明，例证；\n\n\n\nsimplify\nv.简化，使单纯；\n\n\n-pose\n\n\n\n\n\ncompose\nv.组成，构成；创作，写作；使镇定，使安定；\n\n\n\ndecompose\nv.分解，腐烂；\n\n\n\ndepose\nv.免职，罢免；作证，作证明；\n\n\n\ndispose\nv.处理，处置；安排，布置；倾向于，有意于；\n\n\n\nexpose\nv.使暴露，使曝光；揭露，揭发；\n\n\n\nimpose\nv.强加，征税；利用，欺骗；\n\n\n\noppose\nv.反对，反抗；使对立，使对抗；\n\n\n\npropose\nv.提议，建议；打算，计划；求婚；\n\n\n\nsuppose\nv.假定，猜想；认为，以为；\n\n\n-pulate\n\n\n\n\n\nmanipulate\nv.操作，操纵；巧妙地处理；\n\n\n\npopulate\nv.居住于，移居于；殖民于，移植于；\n\n\n\npulate\nv.人口增加；\n\n\n-quire\n\n\n\n\n\nacquire\nv.获得，取得；学到，养成；\n\n\n\ninquire\nv.询问，打听；调查，查究；\n\n\n\nrequire\nv.需要，要求；\n\n\n-quirement\n\n\n\n\n\nacquirement\nn.获得，取得；学到，养成；\n\n\n\ninquirement\nn.询问，打听；调查，查究；\n\n\n\nrequirement\nn.需要，要求；\n\n\n-send\n\n\n\n\n\nascend\nv.上升，攀登；\n\n\n\ndescend\nv.下降，下来；遗传；\n\n\n\nsend\nv.送，寄；派遣，遣送；\n\n\n-sent\n\n\n\n\n\nabsent\nadj.缺席的，不在场的；v.缺席，不参加；\n\n\n\nconsent\nv.同意，赞成；n.同意，赞成；\n\n\n\ndissent\nv.不同意，持异议；n.不同意，持异议；\n\n\n\npresent\nadj.现在的，目前的；出席的，到场的；v.赠送，授予；提出，提交；\n\n\n\nrepresent\nv.代表，象征；描绘，表现；\n\n\n\nresent\nv.对…表示愤恨，怨恨；\n\n\n-side\n\n\n\n\n\nbeside\nprep.在…旁边；除…之外；adv.在旁边；\n\n\n\ninside\nprep.在…里面；adv.在里面；n.内部；adj.内部的；\n\n\n\noutside\nprep.在…外面；adv.在外面；n.外部；adj.外部的；\n\n\n\npreside\nv.主持，担任主席；\n\n\n\nreside\nv.居住，定居；属于，归属于；\n\n\n-sist\n\n\n\n\n\nassist\nv.帮助，援助；n.帮助，援助；\n\n\n\nconsist\nv.由…组成，由…构成；在于，存在于；\n\n\n\ndesist\nv.停止，中止；\n\n\n\ninsist\nv.坚持，坚持要求；\n\n\n\npersist\nv.坚持，持续；固执，执意；\n\n\n\nresist\nv.抵抗，抵制；抵抗，反抗；\n\n\n-spire\n\n\n\n\n\naspire\nv.渴望，追求；立志做，有志于；\n\n\n\nconspire\nv.密谋，共谋；\n\n\n\nexpire\nv.期满，到期；死亡，逝世；\n\n\n\ninspire\nv.鼓舞，激励；启示，启发；\n\n\n\nperspire\nv.出汗，流汗；\n\n\n\nrespire\nv.呼吸；\n\n\n-stance\n\n\n\n\n\nassistance\nn.帮助，援助；\n\n\n\ncircumstance\nn.环境，情况；境遇，境况；\n\n\n\ndistance\nn.距离；远处，远方；v.使远离，使疏远；\n\n\n\ninstance\nn.例子，实例；情况，情形；v.举…为例；\n\n\n\nresistance\nn.抵抗，反抗；阻力，阻力；\n\n\n\nstance\nn.站姿，站立；立场，态度；\n\n\n-stant\n\n\n\n\n\nassistant\nn.助手，助理；adj.辅助的，助理的；\n\n\n\nconstant\nadj.经常的，不变的；n.常数；\n\n\n\ndistant\nadj.远的，遥远的；疏远的，冷淡的；\n\n\n\ninstant\nadj.立即的，即刻的；n.瞬间，片刻；\n\n\n\nresistant\nadj.抵抗的，反抗的；有抵抗力的；\n\n\n-strain\n\n\n\n\n\nstrain\nn.拉紧，张力；扭伤，拉伤；v.拉紧，扭伤；\n\n\n\nconstrain\nv.强迫，迫使；限制，约束；\n\n\n\nrestrain\nv.抑制，克制；约束，限制；\n\n\n-struct\n\n\n\n\n\nconstruct\nv.建造，构造；创立，建立；\n\n\n\ndestruct\nv.破坏，毁坏；\n\n\n\ninstruct\nv.教，指导；通知，命令；\n\n\n\nobstruct\nv.阻碍，妨碍；\n\n\n\nreconstruct\nv.重建，改造；\n\n\n-sume\n\n\n\n\n\nassume\nv.假定，假设；承担，担任；\n\n\n\nconsume\nv.消耗，消费；吃，喝；\n\n\n\nresume\nv.重新开始，继续；恢复，重新占用；\n\n\n-sult\n\n\n\n\n\nconsult\nv.请教，咨询；商量，商议；\n\n\n\ninsult\nv.侮辱，凌辱；n.侮辱，凌辱；\n\n\n\nresult\nn.结果，成果；v.导致，造成；\n\n\n-sure\n\n\n\n\n\nsure\nadj.确信的，肯定的；有把握的，有信心的；\n\n\n\nassure\nv.使确信，使放心；向…保证；\n\n\n\nensure\nv.确保，保证；\n\n\n\ninsure\nv.保险，给…保险；确保，保证；\n\n\n\nmeasure\nn.尺寸，度量；措施，办法；v.测量，衡量；\n\n\n\npleasure\nn.快乐，高兴；乐事，乐趣；v.使高兴，使愉快；\n\n\n\ntreasure\nn.财宝，财富；珍品，珍藏；v.珍惜，珍藏；\n\n\n\nleisure\nn.空闲，闲暇；adj.空闲的，有闲的；\n\n\n\npressure\nn.压力；压强；压迫，压制；v.对…施加压力；\n\n\n\nreassure\nv.使安心，使放心；\n\n\n\n TUVWXYZ\n\n\n\n后缀\nword\n含义\n\n\n\n\n-tain\n\n\n\n\n\nattain\nv.达到，获得；\n\n\n\ncontain\nv.包含，容纳；控制，抑制；\n\n\n\ndetain\nv.拘留，扣留；耽搁，延误；\n\n\n\nmaintain\nv.维持，保持；主张，坚持；\n\n\n\nobtain\nv.获得，得到；\n\n\n\nretain\nv.保留，保持；记住，记得；\n\n\n-take\n\n\n\n\n\nintake\nn.吸入，摄入；引入，输入；\n\n\n\nmistake\nn.错误，过失；v.弄错，误解；\n\n\n\novertake\nv.追上，赶上；超过，胜过；\n\n\n\npartake\nv.参与，参加；分享，吃；\n\n\n\nretake\nv.重拍，重录；重考，补考；\n\n\n\nstake\nn.桩，标桩；赌注，赌金；v.打赌，下赌注；\n\n\n-tative\n\n\n\n\n\nauthoritative\nadj.权威的，有权威的；\n\n\n\ntentative\nadj.试探性的，暂时的；犹豫不决的；\n\n\n-tend\n\n\n\n\n\nattend\nv.出席，参加；照顾，护理；\n\n\n\nextend\nv.延长，延伸；扩大，扩展；\n\n\n\nintend\nv.打算，计划；意指，意思是；\n\n\n\npretend\nv.假装，伪装；\n\n\n\ntend\nv.照料，照管；趋向，倾向；\n\n\n-tense\n\n\n\n\n\nintense\nadj.强烈的，剧烈的；\n\n\n\ntense\nadj.紧张的，拉紧的；v.拉紧，绷紧；\n\n\n-tensive\n\n\n\n\n\nextensive\nadj.广泛的，广阔的；大量的，大规模的；\n\n\n\nintensive\nadj.密集的，集中的；加强的，强化的；\n\n\n-tent\n\n\n\n\n\ncontent\nn.内容，目录；满足，满意；adj.满意的，满足的；v.使满足，使满意；\n\n\n\nextent\nn.范围，广度；程度，限度；\n\n\n\nintent\nn.意图，目的；adj.专心的，专注的；\n\n\n\ntent\nn.帐篷；v.搭帐篷；\n\n\n-tention\n\n\n\n\n\nattention\nn.注意，注意力；\n\n\n\ndistention\nn.膨胀，扩张；\n\n\n\nintention\nn.意图，目的；\n\n\n\nretention\nn.保留，保持；记忆力；\n\n\n-tinction\n\n\n\n\n\ndistinction\nn.区别，差别；特性，特征；\n\n\n\nextinction\nn.灭绝，消灭；熄灭，灭绝；\n\n\n\nintinction\nn.沾湿，浸湿；\n\n\n-tribute\n\n\n\n\n\nattribute\nn.属性，特征；v.把…归于，认为…是；\n\n\n\ncontribute\nv.贡献，捐献；投稿，投诉；\n\n\n\ndistribute\nv.分发，分配；散布，分布；\n\n\n\ntribute\nn.贡品，贡物；颂词，称赞；\n\n\n-turn\n\n\n\n\n\noverturn\nv.翻倒，推翻；颠覆，打翻；\n\n\n\nreturn\nv.返回，回来；归还，送还；n.返回，回来；归还，送还；\n\n\n\nturn\nv.转动，旋转；变成，成为；n.转动，旋转；转向，转弯；\n\n\n-vail\n\n\n\n\n\navail\nv.有益于，有助于；n.效用，利益；\n\n\n\nprevail\nv.盛行，流行；战胜，获胜；\n\n\n-vent\n\n\n\n\n\nadvent\nn.到来，来临；\n\n\n\nevent\nn.事件，大事；\n\n\n\ninvent\nv.发明，创造；捏造，虚构；\n\n\n\nprevent\nv.阻止，防止；预防，防范；\n\n\n\nvent\nn.通风口，排气口；v.发泄，宣泄；\n\n\n-verse\n\n\n\n\n\nadverse\nadj.不利的，相反的；敌对的，有害的；\n\n\n\naverse\nadj.反对的，不愿意的；\n\n\n\nconverse\nv.交谈，谈话；adj.相反的，对立的；n.相反的事物；\n\n\n\ndiverse\nadj.不同的，多种多样的；\n\n\n\ninverse\nadj.相反的，倒转的；n.相反的事物；\n\n\n\nperverse\nadj.固执的，任性的；\n\n\n\nreverse\nv.颠倒，倒转；n.相反，反面；\n\n\n-vert\n\n\n\n\n\nadvert\nv.注意，留意；n.广告；\n\n\n\nconvert\nv.转变，转换；改变信仰；n.皈依者，改变信仰者；\n\n\n\ndivert\nv.转移，转向；使娱乐，使消遣；\n\n\n\ninvert\nv.倒置，倒转；使反转；\n\n\n\npervert\nv.使堕落，使腐化；使误用；n.堕落者，性变态者；\n\n\n\nrevert\nv.恢复，复原；回复，回答；\n\n\n\nsubvert\nv.颠覆，推翻；破坏，损害；\n\n\n\nvert\nn.绿地，草地；\n\n\n-voke\n\n\n\n\n\nconvoke\nv.召集，召开；\n\n\n\nevoke\nv.唤起，引起；\n\n\n\ninvoke\nv.祈求，恳求；援引，援用；\n\n\n\nprovoke\nv.激怒，惹起；煽动，激起；\n\n\n\nrevoke\nv.撤回，废除；取消，放弃；\n\n\n-volve\n\n\n\n\n\ndevolve\nv.移交，委托；\n\n\n\ndissolve\nv.溶解，融化；解散，废除；\n\n\n\nevolve\nv.发展，进化；逐步形成；\n\n\n\ninvolve\nv.包含，包括；使陷入，卷入；\n\n\n\nrevolve\nv.旋转，转动；考虑，思考；\n\n\n-ward\n\n\n\n\n\nbackward\nadj.向后的，倒退的；adv.向后，倒退；\n\n\n\nforward\nadj.向前的，前进的；adv.向前，前进；v.转交，发送；\n\n\n\ntoward\nprep.向，朝；对于，关于；\n\n\n\nsward\nn.草地，草皮；\n\n\n\nstraightforward\nadj.直率的，坦诚的；易懂的，简单的；\n\n\n\nward\nn.病房，病室；v.守护，看守；\n\n\n\n 前缀词汇\n 形似词汇\n ABCDE\n\n\nA\n\n\n\n\nadapt：v.使适应，使适合；改编，改写；\nadopt：v.采用，采纳；收养，领养；接受，采纳；\nadept：adj.熟练的，擅长的；n.内行，能手；\n\n\n\n\n\narise：v.出现，发生；起立，起身；\narouse：v.唤醒，唤起；激发，引起；\n\n\n\n\n\n\nB\n\n\n\n\nboast：v.自夸，夸耀；n.自夸，自吹自擂；\nboost：v.推进，促进；n.推进，促进；提高，增加；\nroast：v.烤，炙，烘；n.烤肉，烘烤；adj.烤过的，烘过的；\ntoast：v.烤，烘，烘干；n.烤面包，吐司；祝酒，干杯；\n\n\n\n\n\nbroad：adj.宽的，广阔的；宽宏的，豁达的；广泛的，大概的；\nboard：n.木板，板；董事会，委员会；v.上（船、车、飞机等）；供（某人）膳宿；\nabroad：adv.在国外，在国外；到处，在各处；\naboard：adv.在船（车、飞机）上；prep.在船（车、飞机）上；\n\n\n\n\n\nblame：v.责备，把…归咎于；n.责备，责难；\nflame：n.火焰，火舌；v.燃烧，发光；发怒，发火；\nframe：n.框架，结构；v.构成，组成；制定，拟定；陷害，诬告；\n\n\n\nC\n\n\n\n\nclash：v.发出撞击声；冲突，抵触；n.撞击声；冲突，抵触；\nclasp：v.扣住，紧握；n.扣子，钩子；紧握，拥抱；\ncrash：v.碰撞，坠落；破产，失败；n.碰撞，坠落；破产，失败；\ncrush：v.压碎，碾碎；压服，压垮；n.压碎，碾碎；迷恋，迷恋对象；\ncrust：n.面包皮，硬外皮；地壳；v.盖以硬皮；结硬皮；\n\n\n\n\n\ncrucial：adj.至关重要的，决定性的；\ncrude：adj.粗糙的，粗鲁的；天然的，未加工的；粗制滥造的，简陋的；\ncruel：adj.残忍的，残酷的；痛苦的，令人痛苦的；\n\n\n\n\n\ncurb：n.路缘，（街道的）镶边石；v.控制，约束；抑制，克制；\ncurd：n.凝乳，凝乳块；凝乳状物；\ncurl：v.（使）卷曲，（使）缠绕；n.卷曲，卷发；卷曲物；\nhurl：v.猛投，猛掷；大声叫骂；\ncurse：n.诅咒，咒骂；v.诅咒，咒骂；\ncure：n.治愈，治疗；v.治愈，治疗；\ncurt：adj.简短的，简洁的；草率的，无礼的；\n\n\n\n\n\n\nD\n\n\nE\n\n\n FGHIJ\n\nF\nG\nH\nI\nJ\n\n KLMNO\n\nK\nL\nM\nN\nO\n\n PQRST\n\nP\nQ\nR\nS\nT\n\n UVWXYZ\n\nU\nV\nW\nX\nY\nZ\n\n 反义词汇\n 领域词汇\n 政治\n\n\n\n英文\n中文\n\n\n\n\ncongress\n国会；议会\n\n\nsenate\n参议院\n\n\nparliament\n议会\n\n\nlegislature\n立法机关\n\n\npremier\n首相，总理\n\n\npresident\n总统\n\n\nchancellor\n总理，首相\n\n\nwhip\n党鞭\n\n\ncabinet\n内阁\n\n\nminister\n部长\n\n\ncharter\n契约；宪章\n\n\nconstitution\n宪法\n\n\nmayor\n市长\n\n\nlobby\n游说群体\n\n\nrepublican\n共和党人；共和国的\n\n\ndemocrat\n民主党人；民主的\n\n\ncommonwealth\n共和国，联邦\n\n\nmainland\n祖国；大陆\n\n\nterritory\n领土；领域\n\n\nsanction\n制裁\n\n\nveto\n否决权\n\n\nforum\n论坛\n\n\n\n 军事\n\n\n\n英文\n中文\n\n\n\n\nescort\n护卫\n\n\ntreason\n叛国，谋反\n\n\nsurrender\n投降\n\n\nammunition\n军火，弹药\n\n\nalliance\n联盟\n\n\nally\n盟友\n\n\nheadquarters\n司令部；总部\n\n\n\n 经济\n\n\n\n英文\n中文\n\n\n\n\nestate\n房地产\n\n\ninflation\n经济过热/通货膨胀\n\n\nrecession\n经济衰退/通货收缩\n\n\nrevenue\n收入；财政收入，税收\n\n\ndeficit\n赤字\n\n\nsurplus\n盈余\n\n\nprofit\n利润\n\n\nexpenditures\n支出；开支\n\n\nsalary\n工资\n\n\nwage\n工资\n\n\npension\n养老金，退休金\n\n\ntuition\n学费\n\n\nscholarship\n奖学金\n\n\nsubsidy\n津贴，补贴\n\n\nmortgage\n抵押\n\n\nportfolio\n投资组合（公文包；文件夹）\n\n\neconomic\n经济学的；经济的\n\n\nfinancial\n金融的；财政的\n\n\nfiscal\n财政的，国库的\n\n\n\n 教育\n\n\n\n英文\n中文\n\n\n\n\nkindergarten\n幼儿园\n\n\nenlighten\n启蒙\n\n\n\n 法律\n\n\n\n英文\n中文\n\n\n\n\ncourt\n法院\n\n\ncounsel\n法律顾问，辩护人\n\n\nmagistrate\n地方法官，治安官\n\n\nstatute\n法规、章程\n\n\nlegacy\n遗产；遗留问题\n\n\nobligation\n义务，责任\n\n\nprosecute\n提起公诉；检举\n\n\n\n\n\n\ndefendant\n被告\n\n\nplaintiff\n原告\n\n\n\n\n\n\ngamble\n赌博\n\n\n\n\n\n\narrest\n拘捕\n\n\nbail\n保释\n\n\n\n\n\n\njudicial\n法庭的，司法的；公正的，明断的\n\n\n\n 交通\n\n\n\n英文\n中文\n\n\n\n\nvessel\n船；舰\n\n\nwaggon\n运货马车；运货车\n\n\nsubmarine\n潜水艇\n\n\n\n\n\n\nembark\n上船，上飞机；着手，开始\n\n\n\n 农业\n\n\n\n英文\n中文\n\n\n\n\nfamine\n饥荒\n\n\ncereal\n谷物\n\n\ngrain\n粮食；谷物\n\n\ncrop\n庄稼；收成\n\n\npasture\n牧场\n\n\nmeadow\n草地\n\n\norchard\n果园\n\n\n\n 工业\n\n\n\n英文\n中文\n\n\n\n\nindustrialize\n工业化\n\n\noverhaul\n彻底检修\n\n\ndisplace\n取代；置换\n\n\nhammer\n捶打；铁锤\n\n\n\n\n\n\nfurnace火炉\n\n\n\nbrick砖块\n\n\n\n\n\n\n\nengineering工程\n\n\n\nproductivity生产率\n\n\n\n\n 商业\n\n\n\n英文\n中文\n\n\n\n\nmerchant\n商人\n\n\ncashier\n收银员\n\n\ncargo\n船货；货物\n\n\nporter\n搬运工\n\n\n\n\n\n\nexploit\n开发\n\n\n\n 文学\n\n\n\n英文\n中文\n\n\n\n\nhumanity\n人文学科；人性；人类\n\n\n\n\n\n\nmetaphor\n隐喻，暗喻\n\n\n\n\n\n\nsatire\n讽刺\n\n\nirony\n反语；讽刺\n\n\nsarcastic\n讽刺的，挖苦的\n\n\n\n\n\n\ngenre\n体裁，类型\n\n\ncatalogue\n目录\n\n\nnarrative\n记叙文；叙述的\n\n\nhandbook\n手册，指南\n\n\nliterature\n文学；文献\n\n\nessay\n文章；散文\n\n\nanecdote\n轶事，趣闻\n\n\nmanuscript\n手稿，原稿\n\n\nshorthand\n速记\n\n\ndigest\n摘要\n\n\nskeleton\n骨架；梗概\n\n\nfabricate\n编造；制造\n\n\n\n 艺术\n\n\n\n英文\n中文\n\n\n\n\naesthetic\n审美的；艺术的\n\n\nmosaic\n马赛克；镶嵌画\n\n\nsketch\n素描；草图\n\n\n\n 音乐\n\n\n\n英文\n中文\n\n\n\n\nvocal\n嗓音的\n\n\nviolent\n小提琴\n\n\npiano\n钢琴\n\n\ntrumpet\n喇叭、小号\n\n\ndisk/disc\n唱片\n\n\nsymphony\n交响乐；和谐\n\n\n\n\n\n\norchestra\n管弦乐队\n\n\n\n 历史\n\n\n\n英文\n中文\n\n\n\n\npriest\n神父；传教士\n\n\nmissionary\n传教士\n\n\npilgrim\n朝圣者；香客\n\n\ndivine\n牧师；神的，神圣的\n\n\nCatholic\n天主教徒\n\n\nsalvation\n拯救，救助\n\n\nrescue\n营救，援救\n\n\nlayman\n普通信徒；门外汉\n\n\nideology\n思想体系；意识形态\n\n\nbronze\n青铜器\n\n\nbrass\n黄铜\n\n\nantique\n古董；古老的\n\n\nsovereign\n至高无上的；独立自主的；君主、元首\n\n\narbitrary\n随心所欲的\n\n\ncolonial\n殖民的\n\n\nancestor\n祖宗\n\n\noffspring\n子孙\n\n\nhierarchy\n等级制度\n\n\norigin\n起源\n\n\n\n 地理\n\n\n\n英文\n中文\n\n\n\n\ntropical\n热带的\n\n\nsubmarine\n海底的\n\n\ntropic\n回归线\n\n\natlas\n地图册\n\n\nmarble\n大理石\n\n\nbrook\n小溪\n\n\nebb\n退潮\n\n\n\n 医学\n\n\n\n英文\n中文\n\n\n\n\nphysician\n内科医生\n\n\nsurgeon\n外科医生\n\n\nartery\n动脉\n\n\nvein\n静脉\n\n\nliver\n肝脏\n\n\nthigh\n大腿\n\n\npalm\n手掌\n\n\nlap\n膝盖；大腿\n\n\nheel\n脚后跟\n\n\ntoe\n脚趾\n\n\n\n\n\n\nvirus\n病毒\n\n\nflu\n流行性感冒\n\n\ninfect\n传染，感染\n\n\ntumour\n肿瘤\n\n\n\n\n\n\nconceive\n怀孕\n\n\ndeliver\n分娩\n\n\nabort\n流产，堕胎\n\n\n\n\n\n\ngasp\n喘气\n\n\npuff\n喘气\n\n\ninhale\n吸气\n\n\nexhale\n呼气\n\n\nsniff\n嗅；闻\n\n\n\n\n\n\ndigest\n消化\n\n\n\n\n\n\nthermometer\n温度计\n\n\nbandage\n绷带\n\n\nphysiology\n生理学\n\n\n\n 科学\n\n\n\n英文\n中文\n\n\n\n\ninnovation\n创新\n\n\nstatistics\n统计学\n\n\n\n\n\n\nastronaut\n宇航员\n\n\n\n\n\n\ngenerator\n发电机\n\n\nvacuum\n真空\n\n\nparticle\n粒子\n\n\ncylinder\n圆柱体\n\n\nsphere\n球体\n\n\nfriction\n摩擦力\n\n\ndensity\n密度；浓度\n\n\n\n\n\n\nsupersonic\n超音速的\n\n\ndigital\n数码的，数字的\n\n\n\n\n\n\ncosmic\n宇宙的\n\n\nsimultaneous\n同步的\n\n\nhomogeneous\n同种类的，同性质的\n\n\nspontaneous\n自发的，自然产生的\n\n\nstationary\n静止的，固定的\n\n\n\n\n\n\ndistill\n蒸馏；提纯\n\n\nblend\n混合\n\n\nretrieve\n找回；检索[计算机]\n\n\n\n\n\n\nmetric\n米制的，公制的\n\n\ngram\n克\n\n\n\n 生活\n\n\n\n英文\n中文\n\n\n\n\nlodge\n住宿\n\n\nlease\n租约\n\n\ntenant\n租客\n\n\nlandlady\n女房东，包租婆\n\n\nslum\n贫民窟\n\n\nstall\n货摊，畜棚\n\n\ncellar\n地下室，地窖\n\n\n\n\n\n\nlocker\n储物柜；带锁的橱柜\n\n\nrack\n架子；行李架\n\n\nlaundry\n洗衣房；待洗衣物\n\n\ntowel\n毛巾\n\n\nlid\n盖子\n\n\n\n\n\n\ngauge/gage\n标准尺寸，规格\n\n\nspecification\n说明书；规格，规范\n\n\n\n\n\n\nlottery\n彩票\n\n\n\n\n\n\nexcursion\n短途旅行\n\n\nexpedition\n远征，探险\n\n\n\n 人物\n\n\n\n英文\n中文\n\n\n\n\npersonality\n性格，人格\n\n\ndisposition\n性格，性情\n\n\n\n\n\n\nempirical\n经验主义的\n\n\neloquent\n有说服力的\n\n\nspiritual\n精神的，心灵的\n\n\n\n\n\n\n\n\n\n\nhospitality\n好客、殷勤\n\n\nkeen\n热心的\n\n\nmodest\n谦虚的\n\n\ncordial\n诚恳的，亲切的\n\n\namiable\n可爱的，亲切的\n\n\ncourtesy\n谦恭有礼\n\n\nnaive\n天真的、幼稚的\n\n\nstraightforward\n坦率地/的\n\n\nconscious\n自觉的；有意识的\n\n\nnotable\n著名的；值得注意的\n\n\nsane\n神志清楚的；明智的\n\n\neloquent\n有说服力的\n\n\nsympathy\n同情心\n\n\nintegrity\n正直，诚实\n\n\nreadily\n乐意地；容易地\n\n\n\n\n\n\nformidable\n可怕的，令人生畏的\n\n\nrigid\n刻板的；严厉的\n\n\neccentric\n古怪的，反常的\n\n\nweird\n古怪的；神秘的\n\n\nego\n自我，自负\n\n\nindifferent\n冷漠的\n\n\nsnobbish\n势利的\n\n\nsolitary\n单独的；独处的\n\n\nindignant\n愤愤不平的\n\n\nroundabout\n拐弯抹角的\n\n\narbitrary\n随心所欲的\n\n\n\n\n\n\nendurance\n耐力\n\n\n\n\n\n\nfatigued\n疲乏的\n\n\nslender\n苗条的\n\n\nmasculine\n男子气概的；男性的\n\n\ntimid\n胆小的\n\n\n\n\n\n\ngrin\n咧嘴笑\n\n\nadore\n崇拜；爱慕\n\n\ntease\n戏弄，取笑，挑逗\n\n\nalienate\n疏远；离间\n\n\ndiscourage\n使泄气；阻碍\n\n\nreproach\n责备\n\n\n\n\n\n\ncorrespondent\n记者；通讯员\n\n\n\n 服装\n\n\n\n英文\n中文\n\n\n\n\ngarment\n衣服\n\n\ntextile\n纺织品\n\n\nscarf\n围巾/头巾\n\n\nveil\n面纱\n\n\nribbon\n缎带，丝带\n\n\nmat\n席子；垫子\n\n\nvest\n背心；马甲\n\n\npants\n长裤；内裤\n\n\ngown\n长袍；女装\n\n\n\n\n\n\nknit\n编织\n\n\nweave\n编织\n\n\n\n 动作\n\n\n\n英文\n中文\n\n\n\n\nstun\n打昏\n\n\nslap\n扇耳光；拍\n\n\nclap\n拍\n\n\nclaw\n抓爪子\n\n\nscratch\n抓；搔\n\n\nplunge\n投入；插进；陷入\n\n\nplug\n插入；塞入插头；塞子\n\n\ngrab\n抓，夺\n\n\ngrip\n紧握，抓紧\n\n\nstir\n搅拌；摇动煽动\n\n\nstrain\n拉紧，用力拉\n\n\nthrust\n戳；刺；插入\n\n\nwhip\n鞭打；抽打\n\n\ndrag\n拖；拖曳\n\n\ntow\n拖，拉\n\n\nfasten\n扎牢；使固定\n\n\nwrench\n猛拉；挣脱；使扭伤扳手；痛苦\n\n\n\n 熟词僻义\n 词汇变形\n","slug":"英语词汇学习","date":"2023-05-03T01:51:13.000Z","categories_index":"","tags_index":"词汇","author_index":"Kevin"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":" 标题1\n测试行内公式：$x^2+y^2=z^2$\n\n\n 标题2\n测试行间公式：\n$$\n    x^2+y^2=z^2\n    y&gt;3\n$$\n\n\n 标题3\n测试表格：\n\n\n\n\ntitle1\ntitle2\ntitle3\n\n\n\n\ncontent1\ncontent2\ncontent3\n\n\n\n\n 标题4\n测试链接：\n[百度](https://www.baidu.com)\n\n\n","slug":"第一篇博客","date":"2023-05-01T15:12:47.000Z","categories_index":"","tags_index":"","author_index":"Kevin"},{"id":"be29bb0db4085d04ddb5f9bb082efc87","title":"hexo使用","content":" hexo主题配置😀\n测试公式渲染：$$f(x)=\\sum_{i=1}{n}i2$$\n\n\n\n\n\n\n\n\n\n参考文章链接：\n\n快速搭建Hexo博客:&gt;&gt;&gt;&lt;&lt;&lt;\nHexo官方文档:&gt;&gt;&gt;Hexo官方文档&lt;&lt;&lt;(个人不推荐，因为官方文档太过简略，不够全面，而且太久没更新，有些坑需要结合他人博客才能填平。)\nAurora官方文档:&gt;&gt;&gt;Hexo主题Aurora使用教程&lt;&lt;&lt;\nmarkdown基本语法:&gt;&gt;&gt;Markdown基本语法&lt;&lt;&lt;\n\n 一.任意主题的通用配置流程📜\n\ngit clone 主题仓库地址 themes/主题名\n修改配置文件：\n\n打开Blog文件夹下的_config.yml文件\n修改theme部分：theme: 主题名\n根据GitHub上主题的说明修改主题配置文件\n\n\n保存配置文件\n\n 二.使用Aurora主题📜\n\n\n\n\n\n\n\n\n\n\n以Aurora为例，其他主题请参考GitHub对应的说明文档或他人博客\n大部分主题的功能都是使用主题配置文件的，但是有部分需要用到 Hexo 插件的就需要在 Hexo 的配置中修改。所以分为&quot;hexo基础设置&quot;和&quot;所选主题基础设置&quot;两部分。\n\n （一）Aurora主题入门设置\n 🔶hexo基础设置\n\n\n\n\n\n\n\n\n\n\n编辑blog文件夹下的_config.yml 文件\nblog文件夹是hexo的根目录（即&quot;hexo init&quot;时所在的文件夹），_config.yml文件是hexo的配置文件，里面有很多参数，这里只介绍和Aurora主题相关的参数。\n\n\n设置 url 和 permalink\n\nurl 为自己的博客地址\n\n例如：https://kevin-lxj.github.io\n\n\npermalink 参数为 /post/:title.html\n\n\n\n_config.yml文件中的url和permalink参数示例：\n    # URL\n    ## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;\n    url: https:&#x2F;&#x2F;kevin-lxj.github.io\n    permalink: &#x2F;post&#x2F;:title.html\n    permalink_defaults:\n    pretty_urls:\n    trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks\n    trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks\n\n设置代码高亮\n\n关闭 Highlight，设置 enable 为 false。\n使用 prismjs，设置 enable 为 true，将 preprocess 设置为 false\n\n\n\n_config.yml文件中的highlight、prismjs参数示例：\nhighlight:\n    enable: false\n    line_number: true\n    auto_detect: false\n    tab_replace: &#39;&#39; \n    wrap: true\n    hljs: false\nprismjs:\n    enable: true\n    preprocess: false\n    line_number: true\n    tab_replace: &#39;&#39;\n\n\n\n\n\n\n\n\n\nAurora 主题使用了 prismjs 作为代码高亮插件，如果不关闭 Highlight，会导致代码高亮两次，从而导致代码高亮失效。\n\n设置主题\n\n设置 theme 为 Aurora\n\n\n\n_config.yml文件中的theme参数示例：\n# Extensions\n## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;\n## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;\ntheme: Aurora\n\n 🔶安装Aurora主题\n\n在blog文件夹下打开终端\n安装主题：npm install hexo-theme-aurora --save\n在 node_modules 目录下的 hexo-theme-aurora 主题文件夹中复制 _config.yml 文件到根目录下，并重命名为 _config.aurora.yml\n\n\n 🔶设置Aurora主题\n\n\n\n\n\n\n\n\n\n编辑blog文件夹下的_config.aurora.yml 文件\n\n设置site参数\n\n\n\n选项\n子属性\n接受类型\n使用说明\n\n\n\n\nsubtitle\n/\nString\n博客自标题，页面主标题后面会跟随这个标题内容。\n\n\nauthor\n/\nString\n博客作者名字，或者是博客名字。会在 header 的 logo 区域显示，也会在博客简介中显示。\n\n\nnick\n/\nString\n博客子名字，会在 header 的 logo 下方显示。\n\n\ndescription\n/\nString\n会在博客简介中显示，用几句话描述博主相关信息（支持 HTML 标签）\n\n\nlanguage\n/\nen, cn\n配置默认博客语言，en 是英文，cn 是中文。\n\n\nmulti_language\n/\ntrue, false\n开启博客的多语言支持\n\n\nlogo\n/\nString\nLogo 的图片链接 image.\n\n\navatar\n/\nString\n头像的图片链接 image.\n\n\nbeian\n/\nObject\n网站备案信息 (从版本 1.1.0 开始，这个配置拥有两个属性)\n\n\n\nnumber\nString\n备案编号.\n\n\n\nlink\nString\n备案链接.\n\n\npolice_beian\n/\nObject\n公安部备案号\n\n\n\nnumber\nString\n备案编号.\n\n\n\nlink\nString\n备案链接.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果不需要备案信息，可以不设置beian、police_beian，可为空，\n_config.aurora.yml文件中的site参数示例：\n    site:\n    subtitle: Kevin&#39;s Blog\n    author: Kevin\n    nick: K\n    description:\n    link: &#39;&#x2F;&#39;\n    language: cn\n    multi_language: true\n    logo: https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20210313122054101.png\n    avatar: https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20210313122054101.png\n    beian:\n        number: &#39;&#39;\n        link: &#39;&#39;\n    police_beian:\n        number: &#39;&#39;\n        link: &#39;&#39;   \n\n （二）Aurora主题进阶设置\n 💠设置菜单menu参数\n 1.设置默认菜单\n\nAurora 拥有 3 个自带样式的页面，分别是关于页、标签页和归档页\n首页和关于页默认是开启的，但是标签和归档页就可以通过修改主题配置里面的 menu 配置来开启或者关闭。\n\n_config.aurora.yml文件中的menu参数示例：\nmenu:\n    About: false\n    # Q：这里的About为什么是false？\n    # A：因为About是默认开启的，如果不想要About页面，就设置为false\n    about: &#x2F;about\n    tags: &#x2F;tags\n    archives: &#x2F;archives\n 2. 自定义菜单\n\n除了默认的菜单，还可以自定义菜单，自定义菜单可以是外部链接，也可以是内部链接。\n例如设置留言板、邮箱等\n\n_config.aurora.yml文件中的menu参数示例：\nmenu:\n    #省略前述代码......\n    message-board:\n        name: &#39;留言板&#39;\n        i18n:\n        cn: &#39;留言板&#39;\n        en: &#39;Message Board&#39;\n        path: &#39;&#x2F;page&#x2F;message-board&#39;\n 3. 设置多级菜单\n\n可以分组一些链接，把一些链接放到二级导航里面\n添加children属性即可\n\n_config.aurora.yml文件中的menu参数示例：\nmenu:\n    #省略前述代码......\n        projects:\n        name: &#39;链接&#39;\n        i18n:\n        cn: &#39;链接&#39;\n        en: &#39;Link&#39;\n        children:\n        Github:\n            name: &#39;YWK&#39;\n            i18n: \n            cn: &#39;凯&#39;\n            en: &#39;K&#39;\n            path: &#39;https:&#x2F;&#x2F;github.com&#x2F;Kevin-LXJ&#x2F;Kevin-LXJ.github.io&#39;\n        Email:\n            name: &#39;邮件&#39;\n            i18n:\n            cn: &#39;邮件&#39;\n            en: &#39;Mail Me&#39;\n            path: &#39;1299664246@qq.com&#39;\n\n 💠设置主题theme参数\n 1. 设置主题深色模式\n\n设置 darkmode 为 true，即可开启深色模式\n设置 darkmode 为 false，即可关闭深色模式\n设置 darkmode 为 auto，即可开启自动深色模式\n\n_config.aurora.yml文件中的theme参数示例：\ntheme:\n    darkmode: true\n 2.设置头像边框形状\n\n设置 profile_shape 为 circle，即可设置头像为圆形\n设置 profile_shape 为 diamond，即可设置头像为六边形\n设置 profile_shape 为 rounded，即可设置头像为圆角矩形\n\n_config.aurora.yml文件中的theme参数示例：\ntheme:\n    profile_shape: circle\n 3.设置主题的渐变颜色\n\n设置渐变颜色，需要设置三个颜色，一个是主色，两个个是辅色\n\n_config.aurora.yml文件中的theme参数示例：\n    theme:\n        # Gradient colors used for the theme\n        # This consist of 3 gradient colors\n        # each can be customized\n        gradient:\n            color_1: &#39;#24c6dc&#39;\n            color_2: &#39;#5433ff&#39;\n            color_3: &#39;#ff0099&#39;\n 4.文章的布局模式\n\n设置 feature 为 true，即可设置为推荐模式\n\n推荐模式会启用一个特殊的区域，让你可以展示特别选定的文章。这个区域可以同时显示三篇推荐文章。\n生成引擎从文章库中选择最新的三篇文章，会根据文章的 markdown 的 Front-Meta 中的 feature 属性来选择文章。只要这个属性是 true，就会被筛选出来作为推荐文章。\n如果没有设置 feature 属性，或者设置为 false，那么这篇文章就不会被选中。\n如果设置了少于3篇文章作为推荐文时，主题生成器将挑选最新的文章，并将其加入推荐数据中，确保展示3 篇推荐文章\n\n\n设置 feature 为 false，即可设置为置顶模式\n\n如果引擎不能找到足够的文章来填补一共 3 篇推荐文章，主题的布局将自动改为“置顶布局模式”。\n\n\n\n_config.aurora.yml文件中的theme参数示例：\ntheme:\n    feature: true\n\n 💠设置网页meta参数\n 1.设置CDN加速\n\n在国内使用国外的 CDN 链接会让网站变得非常的慢，所以这个配置可以根据你的需求切换国际或国内的 CDN。\n\n\n\n属性\n使用\n\n\n\n\nen\n所有脚本将使用 “Jsdelivr CDNs” 的链接。\n\n\ncn\n所有脚本将使用 “BootCDN” 的链接。\n\n\n\n\n\n_config.aurora.yml文件中的site_meta参数示例：\nsite_meta:\n    cdn: cn\n 2.设置SEO meta的默认值\n\ndescription: 对站点的描述.\nkeywords: 网站的关键词.\nauthor: 网站作者.\n\n_config.aurora.yml文件中的site_meta参数示例：\nsite_meta:\n    cdn: cn\n    favicon:\n    description: &#39;&#39;\n    keywords: &#39;&#39;\n    author: &#39;&#39;\n 3.设置SEO meta的自定义值\n\n使用“injectable”设置\ninjects 设置有两个选项，每个选项都可以设置多个 Script 和 CSS 链接。\n\nscripts - 用于配置多个脚本链接\ncss -用于配置多个 css 链接\n\n\n\n_config.aurora.yml文件中的injects参数示例：\ninjects:\n    scripts:\n    css:\n\n 💠设置新的博客页面\n\n使用 Hexo 可以很轻易的创建一个页面，只需要在 source 文件夹中创建一个页面文件夹，然后在里面建立一个 index.md 即可，或者使用 Hexo 的 add 命令。\n例如创建一个关于页面，只需要在 source 文件夹中创建一个 about 文件夹，然后在里面建立一个 index.md 即可，或者使用 Hexo 的 add 命令。\n\nhexo new page about\n\n 💠设置评论插件\n\n\n\n\n\n\n\n\n\n采用Gitalk评论插件\n\nGitalk相关配置参数\n\n\n\n属性\n描述\n\n\n\n\nenable\n使用true开启, 使用false关闭\n\n\nautoExpand\n如果设置为true, Github 评论将会自动展开。否者默认会收起。\n\n\nclientID\nclientID 是你 GitHub 的 Oauth APP 中提供的。\n\n\nclientSecret\nclientSecret 是你 GitHub 的 Oauth APP 中提供的。\n\n\nrepo\n仓库名, 比如: https://github.com/auroral-ui/hexo-theme-aurora-docs, 名字就是 hexo-theme-Aurora-docs\n\n\nowner\n仓库拥有者的用户名. 比如: auroral-ui\n\n\nadmin\n仓库管理员的用户名，这里可以填写多个管理员。(也用于标记那个评论是博主的)\n\n\nid\n确保唯一性和长度小于 50，如果您使用pathname，请确保长度小于 50 个字符或使用uid代替，这个有更好的兼容性 (如果您之前使用其他主题，谁用 uid 将可能无法显示您之前的评论)\n\n\nlanguage\n使用 en 设置为英文，使用 cn 设置为中文.\n\n\ndistractionFreeMode\n与 Facebook 一样的专注模式，点击评论输入框时会让背景变暗。true 来开启 false 来关闭\n\n\nrecentComment\n是否开启最近评论功能。\n\n\nproxy\nGitHub 授权请求的反向代理\n\n\n\n\n\n\n 💠设置机器人插件\n\n基本使用\n\n使用 enable 属性打开机器人，并使用 locale 属性更改语言\n\n\n\n# 开启 Aurora 机器人 Dia\naurora_bot:\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 设置为 true，你可爱的机器人就会启动。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  enable: true\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 该机器人支持两种语言\n  # -- en: 英语\n  # -- cn: 中文\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  locale: en\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 目前只支持使用 Dia，将来会支持 live2d。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  bot_type: dia\n\n其他配置\n\n设置tip属性，可以设置机器人的提示语\n\n\n\n# 这个技巧是用来对用户交互做出反应的\ntips:\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 这些是 Dia 每30秒会说的随机消息。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  messages:\n    - 你好，我是 &lt;span&gt;Dia&lt;&#x2F;span&gt;，好高兴遇见你～\n    - 好久不见，日子过得好快呢……\n    - &#39;&lt;span&gt;大坏蛋！&lt;&#x2F;span&gt;你都多久没理人家了呀，嘤嘤嘤～&#39;\n    - 嗨～快来逗我玩吧！\n    - 拿小拳拳锤你胸口！\n    - 学习使我们快乐，快乐使我们更想学习～\n    - 你知道吗？你可以&lt;span&gt;点击我&lt;&#x2F;span&gt;返回页面顶部哦！～\n    # 这是一个特殊的函数，它将触发 quotes API\n    # 和 Dia 会说出每日引用的信息。\n    - showQuote\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 将在用户打开浏览器控制台时触发。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  console: 哈哈，你打开了控制台，是想要看看我的小秘密吗？\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 当用户从你的博客上复制内容时触发。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  copy: 你都复制了些什么呀，转载要记得加上出处哦！\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 这将在用户返回窗口时触发。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  visibility_change: 老朋友，你怎么才回来呀～\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 欢迎留言，号码是一天中的时间。\n  # -----------------------------------\n  # eg: 24 &#x3D; 00:00 也就是午夜\n  # eg: 17-19 &#x3D; 在下午 5 点到 7 点之间\n  # -----------------------------------\n  # 在一天的这段时间里，Dia 会向你的读者问好\n  # 与相应的消息。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  welcome:\n    &#39;24&#39;: 你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？\n    &#39;5_7&#39;: 早上好！一日之计在于晨，美好的一天就要开始了。\n    &#39;7_11&#39;: 上午好！工作顺利嘛，不要久坐，多起来走动走动哦！\n    &#39;11_13&#39;: 中午了，工作了一个上午，现在是午餐时间！\n    &#39;13_17&#39;: 午后很容易犯困呢，今天的运动目标完成了吗？\n    &#39;17_19&#39;: 傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～\n    &#39;19_21&#39;: 晚上好，今天过得怎么样？\n    &#39;21_23&#39;:\n      - 已经这么晚了呀，早点休息吧，晚安～\n      - 深夜时要爱护眼睛呀！\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 当用户来自搜索引擎时使用。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  referrer:\n    # 用户来自你自己的网站。\n    self: 欢迎来到&lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n    # 用户来自百度搜索引擎。\n    baidu: Hello！来自 百度搜索 的朋友&lt;br&gt;你是搜索 &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt; 找到的我吗？\n    # 用户来自360搜索引擎。\n    so: Hello！来自 360搜索 的朋友&lt;br&gt;你是搜索 &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt; 找到的我吗？\n    # 用户来自谷歌搜索引擎。\n    google: Hello！来自 谷歌搜索 的朋友&lt;br&gt;欢迎阅读&lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n    # 用户来自另一个网站。\n    site: Hello！来自 &lt;span&gt;[PLACEHOLDER]&lt;&#x2F;span&gt; 的朋友\n    # 任何其他来源。\n    other: 感谢您阅读： &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 当你的&#39;鼠标悬停&#39;到特定的HTML标签，Dia将\n  # 给用户留言帮助他们解决问题。\n  # ------------------------------------------------------\n  # selector: 标签选择器(你可以使用任何css选择器)\n  # text: 这是Dia将要传达的信息。(如果你想要的\n  #       Dia从一组信息中随机说出一个，设置它\n  #       数组，否则只是纯文本)\n  #  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  mouseover:\n    # 悬浮在 Dia 上\n    - selector: &#39;#Aurora-Dia&#39;\n      text:\n        - 哇啊啊啊啊啊啊... &lt;span&gt;你想干嘛&lt;&#x2F;span&gt;? O.O\n        - 请您轻一点，我是&lt;span&gt;很昂贵&lt;&#x2F;span&gt;的机器人哦! O.O\n        - &#39;&lt;span&gt;领导，我在呢!&lt;&#x2F;span&gt; 我有什么可以帮到你呢? O.O&#39;\n    # 悬浮在 Home 菜单\n    - selector: &quot;[data-menu&#x3D;&#39;Home&#39;]&quot;\n      text:\n        - 点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\n        - 点它就可以回到首页啦！\n        - 回首页看看吧。\n    # 悬浮在 About 菜单\n    - selector: &quot;[data-menu&#x3D;&#39;About&#39;]&quot;\n      text:\n        - 你想知道我家主人是谁吗？\n        - 这里有一些关于我家主人的秘密哦，要不要看看呢？\n        - 发现主人出没地点！\n    # 悬浮在 Archives 菜单\n    - selector: &quot;[data-menu&#x3D;&#39;Archives&#39;]&quot;\n      text:\n        - 这里存储了主人的所有作品哦！\n        - 想看看主人的图书馆吗？\n    # 悬浮在 Tags 菜单\n    - selector: &quot;[data-menu&#x3D;&#39;Tags&#39;]&quot;\n      text:\n        - 点击就可以看文章的标签啦！\n        - 使用标签可以更好的分类你的文章哦～\n    # 悬浮在 language 菜单\n    - selector: &quot;[data-dia&#x3D;&#39;language&#39;]&quot;\n      text: 主人的博客支持多种语言。\n    # 悬浮在黑白切换按钮上\n    - selector: &quot;[data-dia&#x3D;&#39;light-switch&#39;]&quot;\n      text: 您可以点击这里切换黑白模式哦！\n    # 悬浮在作者简介上\n    - selector: &quot;[data-dia&#x3D;&#39;author&#39;]&quot;\n      text:\n        - 这是我主人的简介。\n        - 点击其中任何一个链接都可以传送到我主人的其他世界。\n    # 悬浮在作跳转评论按钮上\n    - selector: &quot;[data-dia&#x3D;&#39;jump-to-comment&#39;]&quot;\n      text:\n        - 你想看看评论吗?\n        - 点击这里可以帮助你直接跳转到评论部分。\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 当你的&#39;鼠标点击&#39;为特定的HTML标签，Dia将\n  # 给用户留言帮助他们解决问题。\n  # ------------------------------------------------------\n  # 属性与&#39; moveover &#39;事件相同\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  click:\n    # 鼠标点击搜索按钮\n    - selector: &quot;[data-dia&#x3D;&#39;search&#39;]&quot;\n      text:\n        - 没有看到你想要的文章，那么就输入你想搜索的关键词吧～\n        - 可以使用 ctrl&#x2F;cmd + k 快捷键打开搜索哦～\n    # 鼠标点击文章标题\n    - selector: &quot;[data-dia&#x3D;&#39;article-link&#39;]&quot;\n      text:\n        - 希望你会喜欢这篇文章：&lt;span&gt;「&#123;text&#125;」&lt;&#x2F;span&gt;.\n        - 您的选择真的不错哦！好好享受这篇文章吧～\n        - 希望您能从 &lt;span&gt;「&#123;text&#125;」&lt;&#x2F;span&gt;这篇文章中学到点东西。\n    # 鼠标点击跳转评论输入框（Gitalk）\n    - selector: &#39;.gt-header-textarea&#39;\n      text:\n        - 要吐槽些什么呢？\n        - 一定要认真填写喵～\n        - 有什么想说的吗？\n        - 如果觉得文章不错的话，就给博主留个言吧～\n    # 鼠标点击跳转评论输入框（Valine）\n    - selector: &#39;.veditor&#39;\n      text:\n        - 要吐槽些什么呢？\n        - 一定要认真填写喵～\n        - 有什么想说的吗？\n        - 如果觉得文章不错的话，就给博主留个言吧～\n\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 在特定的日期，Dia会向你的读者问候。\n  # ------------------------------------------------------\n  # date: 特别活动的日期(格式:月&#x2F;日或月&#x2F;日-月&#x2F;日)\n  # text:\n  # ---只使用一个简单的字符串。\n  # -——消息的随机集合，使用数组配置格式。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  events:\n    - date: 01&#x2F;01\n      text: &#39;&lt;span&gt;元旦&lt;&#x2F;span&gt;了呢，新的一年又开始了，今年是&#123;year&#125;年～&#39;\n    - date: 02&#x2F;14\n      text: 又是一年&lt;span&gt;情人节&lt;&#x2F;span&gt;，&#123;year&#125;年找到对象了嘛～\n    - date: 03&#x2F;08\n      text: 今天是&lt;span&gt;国际妇女节&lt;&#x2F;span&gt;！\n    - date: 03&#x2F;12\n      text: 今天是&lt;span&gt;植树节&lt;&#x2F;span&gt;，要保护环境呀！\n    - date: 04&#x2F;01\n      text: 悄悄告诉你一个秘密～&lt;span&gt;今天是愚人节，不要被骗了哦～&lt;&#x2F;span&gt;\n    - date: 05&#x2F;01\n      text: 今天是&lt;span&gt;五一劳动节&lt;&#x2F;span&gt;，计划好假期去哪里了吗～\n    - date: 06&#x2F;01\n      text: &#39;&lt;span&gt;儿童节&lt;&#x2F;span&gt;了呢，快活的时光总是短暂，要是永远长不大该多好啊…&#39;\n    - date: &#39;09&#x2F;03&#39;\n      text: &#39;&lt;span&gt;中国人民抗日战争胜利纪念日&lt;&#x2F;span&gt;，铭记历史、缅怀先烈、珍爱和平、开创未来。&#39;\n    - date: &#39;09&#x2F;10&#39;\n      text: &#39;&lt;span&gt;教师节&lt;&#x2F;span&gt;，在学校要给老师问声好呀～&#39;\n    - date: 10&#x2F;01\n      text: &#39;&lt;span&gt;国庆节&lt;&#x2F;span&gt;到了，为祖国母亲庆生！&#39;\n    - date: 11&#x2F;05-11&#x2F;12\n      text: 今年的&lt;span&gt;双十一&lt;&#x2F;span&gt;是和谁一起过的呢～\n    - date: 12&#x2F;20-12&#x2F;31\n      text: 这几天是&lt;span&gt;圣诞节&lt;&#x2F;span&gt;，主人肯定又去剁手买买买了～\n\n (三)bug记录区📌\n 👻tip bug-文章写作\n\nlatex公式无法渲染\n\n\n未解决：采取了网络教程的方法，但是无法解决问题\n复现过程1：\n\n卸载了hexo原生的渲染markdown的插件，安装了@upupming/hexo-renderer-markdown-it-plus插件\n\n发现没有对应的markdown-it-katex包，重新安装了markdown-it-katex包\n发现原生渲染器hexo-renderer-marked仍存在，于是重新卸载了hexo-renderer-marked，并将packkage.json中的hexo-renderer-marked删除\n\n\n在_config.yml中添加了以下代码后，除了公式渲染失败外其他插件均可使用，如emoji\n由于Aurora主题并没有在themes文件夹生成，于是采用下载katex所需的css包，并将其添加到Aurora主题的css文件夹中的方式\n重新渲染后，发现公式仍然无法在网页端渲染\n\n# Markdown config\nmarkdown_it_plus:\n  render:\n    html: true                     \n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: &#39;“”‘’&#39;\n  plugins:\n    - plugin:\n        name: markdown-it-emoji ##支持emoji\n        enable: true\n    - plugin:\n        name: markdown-it-deflist ##支持自定义列表\n        enable: true\n    - plugin:\n        name: markdown-it-footnote ##支持引入参考文献\n        enable: true\n    - plugin:\n        name: markdown-it-sub ##支持H~2~O\n        enable: true\n    - plugin:\n        name: markdown-it-sup ##支持X^2^\n        enable: true\n    - plugin:\n        name: markdown-it-katex ##支持katex公式\n        enable: true\n  anchors: \n    level: 2\n    collisionSuffix: &#39;v&#39;\n    permalink: true\n    permalinkClass: header-anchor\n    permalinkSide: &#39;left&#39;\n    permalinkSymbol: ¶\n\n复现过程2：\n\n安装pandoc软件、\\hexo-renderer-pandoc、mathjax插件\nhexo g失败，报错内容：pandoc exited with code null\n\n\n\n\n自定义容器无法渲染\n\n\n未解决：暂无解决思路\n\n 👻tip bug-评论\n\n评论区部署失败\n\n\n未解决：原想采用gitalk，但涉及到部分安全问题，同时aurora主题相关的配置文档少且旧，不建议使用\n\n","slug":"hexo使用","date":"2023-05-01T15:12:47.000Z","categories_index":"博客,hexo","tags_index":"hexo","author_index":"Kevin"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\n Run server\n$ hexo server\nMore info: Server\n Generate static files\n$ hexo generate\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-01T15:11:53.773Z","categories_index":"","tags_index":"","author_index":"Kevin"}]